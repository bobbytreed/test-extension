{"version":3,"file":"extension.js","mappings":"0DAEA,MAAMA,EAAe,EAAQ,KACvB,QAAEC,EAAO,UAAEC,GAAc,EAAQ,KAEjCC,EAAU,oEAChB,IAAIC,EAAa,GAEjB,MAAMC,EAAc,IACbD,GACI,IAAIE,SAASC,IAClBP,EAAaQ,KAAKL,GAAS,CAACM,EAAKC,KAC/BN,EAAaK,EAAM,IAAMC,EACzBH,EAAQH,EAAW,GACnB,IAMFO,EAAkB,KACtB,IAAKP,EACH,IACEA,EAAaJ,EAAaY,SAAST,EAAS,CAAEU,SAAU,QAC1D,CAAE,MAAOC,GACPV,EAAa,GACf,CAEF,OAAOA,CAAU,EAQbW,EAAQ,QAORC,EAAO,OAEPC,EAAcC,GAAMA,EAAEC,SAAS,eAAiBD,EAAEC,SAAS,YAE3DC,EAAmB,KACvB,MAAMC,EAASnB,IACf,OAAImB,EAAOC,QAAUD,EAAOC,OAAOC,oBAC1BR,EAELS,MAAMC,QAAQJ,EAAOK,gBACnBL,EAAOK,cAAcC,KAAKV,GACrBD,EAGJ,IAAI,EAGPY,EAAqBlB,IACzB,MAAOmB,EAASC,GAAQpB,EAAIqB,MAAM,WAClC,OAAIF,GAAWA,EAAQV,SAASJ,GACvBA,EAELe,GAAQA,EAAKX,SAASH,GACjBA,EAEF,IAAI,EAOPgB,EAASC,UACb,IAAID,EAAS,KACb,GAAI/B,MACF+B,EAASZ,KACJY,GAAQ,CACX,MAAMtB,QAAYL,IAClB2B,EAASJ,EAAkBlB,EAC7B,CAEF,OAAOsB,CAAM,EAOTE,EAAa,KACjB,IAAIF,EAAS,KACb,GAAI/B,MACF+B,EAASZ,KACJY,GAAQ,CACX,MAAMtB,EAAMC,IACZqB,EAASJ,EAAkBlB,EAC7B,CAEF,OAAOsB,CAAM,EAeTG,EAAoB,KACxB,MAAMd,EAASnB,IACf,OAAImB,EAAOC,QAAUD,EAAOC,OAAOC,oBAC1BF,EAAOC,OAAOC,oBAEhB,IAAI,EAGPa,EAAiBC,GAAMA,EAAEC,OAAOP,MAAM,OAAO,GAE7CQ,EAAsB7B,IAC1B,MAAOmB,EAASC,EAAMU,GAAQ9B,EAAIqB,MAAM,WACxC,OAAIF,GAAWA,EAAQV,SAASJ,GACvBqB,EAAcP,GAEnBC,GAAQU,GAAQV,EAAKX,SAASH,GACzBoB,EAAcI,GAEhB,IAAI,EAmCbC,EAAOC,QAAU,CACf3B,QACAC,OACAgB,SACAE,aACAS,gBAlEsBV,SAAYhC,WAAmB+B,MAAajB,EAmElE6B,oBA7D0B,IAAM3C,KAAaiC,MAAiBnB,EA8D9D8B,QAnCcZ,UACd,IAAIY,EAAU,KACd,GAAI5C,MACF4C,EAAUV,KACLU,GAAS,CACZ,MAAMnC,QAAYL,IAClBwC,EAAUN,EAAmB7B,EAC/B,CAEF,OAAOmC,CAAO,EA2BdC,YApBkB,KAClB,IAAID,EAAU,KACd,GAAI5C,MACF4C,EAAUV,KACLU,GAAS,CACZ,MAAMnC,EAAMC,IACZkC,EAAUN,EAAmB7B,EAC/B,CAEF,OAAOmC,CAAO,E,uBCnKhB,MAAM5C,EAAU,IAA2B,UAArB8C,QAAQC,SAE9B,IAAI3B,EAAS,KAWboB,EAAOC,QAAU,CAAEzC,UAASC,UAVV,KACXmB,IAEHA,EAASpB,KAAa8C,QAAQ1B,OAC1B0B,QAAQ1B,OAAOnB,YACf,CAAC,GAEAmB,G,gBCZT,IAAI4B,EAAK,EAAQ,KACbC,EAAO,EAAQ,IACfC,EAAM,EAAQ,KAEdC,EAAQL,QAAQM,QAAUN,QAAQM,OAAOC,WAAc,CAAC,EACxDC,IAAkBR,QAAQS,IAAIC,eAC9BC,EAAWX,QAAQW,SACnBC,EAAMD,EAASE,SACfF,EAASG,MAAQd,QAAQe,SAG3BH,EAAM,eAER,IAAII,EA+LEhB,QAAQW,UAAYX,QAAQW,SAASM,UACrCjB,QAAQS,IAAIS,sBACS,oBAAXC,QAA0BA,OAAOnB,SAAmC,aAAxBmB,OAAOnB,QAAQoB,KAjM9C,WAAa,OACtCC,EAAOrB,QAAQqB,KACfpB,EAAWD,QAAQC,SACnBqB,EAAOtB,QAAQS,IAAIc,OAiMvB,SAAiBtB,GACf,GAAiB,UAAbA,EAAsB,OAAO,EACjC,MAAM,WAAEd,EAAU,KAAElB,GAAS,EAAQ,KACrC,OAAOkB,MAAiBlB,CAC1B,CArMgCuD,CAAOvB,GAAY,OAAS,SACxDwB,EAAOzB,QAAQS,IAAIiB,cAAyB,UAATL,EAAmB,IAAMhB,EAAKsB,cAAgB,GACjFC,GAAMjB,EAASiB,IAAM,IAAI5C,MAAM,KAAK,GAIxC,SAAS6C,EAAMC,GAIX,OAAO,QAAwBD,EAAK1B,KAAK2B,GAG7C,CAiEA,SAASC,EAAaD,GACpB,IACE,OAAO5B,EAAG6B,YAAYD,EACxB,CAAE,MAAOpE,GACP,MAAO,EACT,CACF,CAEA,SAASsE,EAAUF,EAAKG,GACtB,IAAIC,EAAQH,EAAYD,GAAKG,OAAOA,GACpC,OAAOC,EAAM,IAAM/B,EAAKgC,KAAKL,EAAKI,EAAM,GAC1C,CAEA,SAASE,EAAYC,GACnB,MAAO,UAAUC,KAAKD,EACxB,CAEA,SAASE,EAAYF,GAEnB,IAAIG,EAAMH,EAAKrD,MAAM,KACrB,GAAmB,IAAfwD,EAAIC,OAAR,CAEA,IAAIxC,EAAWuC,EAAI,GACfE,EAAgBF,EAAI,GAAGxD,MAAM,KAEjC,GAAKiB,GACAyC,EAAcD,QACdC,EAAcC,MAAMC,SAEzB,MAAO,CAAEP,OAAMpC,WAAUyC,gBATH,CAUxB,CAEA,SAASG,EAAY5C,EAAUoB,GAC7B,OAAO,SAAUyB,GACf,OAAa,MAATA,GACAA,EAAM7C,WAAaA,GAChB6C,EAAMJ,cAActE,SAASiD,EACtC,CACF,CAEA,SAAS0B,EAAeC,EAAGC,GAEzB,OAAOD,EAAEN,cAAcD,OAASQ,EAAEP,cAAcD,MAClD,CAEA,SAASS,EAAWC,GAClB,IAAIX,EAAMW,EAAKnE,MAAM,KAEjBoE,EAAO,CAAED,KAAMA,EAAME,YAAa,GAEtC,GAAkB,SAHFb,EAAIc,MAGpB,CAEA,IAAK,IAAIC,EAAI,EAAGA,EAAIf,EAAIC,OAAQc,IAAK,CACnC,IAAIC,EAAMhB,EAAIe,GAEd,GAAY,SAARC,GAA0B,aAARA,GAA8B,gBAARA,EAC1CJ,EAAKpC,QAAUwC,OACV,GAAY,SAARA,EACTJ,EAAKK,MAAO,OACP,GAAwB,QAApBD,EAAIE,MAAM,EAAG,GACtBN,EAAKxC,IAAM4C,EAAIE,MAAM,QAChB,GAAwB,OAApBF,EAAIE,MAAM,EAAG,GACtBN,EAAKxB,GAAK4B,EAAIE,MAAM,QACf,GAAwB,SAApBF,EAAIE,MAAM,EAAG,GACtBN,EAAK3B,KAAO+B,EAAIE,MAAM,OACjB,IAAY,UAARF,GAA2B,SAARA,EAG5B,SAFAJ,EAAK9B,KAAOkC,CAGd,CAEAJ,EAAKC,aACP,CAEA,OAAOD,CAxBmB,CAyB5B,CAEA,SAASO,EAAW3C,EAASJ,GAC3B,OAAO,SAAUwC,GACf,QAAY,MAARA,GACAA,EAAKpC,UAAYA,IAUzB,SAA0BoC,GACxB,MAAwB,SAAjBA,EAAKpC,SAAsBoC,EAAKK,IACzC,CAZqCG,CAAgBR,IAC7CA,EAAKxC,MAAQA,IAAQwC,EAAKK,MAC1BL,EAAKxB,IAAMwB,EAAKxB,KAAOA,GACvBwB,EAAK3B,MAAQ2B,EAAK3B,OAASA,GAC3B2B,EAAK9B,MAAQ8B,EAAK9B,OAASA,EAGjC,CACF,CAMA,SAASuC,EAAa7C,GAEpB,OAAO,SAAUgC,EAAGC,GAClB,OAAID,EAAEhC,UAAYiC,EAAEjC,QACXgC,EAAEhC,UAAYA,GAAW,EAAI,EAC3BgC,EAAEpC,MAAQqC,EAAErC,IACdoC,EAAEpC,KAAO,EAAI,EACXoC,EAAEK,cAAgBJ,EAAEI,YACtBL,EAAEK,YAAcJ,EAAEI,aAAe,EAAI,EAErC,CAEX,CACF,CArLA3D,EAAOC,QAAUkC,EAWjBA,EAAK1B,KAAO,SAAU2B,GAEpB,IAAIgC,EADJhC,EAAM3B,EAAK3C,QAAQsE,GAAO,KAE1B,IAME,IAAIiC,GAHFD,EAAc,QAAwB3D,EAAKgC,KAAKL,EAAK,iBAAiBO,MAG9C2B,cAAcC,QAAQ,KAAM,KAAO,YACzDjE,QAAQS,IAAIsD,KAAUjC,EAAM9B,QAAQS,IAAIsD,GAC9C,CAAE,MAAOrG,GAAM,CACf,IAAK8C,EAAe,CAClB,IAAI0D,EAAUlC,EAAS7B,EAAKgC,KAAKL,EAAK,iBAAkBM,GACxD,GAAI8B,EAAS,OAAOA,EAEpB,IAAIC,EAAQnC,EAAS7B,EAAKgC,KAAKL,EAAK,eAAgBM,GACpD,GAAI+B,EAAO,OAAOA,CACpB,CAEA,IAAIC,EAAW5G,EAAQsE,GACvB,GAAIsC,EAAU,OAAOA,EAErB,IAAIC,EAAS7G,EAAQ2C,EAAKmE,QAAQtE,QAAQuE,WAC1C,GAAIF,EAAQ,OAAOA,EAEnB,IAAIG,GAAqC,KAAlBV,EAAY,GAAY,GAAK,IAAMA,EAAc,KAAOA,EAAc,IAAM7D,EAAW,IAAMoB,EACpH,IAEE,OAAOoD,EADetE,EAAKmE,QAAQ,qBAAgClE,EAAIsE,cAAcvE,EAAKgC,KAAKL,EAAK,kBAAkBtE,QAAQgH,IAEhI,CAAE,MAAMG,GAAQ,CAEhB,IAAIC,EAAS,CACX,YAAc3E,EACd,QAAUoB,EACV,WAAaL,EACb,OAASJ,EACT,MAAQgB,EACRH,EAAO,QAAUA,EAAO,GACxB,QAAUH,EACV,QAAUtB,QAAQW,SAASkE,KAC3B7E,QAAQW,SAASM,SAAW,YAAcjB,QAAQW,SAASM,SAAW,GAC1B,gBAC5CgB,OAAOW,SAAST,KAAK,KAEvB,MAAM,IAAI2C,MAAM,iCAAmCF,EAAS,sBAAwB9C,EAAM,iBAAmB0C,EAAkB,MAE/H,SAAShH,EAASsE,GAEhB,IACIgB,EADSf,EAAY5B,EAAKgC,KAAKL,EAAK,cAAciD,IAAIxC,GACvCN,OAAOY,EAAW5C,EAAUoB,IAAO2D,KAAKjC,GAAe,GAC1E,GAAKD,EACL,OAAO2B,EAAYtE,EAAKgC,KAAKL,EAAK,YAAagB,EAAMT,MACvD,CACA,SAASoC,EAAaQ,GAEpB,IAEIC,EAFSnD,EAAYkD,GAAWF,IAAI7B,GAChBjB,OAAO0B,EAAU3C,EAASJ,IAC1BoE,KAAKnB,EAAY7C,IAAU,GACnD,GAAIkE,EAAQ,OAAO/E,EAAKgC,KAAK8C,EAAWC,EAAO/B,KACjD,CACF,EA6HAtB,EAAKqB,UAAYA,EACjBrB,EAAK8B,UAAYA,EACjB9B,EAAKgC,YAAcA,EACnBhC,EAAKU,WAAaA,EAClBV,EAAKgB,WAAaA,EAClBhB,EAAKkB,cAAgBA,C,sBC9NrBrD,EAAOC,QAAUwF,QAAQ,gB,uBCAzBzF,EAAOC,QAAUwF,QAAQ,K,uBCAzBzF,EAAOC,QAAUwF,QAAQ,S,sBCAzBzF,EAAOC,QAAUwF,QAAQ,O,uBCAzBzF,EAAOC,QAAUwF,QAAQ,M,ybCgBzB,MAAMC,aAAe,IAAIC,aAAa,GAChCC,WAAa,IAAIC,WAAWH,aAAaI,OAAQ,EAAG,GAC1D,IAAIC,eAAgB,EAChBC,YAqHAC,SApHJ,IACCD,YAAc,IAAIE,WACnB,CAAE,MAAOjB,GAAQ,CAKV,SAASkB,SAASC,EAAKlB,EAAQe,EAAUI,GAC/C,IAAIC,EAAapB,EAAOqB,SAGxB,OAFKD,IACJA,EAAcpB,EAAOqB,SAAW,IAAIC,SAAStB,EAAOY,OAAQZ,EAAOuB,WAAcvB,EAAOwB,WAAa,GAAM,GAAM,WACnGN,GACf,IAAK,SACJ,IAAIO,EAAYP,EAAIrD,OAChB6D,EAAKR,EAAIS,WAAW,GAGxB,GAFMD,GAAM,KACX1B,EAAOe,KAAc,IAClBU,EAAY,GAAM,CACrB,IAAI9C,EAAGiD,EACP,IAAKjD,EAAI,EAAGA,EAAI8C,EAAW9C,IAC1B+C,EAAKR,EAAIS,WAAWhD,GAChB+C,GAAM,GACT1B,EAAOe,KAAc,EACrBf,EAAOe,KAAcW,GACXA,EAAK,IACf1B,EAAOe,KAAcW,EACXA,EAAK,MACf1B,EAAOe,KAAcW,GAAM,EAAI,IAC/B1B,EAAOe,KAAmB,GAALW,EAAY,KAEf,QAAZ,MAALA,IAC2C,QAAZ,OAA9BE,EAAKV,EAAIS,WAAWhD,EAAI,MAE1B+C,EAAK,QAAiB,KAALA,IAAgB,KAAY,KAALE,GACxCjD,IACAqB,EAAOe,KAAcW,GAAM,GAAK,IAChC1B,EAAOe,KAAcW,GAAM,GAAK,GAAO,IACvC1B,EAAOe,KAAcW,GAAM,EAAI,GAAO,IACtC1B,EAAOe,KAAmB,GAALW,EAAY,MAEjC1B,EAAOe,KAAcW,GAAM,GAAK,IAChC1B,EAAOe,KAAcW,GAAM,EAAI,GAAO,IACtC1B,EAAOe,KAAmB,GAALW,EAAY,IAGpC,MAKC,GAJI1B,EAAO6B,UACVd,GAAYf,EAAO6B,UAAUX,EAAKH,GAElCA,GAAYD,YAAYgB,WAAWZ,EAAKlB,EAAO+B,SAAShB,IAAWiB,QAChEjB,EAAWf,EAAOnC,OAAS,EAC9B,MAAM,IAAIoE,WAAW,wCAEvB,MACD,IAAK,SACJzB,aAAa,GAAKU,EAClB,IAEIrD,EAFAqE,EAASxB,WAAW,GACpByB,EAAUzB,WAAW,GAEzB,OAAIQ,EAAM,GACTE,EAAWgB,SAASrB,EAAW,IAAMmB,IAAW,EAAMC,GAAW,KACjEf,EAAWgB,SAASrB,EAAW,GAAc,WAAVoB,KAA0B,GAC7Df,EAAWgB,SAASrB,EAAW,GAAc,GAATmB,EAAgB,KAAQ,GAAG,GACxDnB,EAAW,IAElBlD,EADoB,GAATqE,GAAiBf,EACnB,EACU,QAATe,EACD,EACDA,GAAqB,GAAVC,EACV,EAEA,EAEVf,EAAWgB,SAASrB,EAAW,EAAIoB,IAAY,EAAK,WACpDf,EAAWgB,SAASrB,EAAW,EAAImB,IAAW,EAAMC,GAAW,IAE/Df,EAAWgB,SAASrB,EAAW,GAAa,GAATmB,IAAiB,GAAG,GAChDnB,EAAWlD,GACnB,IAAK,SACJ,GAAIqD,EAAK,CACR,GAAIrH,MAAMC,QAAQoH,GAAM,CACvB,IAAK,IAAIvC,EAAI,EAAG0D,EAAInB,EAAIrD,OAAQc,EAAI0D,EAAG1D,IAClCA,EAAI,IACPqB,EAAOe,KAAc,GACtBA,EAAWE,SAASC,EAAIvC,GAAIqB,EAAQe,GAAU,GAE/C,KACD,CAAO,GAAIG,aAAeoB,WAAY,CACrCtC,EAAOuC,IAAIrB,EAAKH,GAChBA,GAAYG,EAAIrD,OAChB,KACD,CACC,MAAM,IAAIqC,MAAM,sCAElB,CACCF,EAAOe,KAAc,EACrB,MACF,IAAK,UAEJ,OADAK,EAAWoB,UAAUzB,IAAYG,EAAM,EAAI,GAAG,GACvCH,EACR,IAAK,SACJ,OAAOE,SAASwB,OAAOvB,GAAMlB,EAAQe,EAAUI,GAChD,IAAK,YACJ,OAAOJ,EAER,IAAK,SAEJ,OADAf,EAAOe,KAAc,EACdE,SAASC,EAAIwB,YAAa1C,EAAQe,EAAUI,GACpD,QACC,MAAM,IAAIjB,MAAM,wCAA0CgB,GAI3D,OAFIL,gBAAkBM,GACrBC,EAAWoB,UAAUzB,EAAU,GACzBA,CACR,CAGO,SAAS4B,QAAQ/B,EAAQgC,EAAOC,EAAK1B,GAC3CP,EAAOiC,GAAO,EACd9B,SAAW6B,EACX,IACIE,EADAC,EAAcnC,EAAOG,UAEzB,GAAIgC,EAAc,GAClB,GAAIA,EAAc,EAEjB,GADAhC,WACmB,GAAfgC,EACHD,GAAQ,OACF,GAAmB,GAAfC,EACVD,GAAQ,OACF,GAAmB,GAAfC,EACVD,EAAQ,SACF,IAAmB,GAAfC,EAGV,OAAOT,WAAWU,UAAUlE,MAAMmE,KAAKrC,EAAQgC,EAAOC,GAFtDC,EAAQI,OAAOC,IAAIC,WAAWxC,GAE2B,KACpD,CACN,IAGIsB,EAHAb,EAAWT,EAAOS,WAAaT,EAAOS,SAAW,IAAIC,SAASV,EAAOA,OAAQA,EAAOW,WAAcX,EAAOY,WAAa,GAAM,GAAM,IAClIW,EAAUd,EAASgC,SAAStC,WAAa,EACzCuC,EAAOT,EAAM9B,SAEbuC,EAAO,GACVpB,EAASb,EAASgC,SAAStC,SAAW,GACtCoB,GAAWD,IAAW,GAClBoB,GAAQ,IACXpB,IAAW,MAEZA,IAAmB,EACfoB,EAAO,IACVpB,GAAkBtB,EAAOG,SAAW,IAAM,IAG3CmB,EAAS,EACNa,EAAc,KAEjBZ,GAAoB,WACpBD,GAAUA,GAEXxB,WAAW,GAAKyB,EAChBzB,WAAW,GAAKwB,EAChBY,EAAQtC,aAAa,GACrBO,UAAY,CACb,MAEoB,IAAfgC,GACHhC,WAED+B,EAAQM,WAAWxC,GAUpB,KAAOG,SAAW8B,GAAK,CAGtB,GAFyB,IAArBjC,EAAOG,WACVA,WACGI,EAEH,OADAoC,QAAQxC,SAAWA,SACZ+B,EAER,IAAIU,EAAYb,QAAQ/B,EAAQG,SAAU8B,GAAK,GAC3CC,aAAiBjJ,MACpBiJ,EAAMW,KAAKD,GAEXV,EAAQ,CAAEA,EAAOU,EACnB,CACA,OAAOV,CACR,CACO,MAAMY,sBAAwB,IAAM7C,eAAgB,EAE9C0C,QAAU,CACtBtC,SACA0B,QACAe,uBAED,IAAIC,aAAe,GACfC,eAAiB,EACrB,MAAMC,cAAkC,oBAAXC,OACvBC,kBAAoBF,cAAgBC,OAAOE,gBAAkB1B,WACtD2B,YAAe/C,IAC3B,IAAIgD,EACAN,eAAiB,IAAMD,aAAa9F,SACvC8F,aAAe,IAAII,kBAAkB,MACrCH,eAAiB,EACjBM,GAAY,GAEb,IACC,IAAIC,EAASR,aAAa7E,MAAM8E,eAAgBA,eAAiB3C,SAASC,EAAKyC,aAAcC,iBAC7F,GAAIA,eAAiBD,aAAa9F,OAAQ,CACzC,GAAIqG,EACH,MAAM,IAAIhE,MAAM,oBACjB,OAAO+D,YAAY/C,EACpB,CACA,OAAOiD,CACR,CAAE,MAAMpE,GACP,GAAImE,EACH,MAAMnE,EAEP,OADA6D,eAAiBD,aAAa9F,OACvBoG,YAAY/C,EACpB,GAEYkD,cAAiBC,GACtB1B,QAAQ0B,EAAc,EAAGA,EAAaxG,QAExCyG,aAAeC,OAAOD,aAC5B,SAASE,oBACR,IAAIC,EAAkB,gBAClBC,EAAW,GACf,IAAK,IAAI/F,EAAI,EAAGA,EAAI,GAAMA,IAAK,CAC9B,IAAIgG,EAAIL,aAAyB,IAAP,GAAJ3F,IAAiB2F,aAAwB,IAAV3F,GAAK,IAC1D8F,GAAmB,aACbE,mCACAA,uBACCA,cAAcA,kBAAkBA,uCAEhCA,qBACHA,mEAEoBD,kBAGxBA,EAASjB,KAAKkB,GACL,KAALhG,GACHiG,YACF,CAEA,OADAH,GAAmB,uBAAuBC,2BACnCD,CACR,CAEA,IAAII,iBACJ,SAASD,WAAWE,EAAOC,GAC1B,GAAuB,MAAV,IAARD,GAGJ,OAAiB,GAARA,IAAiB,EADM,GAAlBC,EAAIhE,YAEZ,GAAuB,MAAV,IAAR+D,GAIX,OAAiB,GAARA,IAAiB,IAFM,GAAlBC,EAAIhE,cAEwB,EADV,GAAlBgE,EAAIhE,YAEZ,GAAuB,MAAV,IAAR+D,GAAwB,CAEnC,GAAID,iBAIJ,OAHAC,EAAQD,iBACRA,iBAAmB,KACnB9D,UAAY,EACL+D,EAKP,IAAIE,GAAiB,EAARF,IAAiB,IAHE,GAAlBC,EAAIhE,cAG8B,IAFhB,GAAlBgE,EAAIhE,cAEgD,EADlC,GAAlBgE,EAAIhE,YAQlB,OANIiE,EAAO,QACXA,GAAQ,MACRA,EAAO,MAAiB,KAAPA,EACjBH,iBAAqBG,IAAS,GAAM,KAAS,MAC7CjE,UAAY,GAELiE,CACR,CACC,OAAOF,CAET,CAEA,MAAM1B,WAAa6B,KAAKT,qBAEjB,SAASU,YAAY9G,EAAGC,GAE9B,GAAgB,iBAALD,EAAe,CACzB,IAAKA,EACJ,OAAY,MAALC,EAAY,GAAK,EAEzB,GAAID,EAAE+G,QACL,OAAS,MAAL9G,EACI,EACGA,EAAE8G,QACL/G,EAAE+G,QAAQ9G,IAET,EAGV,IAAI+G,EACJ,GAAI/G,aAAaxE,MAAO,CACvB,IAAI8E,EAAI,EACR,KAAqD,IAA9CyG,EAAkBF,YAAY9G,EAAEO,GAAIN,EAAEM,MAAaA,GAAKP,EAAEP,QAChEc,IAED,OAAOyG,CACR,CAEA,OADAA,EAAkBF,YAAY9G,EAAE,GAAIC,GACb,GAAnB+G,GAAwBhH,EAAEP,OAAS,EAC/B,EACDuH,CACR,CAAO,cAAWhH,UAAYC,GACZ,iBAAND,IACVA,EAAI8E,OAAOmC,OAAOjH,GAClBC,EAAI6E,OAAOmC,OAAOhH,IAEZD,EAAIC,GAAK,EAAID,IAAMC,EAAI,EAAI,GAEd,iBAALA,EACXA,aAAaxE,OACRqL,YAAY7G,EAAGD,GACjB,EAEAkH,iBAAiBlH,GAAKkH,iBAAiBjH,IAAM,EAAI,CAE1D,CACA,MAAMiH,UAAY,CACjBC,OAAQ,EACRC,UAAW,EACXC,QAAS,EACTC,OAAQ,EACRC,OAAQ,GAEIC,YAAc,KACdC,YAAc,IAAIvD,WAAW,CAAC,K,GCtWvCwD,yBAA2B,CAAC,EAGhC,SAASC,oBAAoBC,GAE5B,IAAIC,EAAeH,yBAAyBE,GAC5C,QAAqBR,IAAjBS,EACH,OAAOA,EAAalL,QAGrB,IAAID,EAASgL,yBAAyBE,GAAY,CAGjDjL,QAAS,CAAC,GAOX,OAHAmL,oBAAoBF,GAAUlL,EAAQA,EAAOC,QAASgL,qBAG/CjL,EAAOC,OACf,CCrBAgL,oBAAoBI,EAAI,CAACpL,EAASqL,KACjC,IAAI,IAAIlF,KAAOkF,EACXL,oBAAoBM,EAAED,EAAYlF,KAAS6E,oBAAoBM,EAAEtL,EAASmG,IAC5EoF,OAAOC,eAAexL,EAASmG,EAAK,CAAEsF,YAAY,EAAMC,IAAKL,EAAWlF,IAE1E,ECND6E,oBAAoBM,EAAI,CAACK,EAAKC,IAAUL,OAAOtD,UAAU4D,eAAe3D,KAAKyD,EAAKC,GCClFZ,oBAAoBc,EAAK9L,IACH,oBAAXmI,QAA0BA,OAAO4D,aAC1CR,OAAOC,eAAexL,EAASmI,OAAO4D,YAAa,CAAEhE,MAAO,WAE7DwD,OAAOC,eAAexL,EAAS,aAAc,CAAE+H,OAAO,GAAO,E,uRCFvD,IAAIiE,EAAKC,EAAKC,EAAKC,EAAaC,EAAQC,EAAYC,EAAkBC,EAAwBC,EAAkBC,EAAcC,EAAiBhL,EAAMnB,EAAIoM,EAAIC,EAAQC,EAAQC,EAAW,EAAMC,EAAcC,EAAeC,EAAiBC,EAAoCC,EAAaC,EAAcC,EAAWC,EAAiBC,EAAO,EAAUC,EAASC,EAAUC,EAAUC,EAAiBC,EAAkBC,EAAmBC,EAAmBC,EAAiBC,EACtd,EAAO,EACP,IACWC,EAAc,GADX,IAAAtJ,UAAQ,IAAAuJ,eAAc,mEAAkB5J,QAAQ,QAAS,KAsChE,SAAS6J,EAAmBC,GAClCpC,EAAMoC,EAAUpC,IAChBC,EAAMmC,EAAUnC,IAChBC,EAAMkC,EAAUlC,IAChBC,EAAciC,EAAUjC,YACxBE,EAAa+B,EAAU/B,WACvBC,EAAmB8B,EAAU9B,iBAC7BC,EAAyB6B,EAAU7B,uBACnCC,EAAmB4B,EAAU5B,kBAAoB,WAAY,EAC7DW,EAAciB,EAAUjB,YACxBC,EAAgBgB,EAAUhB,aAC1BC,EAAYe,EAAUf,UACtBC,EAAkBc,EAAUd,gBAC5BZ,EAAkB0B,EAAU1B,gBAC5BD,EAAe2B,EAAU3B,aACzBsB,EAAkBK,EAAUL,gBAC5BN,EAAWW,EAAUX,SACrBD,EAAUY,EAAUZ,QACpB,EAAWY,EAAUpI,SACrB0H,EAAWU,EAAUV,SACrBC,EAAkBS,EAAUT,gBAC5BC,EAAmBQ,EAAUR,iBAC7BC,EAAoBO,EAAUP,kBAC9BC,EAAoBM,EAAUN,kBAC9BP,EAAQa,EAAUb,MAClBS,EAAWI,EAAUJ,SACrB5B,EAASgC,EAAUhC,OACnBU,EAAYsB,EAAUtB,UAClBsB,EAAUvB,SACPA,EAASuB,EAAUvB,OAC3B,CCzEO,SAASwB,EAAKC,EAASC,EAAUC,GACtC,OAAIF,GAAWA,EAAQG,KACdD,EACLF,EAAQG,KAAKF,EAAUC,GACvBF,EAAQG,KAAKF,GAEVA,EAASD,EAClB,CCLA,IAAII,EFMArO,QAAQe,MAiCZ+M,EAAmBF,GErCnB,MAAMU,EAAoB,SACpBC,EAAyB,IACzBC,EAAgB,UAChBC,EAAgB,UAChBC,EAAc,UACdC,EAAa,WACNC,EAAmB,SAC1BC,EAAoB,IACpBC,EAAoB,KACpBC,GAAa,GACbC,GAAU,EACVC,GAAgC,KAChCC,GAA6B,KAE7BC,GAAuB5R,QAAQC,SAAQ,GACvC4R,GAAoB7R,QAAQC,SAAQ,GAC1C2R,GAAqBE,QAAS,EAC9BD,GAAkBC,QAAS,EAC3B,MAAMC,GAAkB/R,QAAQC,SAAQ,GAC3B+R,GAAQ,sBACRC,GAAY,sBACnBC,GAAiB,CAAC,EAClBC,GAAwC,oBAARC,KAAsBC,YAAcC,kBACpEC,GAA6B,oBAAVpH,OAAwB,SAASlD,GAAU,OAAOkD,OAAOqH,KAAKvK,EAAQ,EAAI0B,WAC7F8I,GAAmC,oBAAhBC,aAA8BA,aAAeC,WAEhEC,GAAoB,MAq1B1B,MAAMC,WAAc3R,MACnB4R,YAAYnC,GACXoC,QACAC,KAAKrC,SAAWA,CACjB,CACAsC,IAAI1K,EAAK4B,GACR6I,KAAKlI,KAAK,CAAEjH,KAAM,MAAO0E,MAAK4B,SAC/B,CACA+I,IAAI3K,GACHyK,KAAKlI,KAAK,CAAEjH,KAAM,MAAO0E,OAC1B,CACA4K,QACCH,KAAKI,OAAO,EAAGJ,KAAK9N,OACrB,CACAyK,MAAMgB,GACL,OAAOqC,KAAKrC,SAASqC,KAAMrC,EAC5B,ECn4BM,MAAM0C,GAAO,CAAC,EACfC,GAAO,CACZnJ,MAAO,KACPoJ,MAAM,GAEFhJ,OAAOiJ,gBACXjJ,OAAOiJ,cAAgBjJ,OAAOC,IAAI,yBAG5B,MAAMiJ,GACZX,YAAYY,GACPA,IACHV,KAAKpD,QAAU8D,EAAYnJ,OAAOoJ,UAAUC,KAAKF,GAEnD,CACAlM,IAAIqM,GACH,IAAIC,EAASd,KACTe,EAAW,IAAIN,GAmDnB,OAlDAM,EAASnE,QAAWjO,IACnB,IAAIgS,EAAWG,EAAOvJ,OAAOoJ,UAAUhS,GACnCqE,EAAI,EACR,MAAO,CACNgO,KAAKC,GACJ,IAAIzI,EACJ,EAAG,CACF,IAAI0I,EACJ,GAAID,EACHC,EAAiBD,EACjBA,EAAiB,UAGjB,GADAC,EAAiBP,EAASK,OACtBE,EAAerD,KAClB,OAAOqD,EAAerD,MAAKqD,GAAkBlB,KAAKgB,KAAKE,KAGzD,IAA4B,IAAxBA,EAAeX,KAGlB,OAFAP,KAAKO,MAAO,EACRQ,EAASI,QAAQJ,EAASI,SACvBD,EAGR,GADA1I,EAASqI,EAAKK,EAAe/J,MAAOnE,KAChCwF,GAAUA,EAAOqF,KACpB,OAAOrF,EAAOqF,MAAKrF,GAClBA,IAAW6H,GACVL,KAAKgB,OACL,CACC7J,MAAOqB,IAGZ,OAAQA,IAAW6H,IACnB,OAAI7H,IAAW8H,IACVS,EAASI,QAAQJ,EAASI,SACvB3I,GAED,CACNrB,MAAOqB,EAET,EACA4I,OAAM,KACDL,EAASI,QAAQJ,EAASI,SACvBR,EAASS,UAEjBC,MAAK,KACAN,EAASI,QAAQJ,EAASI,SACvBR,EAASU,SAEjB,EAEKN,CACR,CACA,CAACxJ,OAAOiJ,iBACP,OAAOR,KAAKW,SAAWX,KAAKpD,SAC7B,CACA,CAACrF,OAAOoJ,YACP,OAAOX,KAAKW,SAAWX,KAAKpD,SAC7B,CACAlL,OAAOmP,GACN,OAAOb,KAAKxL,KAAI8M,IACf,IAAI9I,EAASqI,EAAKS,GAElB,OAAI9I,GAAQqF,KAAarF,EAAOqF,MAAMrF,GAAWA,EAAS8I,EAAUjB,KACxD7H,EAAS8I,EAAUjB,EAAI,GAErC,CAEAkB,QAAQ5D,GACP,IACInF,EADAmI,EAAWX,KAAKW,SAAWX,KAAKpD,UAEpC,MAA2C,KAAnCpE,EAASmI,EAASK,QAAQT,MACjC5C,EAASnF,EAAOrB,MAElB,CACAqK,OAAOC,GACN,IAAIC,EAAiB,IAAIjB,GA6BzB,OA5BAiB,EAAe9E,QAAWjO,IACzB,IAAIgS,EAAWX,KAAKW,SAAWX,KAAKpD,UAChC+E,GAAU,EACd,MAAO,CACNX,OACC,IAAIxI,EAASmI,EAASK,OAWtB,OAVIxI,EAAO+H,OACNoB,GACHA,GAAU,EACVhB,EAAWc,EAAelK,OAAOoJ,UAAUhS,GAC3C6J,EAASmI,EAASK,OACdxI,EAAO+H,MAAQmB,EAAeP,QAAQJ,SAASI,UAE/CO,EAAeP,QAAQO,EAAeP,UAGrC3I,CACR,EACA4I,OAAM,KACDM,EAAeP,QAAQO,EAAeP,SACnCR,EAASS,UAEjBC,MAAK,KACAK,EAAeP,QAAQO,EAAeP,SACnCR,EAASU,SAEjB,EAEKK,CACR,CAEAE,QAAQjE,GACP,IAAIkE,EAAiB,IAAIpB,GA0CzB,OAzCAoB,EAAejF,QAAWjO,IACzB,IAEImT,EAFAnB,EAAWX,KAAKW,SAAWX,KAAKpD,QAAQjO,GAG5C,MAAO,CACNqS,OACC,OAAG,CACF,GAAIc,EAAoB,CACvB,IAAItJ,EAASsJ,EAAmBd,OAChC,IAAKxI,EAAO+H,KACX,OAAO/H,CAET,CACA,IAAIA,EAASmI,EAASK,OACtB,GAAIxI,EAAO+H,KAEV,OADIsB,EAAeV,QAAQU,EAAeV,SACnC3I,EAER,IAAIrB,EAAQwG,EAASnF,EAAOrB,OAC5B,KAAIjJ,MAAMC,QAAQgJ,IAAUA,aAAiBsJ,IAI5C,OADAqB,EAAqB,KACd,CAAE3K,SAHT2K,EAAqB3K,EAAMI,OAAOoJ,WAKpC,CACD,EACAS,OAAM,KACDS,EAAeV,QAAQU,EAAeV,SACtCW,GACHA,EAAmBV,SACbT,EAASS,UAEjBC,MAAK,KACAQ,EAAeV,QAAQU,EAAeV,SACtCW,GACHA,EAAmBT,QACbV,EAASU,SAEjB,EAEKQ,CACR,CAEA1O,MAAM8D,EAAOC,GACZ,OAAO8I,KAAKxL,KAAI,CAAC8M,EAAStO,IACrBA,EAAIiE,EACAoJ,GACJrN,GAAKkE,GACRoJ,GAAKnJ,MAAQmK,EACNhB,IAEDgB,GAET,CACAN,OAGC,OAFKhB,KAAKW,WACTX,KAAKW,SAAWX,KAAKpD,WACfoD,KAAKW,SAASK,MACtB,CACAe,SACC,GAAI/B,KAAKgC,SAAWhC,KAAKgC,QAAQT,QAChC,OAAOvB,KAAKgC,QAEb,MAAM,IAAIzN,MAAM,sEAEjB,CACIyN,cACH,GAAIhC,KAAKiC,SACR,OAAOjC,KAAKiC,SACb,IAAIvE,EAAU,IAAI1Q,SAAQ,CAACC,EAASiV,KACnC,IAAIvB,EAAWX,KAAKpD,UAChBuF,EAAQ,GACRpB,EAAWf,KACfrF,OAAOC,eAAeuH,EAAO,WAAY,CAAEhL,MAAO4J,IAClD,SAASC,EAAKxI,GACb,MAAuB,IAAhBA,EAAO+H,MAAe,CAC5B,GAAI/H,EAAOqF,KACV,OAAOrF,EAAOqF,KAAKmD,GAEnBmB,EAAMrK,KAAKU,EAAOrB,OAEnBqB,EAASmI,EAASK,MACnB,CACA/T,EAAQ8T,EAASkB,SAAWE,EAC7B,CACAnB,CAAKL,EAASK,OAAO,IAGtB,OADAtD,EAAQqD,SAAWf,KACZA,KAAKiC,WAAajC,KAAKiC,SAAWvE,EAC1C,CACA0E,cACC,OAAOpC,KAAKgC,OACb,EAEDvB,GAAcpJ,UAAUiJ,KAAOA,GC5N/B,MAAM,GAAoB,IACpB+B,GAAiB,CAAC9M,EAAKlB,EAAQ4C,MACnC5C,EAAOqB,WAAarB,EAAOqB,SAAW,IAAIC,SAAStB,EAAOY,OAAQ,EAAGZ,EAAOnC,UAAU2E,UAAUI,EAAO1B,GAAK,GACtG0B,EAAQ,GAEVqL,GAAgB,CAACjO,EAAQ4C,KACtB5C,EAAOqB,WAAarB,EAAOqB,SAAW,IAAIC,SAAStB,EAAOY,OAAQ,EAAGZ,EAAOnC,UAAUqQ,UAAUtL,GAAO,GAE1GuL,GAAiB,CAACjN,EAAKlB,EAAQ4C,KACpC5C,EAAOuC,IAAIrB,EAAK0B,GACT1B,EAAIrD,OAAS+E,GAEfwL,GAAkB9L,WAAWU,UAAUlE,MACvCuP,GAAgB,CAACrO,EAAQ4C,EAAOC,IAC9BuL,GAAgBnL,KAAKjD,EAAQ4C,EAAOC,GAG5C,IAAIyL,GAAkBC,GA2ClBC,GAAYC,GAA4DC,GAApDC,GAAe,CAAEC,aAAc,EAAGpM,YAAa,GACnEqM,GAAe,IACfC,GAA0B,KAC9B,SAASC,KACRP,GAA8B,oBAAV1K,OAAwBA,OAAOkL,MAAMF,IAA2B,IAAIxM,WAAWwM,IACnGL,GAAS,KACTD,GAAW5N,OAAOqO,QAAU7H,EAAWoH,GAAW5N,QAClD8N,GAAkBF,GAAW5N,OAAOqO,QAEpCN,GAAanM,UAAUqM,GAAc,YACrCF,GAAaC,WAAWC,GAAe,EAAGH,IAAiB,GAC3DC,GAAeH,GAAWnN,WAAamN,GAAWnN,SAAW,IAAIC,SAASkN,GAAW5N,OAAQ4N,GAAWjN,WAAYiN,GAAWhN,aAC/HqN,GAAe,CAChB,CACO,SAASK,GAAQhO,EAAKD,EAAUkO,EAAQC,EAAYC,GACtDR,GAAe,MAClBE,KAED,IAAInM,EAAQiM,GACZ,IACCA,QAAuBrJ,IAARtE,EAAoB0B,EAAQ,EAC1C3B,EAASC,EAAKsN,GAAY5L,EAAQ,EACpC,CAAE,MAAO7C,GAER,GADAyO,GAAWc,KAAK,EAAG1M,EAAQ,GACT,cAAd7C,EAAMtC,KAAsB,CAC/B,GAAI,KAAOmF,EAAQwM,EAElB,OADAL,KACOG,GAAQhO,EAAKD,EAAUkO,EAAQC,GAEvC,MAAM,IAAIlP,MAAM,sCAAwCkP,EACzD,CACC,MAAMrP,CACR,CACA,IAAIlC,EAASgR,GAAejM,EAAQ,EACpC,GAAI/E,EAASuR,EACZ,MAAM,IAAIlP,MAAM,eAAiBrC,EAAS,mCAAqCuR,GAEhF,OAAIP,IAAgB,MACnBA,GAAejM,EACfmM,KACOG,GAAQhO,EAAKD,EAAUkO,EAAQC,IAEnCD,GACHR,GAAanM,UAAUI,EAAOyM,EAAQxR,EAASwR,EAAQxR,GAAQ,GAC/DsR,EAAOX,WAAaA,GACpBK,GAAgBA,GAAe,GAAM,SAC9BjM,EAAQ8L,KAEfF,GAAW5L,MAAQA,EAAQ,EAC3B4L,GAAW3L,IAAMgM,GACjBA,GAAgBA,GAAe,EAAK,SAC7BL,GAET,CChHA,MAAM,GAAY,sBACZe,GAAgB,CAAErD,MAAM,EAAMpJ,WAAO0C,GACrC,GAAkBlD,WAAWU,UAAUlE,MAC7C,IAAI0Q,GAAgBhI,EACfgI,GAAcC,YAClBD,GAAcC,UAAYD,GAAc3R,OACxC2R,GAAcE,UAAW,EACzBpJ,OAAOC,eAAeiJ,GAAe,SAAU,CAAE1M,MAAO0M,GAAc3R,OAAQ8R,UAAU,EAAMC,cAAc,KAE7G,MAAMC,GAAyB,KACzBC,GAAuB,MACvBC,GAAgB7M,OAAOC,IAAI,UACpB6M,GAAa,CAAC,EAC3B,IAAIC,GAAQ,GAEL,SAASC,GAAeC,GAAW,WACzCf,EAAU,IAAEvT,EAAG,SAAEuU,EAAQ,aAAEC,EAAY,eAAEC,EAAc,aAAEC,IAEzD,IAAIC,EAASC,EAAgBC,GAAe,EACxCC,EAAU,EACVC,EAAmB,EACvBtK,OAAOuK,OAAOV,EAAUnN,UAAW,CAClC8N,UAAUC,EAAIC,GACb,IAAIC,EAAMpV,EAAIqV,UAAaF,GAAWA,EAAQG,cAAiBV,EAAiBD,EAAUY,EAAazF,OACnGhG,EAASiD,EAAkB+C,KAAK0F,UAAW1F,KAAK1K,SAAS8P,EAAIX,EAAU,GAAIa,EAAIhC,SAAW,GAQ9F,MAPsB,iBAAXtJ,IACVgG,KAAK2F,mBAAmB3L,GAExBA,EAASiD,EAAkB+C,KAAK0F,UAAW1F,KAAK1K,SAAS8P,EAAIX,EAAU,GAAIa,EAAIhC,SAAW,IAEvFtJ,IACHgG,KAAK4F,SAAW5L,EAAO9H,QACjB8H,CACR,EACA6L,cAAcT,EAAIC,GACjB,IAAIS,EACAR,EAAMpV,EAAIqV,UAAaF,GAAWA,EAAQG,cAAiBV,EAAiBD,EAAUY,EAAazF,OAEvG,GADA8F,EAAK9F,KAAK4F,SAAWrJ,EAAYyD,KAAK0F,UAAW1F,KAAK1K,SAAS8P,EAAIX,EAAU,GAAKY,GAAWA,EAAQU,YAAe,EAAGT,EAAIhC,SAAW,GAClIwC,EAAK,EAAG,CACX,IAAW,OAAPA,EACH,OACD,IAAW,OAAPA,EACH,OAAOzB,GACR,IAAW,OAAPyB,GAAsE,GAAlC9F,KAAK1K,SAAS8P,EAAIX,EAAU,GACnE,MAAM,IAAIlQ,WAAasF,IAAPuL,EAChB,8CACA,0CACD,IAAW,KAAPU,EAEC,KAAW,OAAPA,EAGR,OAFA9F,KAAK4F,SAAWlB,EAAanC,UAAU,GAAG,GAEnCyD,EADQtB,EAAanC,UAAU,GAAG,GACVvC,KAAK4F,UAEpC,MAAM1J,EAAU4J,EAAG,CANnBA,EAAK9F,KAAK4F,SAAWlB,EAAanC,UAAU,GAAG,EAOjD,CACA,IAAI0D,EAAcjG,KAAKiG,YACnBrD,EAAQqD,EAAcA,EAAYpC,cAAgBA,GACtD,OAAIiC,EAAKlD,EAAMkB,UAEP9D,KAAKkG,oBACX,IAAM3J,EAAYyD,KAAK0F,UAAW1F,KAAK1K,SAAS8P,EAAIX,EAAU,GAAI,EAAGa,EAAIhC,SAAW,MAEtFV,EAAM1Q,OAAS8N,KAAK4F,SACbhD,EACR,EACAuD,WAAWf,EAAIC,EAAS1H,GACvB,IAAI2H,EAAMpV,EAAIqV,UAAaF,GAAWA,EAAQG,cAAiBV,EAAiBD,EAAUY,EAAazF,OACvGsF,EAAIc,UAAYd,EAAIc,UAAY,GAAK,EACrCnB,IACA,IAAI3B,EAAU+C,GAAsBf,EAAIhC,QAAStD,KAAKsG,GAAGC,IAAKnB,EAAIpF,KAAK1K,SAAUmO,GAAY,CAAEqC,EAAIU,EAAUC,EAAQ9O,KAChHmO,GAAa,IAAPA,GACTnI,EAASzB,EAAU4J,IACpBb,IACA,IAAIhQ,EAASqP,GAAMkC,GAKnB,GAJKvR,IACJA,EAASqP,GAAMkC,GAAYrJ,EAAgBqJ,EAAUtW,EAAIoT,UAGtDrO,EAAOyR,YAAa,CAIvB,IAAI9D,EAAQ,IAAIjM,WAAW1B,EAAQwR,EAAQ9O,GAC3CiL,EAAM0C,IAAMA,EACZ3H,EAASiF,EAAO,EAAGjL,EACpB,MAEC2N,EAAI/E,OACJ5C,EAAS1I,EAAQwR,EAAQ9O,EAC1B,IAEG2L,GACH7G,EAAU6G,GAAS,KAClBqD,cAAc,GAGjB,EACAC,SAASxB,EAAIC,EAAS1H,GACrB,IAAID,EAuBJ,OAtBKC,IACJD,EAAU,IAAI1Q,SAAQC,GAAW0Q,EAAW1Q,KAC7C+S,KAAKmG,WAAWf,EAAIC,GAAS,CAACpQ,EAAQwR,EAAQ9O,KACzCqI,KAAK6G,cAERJ,GAAU,EACV9O,GAAQ,GAET,IACIR,EADAyL,EAAQ,IAAIjM,WAAW1B,EAAQwR,EAAQ9O,GAEvCqI,KAAK8G,QAER3P,EAAQyL,GAAS5C,KAAK8G,QAAQC,OAAOnE,GACV,UAAjB5C,KAAKzS,SACf4J,EAAQyL,GAERzL,EAAQgB,OAAOd,UAAU2P,UAAU1P,KAAKsL,EAAO,EAAGjL,GAC7B,QAAjBqI,KAAKzS,UAAsB4J,IAC9BA,EAAQ8P,KAAKC,MAAM/P,KAErBwG,EAASxG,EAAM,IAETuG,CACR,EACAyJ,OAAOC,EAAM/B,GACZ,IAAK+B,EACJ,OACD,IAAItG,EAASsG,EAAKhD,IACdnP,EAAS6L,EAASA,EAAO8B,MAAQwE,EACrC,GAAKnS,EAAO8O,UAAa7T,EAAIqV,SAO5B,OADAtQ,EAAS,GAAgBqC,KAAKrC,EAAQ,EAAG+K,KAAK4F,UAC1C9E,GACHA,EAAO8B,MAAQ3N,EACRmS,GAEAnS,EAX8B,CACtC,IAAIqQ,EAAMD,GAASG,cAAgBV,EAAiBD,EAAUY,EAAazF,OAG3E,OAFA/K,EAAOqQ,IAAMA,EACbA,EAAIc,UAAYd,EAAIc,UAAY,GAAK,EAC9BgB,CACR,CAQD,EACAlB,mBAAmBmB,GAClB,IAAIzE,EACAqD,EAAcjG,KAAKiG,YACvB,GAAIlB,GAAgB/E,KAAK4F,SAAWzB,GAAsB,CAEzD,IAAImD,EACJ,IACC,GAAIrB,EAAa,CAChBqB,EAAiBrB,EAAYpC,cAC7B,IAAI0D,EAAatB,EAAYsB,YAAc,GACvCC,EAAcD,EAAWrV,QAAU,GAAM,EAC7C0Q,EAAQ6E,GAAmBzH,KAAK4F,UAChCK,EAAYyB,UAAU9E,EAAM3N,OAAQ2N,EAAMhN,WAAYoK,KAAK4F,SAAU2B,EAAYC,GACjFvB,EAAYpC,cAAgBjB,CAC7B,MACC0E,EAAiBzD,GACjB/H,EAAgB8G,EAAQiB,GAAgB4D,GAAmBzH,KAAK4F,WAEjEyB,GACD,CAAE,QACD,GAAIpB,EAAa,CAChB,IAAIuB,EAAcvB,EAAYsB,WAAWrV,QAAU,GAAM,EACzD+T,EAAYyB,UAAUJ,EAAerS,OAAQqS,EAAe1R,WAAY0R,EAAexD,UAAWmC,EAAYsB,WAAYC,GAC1HvB,EAAYpC,cAAgByD,CAC7B,MACCxL,EAAgBwL,GAChBzD,GAAgByD,CAElB,CACA,OAAO1E,CACR,CAMA,OAJAA,EAAQ5C,KAAK2F,mBAAmB3F,KAAK4F,UAErCyB,IACAzE,EAAM1Q,OAAS8N,KAAK4F,SACbhD,CACR,EACA+C,mBAAmBC,GAClB,IACIhD,EADA+E,EAAYC,KAAKC,IAAID,KAAKE,IAAe,EAAXlC,EAAc,MAAS,YAEzD,GAAI5F,KAAKiG,YAAa,CACrB,IAAIsB,EAAavH,KAAKiG,YAAYsB,YAAcpP,OAAOE,gBAAgB,GACnEmP,EAAcD,EAAWrV,QAAU,GAAM,EAC7C0Q,EAAQzK,OAAOE,gBAAgBsP,EAAYH,GAC3C5E,EAAMhM,IAAI2Q,GAEV3E,EAAQA,EAAMxM,SAASoR,GACvBxH,KAAKiG,YAAYyB,UAAU9E,EAAM3N,OAAQ2N,EAAMhN,WAAY+R,EAAWJ,EAAYC,GAClF5E,EAAMkB,UAAY6D,EAClBhN,OAAOC,eAAegI,EAAO,SAAU,CAAEzL,MAAOwQ,EAAW3D,UAAU,EAAMC,cAAc,IACzFjE,KAAKiG,YAAYpC,cAAgBjB,CAClC,MACCA,EAAQ6E,GAAmBE,GAC3B7L,EAAgB+H,GAAgBjB,GAGjC,OADAA,EAAMmB,UAAW,EACVnB,CACR,EACAmF,UAAU3C,EAAIC,GACb,IACCN,GAAe,EACf,IAAIiD,EAAahI,KAAK6F,cAAcT,EAAIC,GACxC,OAAO2C,IAAeA,EAAWjE,SAAW,GAAgBzM,KAAK0Q,EAAY,EAAGhI,KAAK4F,UAAYoC,EAClG,CAAE,QACDjD,GAAe,CAChB,CACD,EACAkD,gBAAgB7C,EAAIC,GACnB,IAAI2C,EAAahI,KAAK6F,cAAcT,EAAIC,GACxC,GAAI2C,EACH,OAAIA,EAAWjE,UAAYwB,SACnB,GAAgBjO,KAAK0Q,EAAY,EAAGhI,KAAK4F,WACjDoC,EAAW1C,IAAOD,GAAWA,EAAQG,YACrCH,EAAQG,YAAYY,UAAYf,EAAQG,YAAYY,UAAY,GAAK,EAC9D4B,EAET,EACAlN,IAAIsK,EAAIC,GACP,GAAIrF,KAAKkI,cAAe,CAEvB,IAAItF,EAAQ5C,KAAK6F,cAAcT,EAAIC,GACnC,OAAOzC,IAAUA,GAASyB,GAAaA,GAAarE,KAAK8G,QAAQC,OAAOnE,EAAOyC,GAChF,CACA,GAAqB,UAAjBrF,KAAKzS,SACR,OAAOyS,KAAK+H,UAAU3C,EAAIC,GAC3B,GAAIrF,KAAK8G,QAAS,CAEjB,IAAIlE,EAAQ5C,KAAK+H,UAAU3C,EAAIC,GAC/B,OAAOzC,IAAUA,GAASyB,GAAaA,GAAarE,KAAK8G,QAAQC,OAAOnE,GACzE,CAEA,IAAIpK,EAASwH,KAAKmF,UAAUC,EAAIC,GAChC,OAAI7M,GACkB,QAAjBwH,KAAKzS,SACD0Z,KAAKC,MAAM1O,GAEbA,CACR,EACA2P,SAAS/C,EAAIC,GACZ,IAAIlO,EAAQ6I,KAAKlF,IAAIsK,EAAIC,GACzB,QAAcxL,IAAV1C,EACH,OAAI6I,KAAK6G,YACD,CACN1P,QACA5H,QAASoV,KAIH,CACNxN,QAIJ,EACAiR,eACCA,GACD,EACAC,iBACKxD,IACHA,EAAQyD,aAAc,EACtBzD,EAAQ0D,UAETC,EAAiB,KACjB1D,EAAiB,KACjBD,EAAU,IACX,EACA4D,gBACMvY,EAAIqV,UAAaT,GACrBW,EAAazF,KACf,EACA0I,UAAUnT,EAAKoT,GACd,OAAsB,MAAlBA,OAEiC9O,IAA5BmG,KAAK6F,cAActQ,KAA2C,OAAnBoT,GAE3C3I,KAAK6G,iBACsBhN,IAA5BmG,KAAK6F,cAActQ,KAAuBoT,IAAmB,IAAahE,MAAqBgE,IAGlGA,GAAkBA,EAAe,iBACpCA,EAAiBA,EAAe,iBACxB3I,KAAKpI,UACb+Q,EAAiB3I,KAAKpI,QAAQgR,OAAOD,IACT,iBAAlBA,IACVA,EAAiBxQ,OAAOqH,KAAKmJ,IACvB3I,KAAK6I,eAAetT,EAAK,CAAE0B,MAAO0R,EAAgBG,YAAY,IAAS,EAEhF,EACAC,UAAUxT,EAAK8P,GACd,IAAI2D,EAAiB,CACpBzT,MACA0T,cAAc,GAEf,GAAI5D,IAAgC,IAArBA,EAAQ6D,SACtB,MAAM,IAAI3U,MAAM,2CACjB,OAAOyL,KAAKmJ,SAAS9D,EAAU1K,OAAOuK,OAAO8D,EAAgB3D,GAAW2D,EACzE,EACAI,QAAQ/D,GAIP,OAHKA,IACJA,EAAU,CAAC,GACZA,EAAQgE,QAAS,EACVrJ,KAAKmJ,SAAS9D,EACtB,EACAiE,SAASjE,GAIR,OAHKA,IACJA,EAAU,CAAC,GACZA,EAAQkE,WAAY,EACbvJ,KAAKmJ,SAAS9D,GAASzI,SAC/B,EACA4M,aAAanE,GAKZ,OAJKA,IACJA,EAAU,CAAC,GACZA,EAAQkE,WAAY,EACpBlE,EAAQgE,QAAS,EACVrJ,KAAKmJ,SAAS9D,GAASzI,SAC/B,EACAiM,eAAetT,EAAK8P,GAMnB,OALKA,IACJA,EAAU,CAAC,GACZA,EAAQ9P,IAAMA,EACd8P,EAAQ4D,cAAe,EACvB5D,EAAQkE,WAAY,EACbvJ,KAAKmJ,SAAS9D,GAASzI,SAC/B,EACAuM,SAAS9D,GACR,IAAItE,EAAW,IAAIN,GACd4E,IACJA,EAAU,CAAC,GACZ,IAAIoE,GAAmC,IAAnBpE,EAAQgE,OACxBK,EAAkBrE,EAAQjV,SAC1B6Y,EAAe5D,EAAQ4D,aACvBU,EAAQtE,EAAQsE,MAChBrD,EAAKtG,KAAKsG,GACV4C,EAAW7D,EAAQ6D,SACnBjD,EAAcjG,KAAKiG,YA6MvB,OA5MAlF,EAASnE,QAAU,KAClB,IAAIgN,EAAaX,EAAe5D,EAAQ9P,IAAM8P,EAAQpO,MACtD,MAAM4S,EAAUxE,EAAQwE,QACxB,IACIC,EAAQC,EAAeC,EACvB1E,EAFA2E,EAAQ,EAGRvG,GAAS+F,EAAgB,IAAQ,IAAMI,EAAU,KAAQ,IAC3DZ,EAAe,KAAQ,IAAM5D,EAAQyD,WAAa,MAAS,IAC3DzD,EAAQ6E,aAAe,MAAS,IAChC7E,EAAQ8E,eAAiB,MAAU,GACjCC,EAAQpK,KACZ,SAASqK,IACR,IAGC,IAAIC,EAEJ,GAJIR,GACHS,IAEDjF,EAAMD,EAAQG,YACVF,EAAK,CACR,GAAIA,EAAIkF,OAAQ,MAAM,IAAIjW,MAAM,kEAEhC+V,EAAahF,EAAIhC,QACjBwG,EAAS,IACV,KAAO,CACN,IAAIvE,EAAWrV,EAAIqV,SACfA,IACH2D,GAAW,GACZ5D,EAAMpV,EAAIqV,UAAYF,EAAQG,cAAgBV,EAAiBD,EAAUY,EAAa2E,IACtFN,GAAUvE,GAAYe,EAAGmE,eAC1B,CACIX,GACHxD,EAAGmE,gBAAkB,KACrB/G,GAAS,MAEToG,EAAS,IAAItO,EAAO8K,EAAIgE,GAAc,GAEvCN,EAAgBF,EAAOxG,QACvBgC,EAAIc,UAAYd,EAAIc,UAAY,GAAK,GACpB,IAAb8C,IACHa,EAAgB/E,EAChBM,EAAIoF,kBAAoBpF,EAAIoF,kBAAoB,GAAK,EAEvD,CAAE,MAAMtW,GACP,GAAI0V,EACH,IACCA,EAAOa,OACR,CAAE,MAAMvW,GAAS,CAElB,MAAMA,CACP,CACD,CAEA,GADAiW,IACIhF,EAAQkE,UAAW,CACtB7F,GAAS,KACT,IAAIuG,EAAQ7U,EAASiQ,EAAQoB,QAI7B,OAHIwD,EAAQ,GACX/N,EAAU+N,GACXM,IACON,CACR,CACA,SAAS7U,EAASqR,GACjB,IACImE,EADAC,OAAyBhR,IAAf+P,EAA2B,EAAIQ,EAAM9U,SAASsU,EAAYnF,EAAU,GAElF,GAAIwE,EACH,QAAsBpP,IAAlBwL,EAAQpO,YAAuC4C,IAAhBwL,EAAQnO,IAC1C0T,EAAa,MACT,CACJ,IAAIE,EACJ,GAAIV,EAAMxS,QAAQtC,SACjBwV,EAAevH,GAAQ8B,EAAQpO,MAAOmT,EAAMxS,QAAQtC,SAAUyL,EAAU0C,GACxEiB,EAAazB,WAAWiB,GAAwB4G,GAAc,GAC9DF,EAAarH,GAAQ8B,EAAQnO,IAAKkT,EAAMxS,QAAQtC,SAAUyL,EAAU0C,OAC9D,IAAM4B,EAAQpO,SAASoO,EAAQpO,iBAAiBN,aAAiB0O,EAAQnO,OAAOmO,EAAQnO,eAAeP,YAK7G,MAAM,IAAIpC,MAAM,6DAJhBuW,EAAevH,GAAQ8B,EAAQpO,MAAOmF,EAAc9G,SAAUyL,EAAU0C,GACxEiB,EAAazB,WAAWiB,GAAwB4G,GAAc,GAC9DF,EAAarH,GAAQ8B,EAAQnO,IAAKkF,EAAc9G,SAAUyL,EAAU0C,EAMrE,CACD,MAEAmH,EAAarH,GAAQ8B,EAAQnO,IAAKkT,EAAM9U,SAAUyL,EAAU0C,GAC7D,OAAO,EAAWuG,EAAetG,EAAO+C,GAAU,EAAGoE,EAASD,EAC/D,CAEA,SAASL,IACJjF,EAAIkF,SAEJzJ,EAASI,QACZJ,EAASI,SACN4I,GACHzE,EAAIoF,qBACCpF,EAAIc,UAAY,GAAKd,EAAIyF,YAC9BjB,EAAOa,QACPrF,EAAI0F,QACJ1F,EAAIkF,QAAS,GAETlE,EAAGmE,iBAAmBnF,GAAOT,EAChCiF,EAAOa,SAEPrE,EAAGmE,gBAAkBX,EACrBxD,EAAG2E,UAAY3F,GAGlB,CACA,MAAO,CACNtE,OACC,IAAI6J,EAASjF,EASb,GARImE,IAAkBA,GAAiB/E,GAAWM,EAAIkF,UACrDH,IACAQ,EAAUzV,EAAS,IAGnByV,EADa,IAAVZ,EACO7U,EAASiQ,EAAQoB,QAEjB7J,EAAQoN,GACfa,GAAW,GACZZ,KAAWN,EAIb,OAHIM,EAAQ,GACX/N,EAAU+N,GACXM,IACO3G,GAER,IAAKqF,IAA6B,IAAbC,EAAoB,CACxC,GAAI2B,EAAU,IAGb,MAFIA,EAAU,UACb3O,EAAU2O,EAAU,YACf,IAAItW,MAAM,oBAAsBsW,EAAQK,SAAS,KAExDtB,EAAaQ,EAAMpT,QAAQyN,EAAU,GAAIoG,EAAU,GACpD,CACA,GAAIpB,EAAe,CAClB,IAAItS,EACJyO,EAAWlB,EAAanC,UAAU,GAAG,GACrC,IACIK,EADA4D,EAAW9B,EAAanC,UAAU,GAAG,GAEzC,GAAIiE,EACH5D,EAAQoD,EAAcQ,EAAUZ,QAGhC,GADAhD,EAAQqD,EAAcA,EAAYpC,cAAgBA,GAC9C+B,EAAWhD,EAAMkB,UAAW,CAC/BsG,EAAMxE,SAAWA,EACjBb,EAAiC,UAAlBqF,EAAM7c,SACrB,IACCqV,EAAQwH,EAAMlE,oBAAmB,IAAMnJ,EAAgBiN,IACxD,CAAE,QACDjF,GAAe,CAChB,CACD,MACCnC,EAAM1Q,OAAS0T,EAWjB,OATIwE,EAAMtD,QACT3P,EAAQiT,EAAMtD,QAAQC,OAAOnE,EAAOgD,GACR,UAAlBwE,EAAM7c,SAChB4J,EAAQyL,EAAMmB,SAAW,GAAgBzM,KAAKsL,EAAO,EAAGgD,GAAYhD,GAEpEzL,EAAQyL,EAAMsI,SAAS,OAAQ,EAAGtF,GACZ,QAAlBwE,EAAM7c,UAAsB4J,IAC/BA,EAAQ8P,KAAKC,MAAM/P,KAEjBuS,EACI,CACNvS,MAAO,CACN5B,IAAKqU,EACLzS,QACA5H,QAASoV,MAGFsE,EACF,CACN9R,SAGM,CACNA,MAAO,CACN5B,IAAKqU,EACLzS,SAGJ,CAAO,OAAIuS,EACH,CACNvS,MAAO,CACN5B,IAAKqU,EACLra,QAASoV,MAIJ,CACNxN,MAAOyS,EAGV,EACAxI,OAAM,KACLmJ,IACO3G,IAERvC,MAAK,KACJkJ,IACO3G,IAER,EAEK7C,CACR,EAEAoK,QAAQC,EAAMzN,GAKb,IAAID,EAAUC,OAAW9D,EAAY,IAAI7M,SAAQC,GAAW0Q,EAAW,CAACvJ,EAAOiX,IAAYpe,EAAQoe,KAQnG,OAPArL,KAAKnD,SAASuO,GAAM,KACnB,IAAIC,EAAU,IAAInd,MAAMkd,EAAKlZ,QAC7B,IAAK,IAAIc,EAAI,EAAG0D,EAAI0U,EAAKlZ,OAAQc,EAAI0D,EAAG1D,IACvCqY,EAAQrY,GAAK8H,EAAIxD,KAAK0I,KAAMoL,EAAKpY,IAElC2K,EAAS,KAAM0N,EAAQ,IAEjB3N,CACR,EACA4N,sBAAsBlG,EAAIC,GACzB,IAAIC,EAAMpV,EAAIqV,UAAaF,GAAWA,EAAQG,cAAiBV,EAAiBD,EAAUY,EAAazF,OAEvG,GADAA,KAAK4F,SAAW5F,KAAKuL,mBAAqBjG,EAAIkG,gBAAgBpG,GAAMpF,KAAKsG,GAAGxL,IAAIkF,KAAK1K,SAAS8P,EAAIX,EAAU,KACrF,QAAnBzE,KAAK4F,SAGT,OAAO5F,KAAK4F,QAiBb,EACA/I,SAASuO,EAAMzN,GACd,IAAKyN,EACJ,MAAM,IAAI7W,MAAM,qCACjB,IAAK6W,EAAKlZ,OACT,OAAIyL,OACHA,EAAS,MAGF3Q,QAAQC,UAEjB,IACIwe,EAEAC,EAHAC,EAAU,GAEVC,EAAe,CAAC,EAEpB,IAAK,IAAIrW,KAAO6V,EAAM,CACrB,IAAIhW,EACAG,QAAmBsE,IAAZtE,EAAIA,UAAmCsE,IAAdtE,EAAI4B,OACvC/B,EAAWmO,GAAQhO,EAAI4B,MAAO6I,KAAK1K,SAAUsW,EAAcnI,EAAY,YACvEF,GAAQhO,EAAIA,IAAKyK,KAAK1K,SAAUsW,EAAcnI,IAE9CrO,EAAWmO,GAAQhO,EAAKyK,KAAK1K,SAAUsW,EAAcnI,GAEjDgI,IACJA,EAAgBrW,GACbwW,EAAa/I,YAAc6I,IAC9BC,EAAQ7T,KAAK8T,GACbF,EAAaE,EAAa/I,WAC1B+I,EAAe,CAAE/I,WAAY6I,GAE/B,CAUA,OATAnI,QAAQ1J,EAAWmG,KAAK1K,SAAUsW,EAAcnI,GAChDwB,IACApI,EAASmD,KAAK0F,UAAW+F,GAAgBrX,IACxC6Q,IACI7Q,EACHyX,QAAQzX,MAAM,sBAAuBuX,EAASC,GAE9CjO,EAAS,KAAK,IAEXA,OAAL,EACQ,IAAI3Q,SAAQC,GAAW0Q,EAAW1Q,GAC3C,EACA6e,qBACC,IAAIxG,EAAMR,EAAiBD,EAAUY,EAAazF,MAElD,OADAsF,EAAIyG,MACGzG,CACR,EACAqF,MAAMhN,GAEL,IAAIqO,EACJ,GAFAhM,KAAKiM,OAAS,UAEVjM,KAAKkM,OAAQ,CAEhB,GAAIrH,EACH,IACCA,EAAQmG,OACT,CAAE,MAAM5W,GAAQ,CAEjByQ,EAAU,CACTsH,QACC,MAAM,IAAI5X,MAAM,sCACjB,GAEDuQ,EAAiB,KACjBkH,EAAahM,KAAKoM,YAAcpM,KAAKoM,YACtC,CACA,MAAMC,EAAU,KACf,GAAIrM,KAAKkM,OAAQ,CAChB,GAAIjH,EAAmB,EACtB,OAAO,IAAIjY,SAAQC,GAAW0S,YAAW,IAAM1S,EAAQof,MAAY,KAEpEnc,EAAIoT,QAAU,EACdpT,EAAIya,OACL,MACC3K,KAAKsG,GAAGqE,QACT3K,KAAKiM,OAAS,SACVtO,GACHA,GAAU,EAEZ,OAAIqO,EACIA,EAAWnO,KAAKwO,IAEvBA,IACOrf,QAAQC,UAEjB,EACAqf,WACWpc,EAAIqV,UAAaT,GAA2BW,EAAazF,MAAnE,IACIuM,EAAUvM,KAAKsG,GAAGkG,OAItB,OAHAD,EAAQE,KAAOvc,EAAIsc,OACnB7R,OAAOuK,OAAOqH,EAASrc,EAAIwc,QAC3BH,EAAQI,KAAOzc,EAAI0c,WACZL,CACR,IAED,IACI/D,EADA1N,EAAM0J,EAAUnN,UAAUyD,IAE9B,SAASkL,EAAcQ,EAAU7O,GAChC,IAAI1C,EAASqP,GAAMkC,GACdvR,IACJA,EAASqP,GAAMkC,GAAYrJ,EAAgBqJ,EAAUtW,EAAIoT,UAE1D,IAAImD,EAAS/B,EAAanC,UAAU,GAAG,GACvC,OAAO,IAAI5L,WAAW1B,EAAQwR,EAAQ9O,EACvC,CACA,SAAS8N,EAAa2E,GACrB,IAAKvF,EAAS,CACb,IACIgI,EADAC,EAAU,EAEd,GACC,IACC,IAAIC,EAAcvE,GAAkBA,EAAewE,QACnDnI,EAAU,IAAIxJ,EAAInL,EAAK,OAAS6c,IAAgBA,EAAYvC,QAAUuC,GAC/C,GAAnBlI,EAAQvB,UACXuB,EAAUkI,EACNlI,EAAQkG,aACXlG,EAAQkG,YAAa,IAEvB,KACD,CAAE,MAAO3W,GACR,IAAIA,EAAM6Y,QAAQpf,SAAS,eAK1B,MAAMuG,EAJDyY,IACJA,EAAY,IAAI7X,WAAW,IAAIsK,kBAAkB,GAAI,EAAG,IACzD4N,QAAQC,KAAKN,EAAW,EAAG,EAAa,EAAVC,EAGhC,QACQA,IAAY,IACtB,CAKA,OAFAhI,EAAiBnF,WAAWyI,EAAc,GAC1CgC,EAAMgD,KAAK,qBACJvI,CACR,CACA,SAASuD,IACRpD,IACIF,IACHA,EAAiB,KACbD,EAAQuB,UAAYvB,EAAQ6F,kBAAoB,GAAK,GACxD7F,EAAQkG,YAAa,EACrBvC,EAAiB,IAAI6E,QAAQxI,GAC7BA,EAAU,MAEV/H,EAAS+H,EAAQvB,SAGpB,CACD,CACO,SAASmE,GAAmB9P,GAClC,IAAIiL,EAAyB,oBAAVzK,OAAwBA,OAAOkL,MAAM1L,GAAQ,IAAIhB,WAAWgB,GAG/E,OAFAiL,EAAMkB,UAAYnM,EAClBgD,OAAOC,eAAegI,EAAO,SAAU,CAAEzL,MAAOQ,EAAMqM,UAAU,EAAMC,cAAc,IAC7ErB,CACR,CAEAvH,EAAIhE,UAAUkJ,KAAO,WACpBP,KAAKoG,WACiB,IAAlBpG,KAAKoG,UAAkBpG,KAAK+K,aAC/B/K,KAAKgL,QACLhL,KAAKwK,QAAS,EAEhB,EACAnP,EAAIhE,UAAU0U,IAAM,WACnB/L,KAAKoG,UAAYpG,KAAKoG,UAAY,GAAK,CACxC,EAGA,IAAIkH,GAA6CC,GAAgFC,GAA3GC,GAAgB,IAAIC,IAA2BC,GAAuB,CAAE1K,aAAc,EAAGpM,YAAa,GACxH,GAAe,IACf,GAA0B,KAC9B,SAAS+W,KACRN,GAAoC,oBAAVnV,OAAwBA,OAAOkL,MAAM,IAA2B,IAAI1M,WAAW,IACzG4W,GAAqB,IAAIvY,WAAWsY,GAAiBrY,OAAQ,EAAGqY,GAAiBrY,OAAOY,YAAc,GACtG0X,GAAmB,GAAK,WACxBC,GAAsBF,GAAiBrY,OAAOqO,QAAU7H,EAAW6R,GAAiBrY,QACpFqY,GAAiB5X,SAAWiY,GAAuB,IAAIhY,SAAS2X,GAAiBrY,OAAQqY,GAAiB1X,WAAY0X,GAAiBzX,YACvI,GAAe,CAChB,CACO,SAASwQ,GAAsBiE,EAAY/D,EAAKhR,EAAKD,EAAUmO,EAAY9F,GAC7E,GAAe,MAClBiQ,KAED,IAAI3W,EAAQ,GACR4W,EAAc,GAAe,GACjC,IACC,QAAuBhU,IAARtE,EAAoBsY,EAClCvY,EAASC,EAAK+X,GAAkBO,EAClC,CAAE,MAAOzZ,GACR,GAAkB,cAAdA,EAAMtC,KAAsB,CAC/B,GAAI,KAAOmF,EAAQwM,EAElB,OADAmK,KACOvH,GAAsBiE,EAAY/D,EAAKhR,EAAKD,EAAUmO,EAAY9F,GAE1E,MAAM,IAAIpJ,MAAM,sCAAwCkP,EACzD,CACC,MAAMrP,CACR,CACA,IAAIlC,EAAS,GAAe2b,EAC5B,GAAI3b,EAASuR,EAEZ,MADA,GAAexM,EACT,IAAI1C,MAAM,eAAiBrC,EAAS,mCAAqCuR,GAEhF8J,GAAkC,GAAdtW,GAAS,IAAU/E,EACvCqb,GAAkC,GAAdtW,GAAS,IAAUsP,EACvC,GAAgB,GAAe,GAAM,SACrCoH,GAAqB1K,WAAWhM,EAAOqT,GAAY,GACnD,IAAIwD,EAAaC,IAAgB,KAChC,IAAI3Y,EAAW6B,GAAS,EACpB6O,EAAKkI,EAAiB5Y,GAC1BuI,EAASmI,EAAIkI,EAAiB5Y,EAAW,GAAI4Y,EAAiB5Y,EAAW,GAAI4Y,EAAiB5Y,EAAW,GAAG,IAEzG4Y,EAAmBT,GAEtB,OAAO9Q,EAAU+Q,GAAsBvW,EAAO6W,EAAY,CAAC,EAAG,OAGhE,CACA,IChyBInJ,GAAgBC,GDgyBhBqJ,GAAiB,EACjBF,GAAkBG,WAAWC,qBAC5BJ,KACJA,GAAkBG,WAAWC,qBAAuB,SAASxQ,GAC5D,IAAImQ,EAAaG,KAEjB,OADAR,GAAc7W,IAAIkX,EAAYnQ,GACvBmQ,CACR,EACApR,GAAgB,SAASoR,GACxBL,GAAc3S,IAAIgT,EAAlBL,GACAA,GAAcW,OAAON,EACtB,KC1yBD,MAAMO,GAASX,IAAIrW,UAAUyD,IAChBwT,GAAe,CAACC,EAAOre,KACnC,IAAIse,EACJ,OAAO,cAAwBD,EAC/BzO,YAAY2O,EAAQpJ,GACnBtF,MAAM0O,EAAQpJ,GACTnV,EAAIwe,iBACRxe,EAAIwe,gBAAiB,EACrB1O,KAAK2O,GAAG,eAAe,EAAG3N,OAAM4N,OAAMC,YACrC,EAAG,CACF,IAAIC,EAAO9N,EAAK8N,KACZ1E,EAAQ0E,GAAQA,EAAK1E,MACzB,GAAIA,EACH,GAAIpJ,EAAK+N,KAAO1Q,EACf+L,EAAM4E,MAAMZ,OAAOU,EAAKvZ,SACpB,CACJ,IAAI0Z,EAAqBH,EAAKI,WAAa,GACvCF,EAAQ5E,EAAM4E,MACdG,EAAQd,GAAO/W,KAAK0X,EAAOF,EAAKvZ,KAChC4Z,IACHA,EAAMN,MAAQA,EACdG,EAAMI,KAAKD,EAAOF,EAAqB,GAEzC,CAEF,OAASjO,GAAQ4N,IAAS5N,EAAOA,EAAKA,MAAK,KAG7ChB,KAAKsG,GAAG+I,UAAYrP,KAChBqF,EAAQ2J,MAAMM,oBACjBjK,EAAQ2J,MAAMpT,iBAAmBA,GAClCoE,KAAKgP,MAAQ,IAAI1S,EAAa+I,EAAQ2J,OAClC3J,EAAQ2J,MAAMO,YACjBvP,KAAKgP,MAAMO,WAAY,EACzB,CACIC,gBACH,OAAO,CACR,CACA1U,IAAIsK,EAAIC,GACP,IAAIlO,EACJ,GAAI6I,KAAKgP,MAAMO,UAAW,CACzB,IAAIJ,EAAQnP,KAAKgP,MAAMlU,IAAIsK,GAC3B,GAAI+J,EAAO,CACV,IAAIM,EAAcN,EAAMhY,MACxB,GAAmB,MAAfgY,EAAMN,MAKT,OAAOY,EAHP,GADAtY,EAAQ4I,MAAMjF,IAAIsK,EAAI,CAAEW,WAAYoJ,EAAMN,MAAOrJ,YAAaH,GAAWA,EAAQG,cAC7ErO,IAAUkN,GACb,OAAOoL,CAGV,MACCtY,EAAQ4I,MAAMjF,IAAIsK,EAAIC,EACxB,KAAO,IAAIA,GAAWA,EAAQG,YAC7B,OAAOzF,MAAMjF,IAAIsK,EAAIC,GAGrB,GADAlO,EAAQ6I,KAAKgP,MAAMU,SAAStK,QACdvL,IAAV1C,EACH,OAAOA,EAERA,EAAQ4I,MAAMjF,IAAIsK,EACnB,CACA,GAAIjO,GAA0B,iBAAVA,IAAuBkO,GAAyB,iBAAPD,EAAiB,CAC7E,IAAI+J,EAAQnP,KAAKgP,MAAMW,SAASvK,EAAIjO,EAAO6I,KAAK4F,UAAY,IACxD5F,KAAK6G,cACRsI,EAAM5f,QAAUoV,MAEb3E,KAAKgP,MAAMO,YACdJ,EAAMN,MAAQjK,KAChB,CACA,OAAOzN,CACR,CACAgR,SAAS/C,EAAIC,GACZ,IAAI8J,EAAOhY,EACX,GAAI6I,KAAKgP,MAAMO,UAEd,GADAJ,EAAQnP,KAAKgP,MAAMlU,IAAIsK,GACnB+J,EAAO,CACV,GAAmB,MAAfA,EAAMN,MAKT,OAAOM,EAHP,GADAhY,EAAQ4I,MAAMjF,IAAIsK,EAAI,CAAEW,WAAYoJ,EAAMN,MAAOrJ,YAAaH,GAAWA,EAAQG,cAC7ErO,IAAUkN,GACb,OAAO8K,CAGV,MACChY,EAAQ4I,MAAMjF,IAAIsK,EAAIC,OACjB,IAAIA,GAAWA,EAAQG,YAC7B,OAAOzF,MAAMoI,SAAS/C,EAAIC,GAG1B,GADA8J,EAAQnP,KAAKgP,MAAMlU,IAAIsK,QACTvL,IAAVsV,EACH,OAAOA,EAERhY,EAAQ4I,MAAMjF,IAAIsK,EACnB,CACA,QAAcvL,IAAV1C,EAUJ,OAPCgY,EADGhY,GAA0B,iBAAVA,IAAuBkO,GAAyB,iBAAPD,EACpDpF,KAAKgP,MAAMW,SAASvK,EAAIjO,EAAO6I,KAAK4F,UAAY,IAEhD,CAAEzO,SACP6I,KAAK6G,cACRsI,EAAM5f,QAAUoV,MACb3E,KAAKgP,MAAMO,YACdJ,EAAMN,MAAQjK,MACRuK,CACR,CACAS,SAASxK,EAAI+J,EAAOU,GACnB,IAAIrX,EAASuH,MAAME,IAAImF,EAAI+J,EAAMhY,MAAOgY,EAAM5f,QAASsgB,GACvD,GAAkB,iBAAPzK,EACV,OAAO5M,EACJA,GAAUA,EAAOqF,KACpBmC,KAAKgP,MAAMc,YAAY1K,EAAI+J,GAE3BnP,KAAKgP,MAAMpY,IAAIwO,EAAI+J,EACrB,CACAlP,IAAImF,EAAIjO,EAAO5H,EAASsgB,GACvB,IAAIrX,EAASuH,MAAME,IAAImF,EAAIjO,EAAO5H,EAASsgB,GAC3C,GAAkB,iBAAPzK,EAAiB,CAC3B,GAAIjO,GAASA,EAAM,iBAGlB,OADA6I,KAAKgP,MAAMZ,OAAOhJ,GACX5M,EAGR,IAAI2W,EAAQnP,KAAKgP,MAAMW,SAASvK,EAAIjO,GAAQqB,GAAUA,EAAOsG,OAAS,GAAK,GACvE0P,GACHA,EAAgBuB,IAAI3K,QACLvL,IAAZtK,IACH4f,EAAM5f,QAA6B,iBAAZA,EAAuBA,EAAQA,QAAUA,EAClE,CACA,OAAOiJ,CACR,CACAwX,QAAQ5K,EAAIjO,EAAO5H,EAASsgB,GAC3B,GAAW,WAAPzK,EAEH,GAAIjO,GAA0B,iBAAVA,EAAoB,CACvC,IAAIgY,EAAQnP,KAAKgP,MAAMW,SAASvK,EAAIjO,GAChCqX,GACHA,EAAgBuB,IAAI3K,QACLvL,IAAZtK,IACH4f,EAAM5f,QAA6B,iBAAZA,EAAuBA,EAAQA,QAAUA,EAElE,MACCyQ,KAAKgP,MAAMZ,OAAOhJ,GAEpB,OAAOrF,MAAMiQ,QAAQ5K,EAAIjO,EAAO5H,EAASsgB,EAC1C,CACAI,OAAO7K,EAAIyK,GAEV,OADA7P,KAAKgP,MAAMZ,OAAOhJ,GACXrF,MAAMkQ,OAAO7K,EAAIyK,EACzB,CACAK,WAAW9K,EAAIyK,GAEd,OADA7P,KAAKgP,MAAMZ,OAAOhJ,GACXrF,MAAMmQ,WAAW9K,EAAIyK,EAC7B,CACAM,WAAWxS,GAEV,OADAqC,KAAKgP,MAAM7O,QACJJ,MAAMoQ,WAAWxS,EACzB,CACAyS,YACCpQ,KAAKgP,MAAM7O,QACXJ,MAAMqQ,WACP,CACAC,iBAAiB1S,GAChB,OAAOoC,MAAMsQ,kBAAiB,KAC7B,IAAIrB,EAAQhP,KAAKgP,MACbsB,EAAkB9B,EACtB,IAEC,OADAA,EAAkB,IAAI+B,IACf9S,EAAKE,KAAanF,GACpBA,IAAWwG,GACPgM,KACRwD,EAAkB8B,EACX9X,IACLwS,EACJ,CAAE,MAAM5W,GACP4W,EAAM5W,EACP,CACA,SAAS4W,EAAM5W,GAEd,IAAK,IAAIgR,KAAMoJ,EACdQ,EAAMZ,OAAOhJ,GAEd,GADAoJ,EAAkB8B,EACdlc,EACH,MAAMA,EAEN,OAAO4K,EACT,IAEF,CACA0J,UAAUnT,EAAKoT,GACd,IAAIwG,EAAQnP,KAAKgP,MAAMlU,IAAIvF,GAC3B,GAAI4Z,EAAO,CACV,GAAsB,MAAlBxG,EACH,OAA0B,OAAnBA,EACD,GAAI3I,KAAK6G,YACf,OAAO8B,IAAmB1J,IAAakQ,EAAM5f,UAAYoZ,CAE3D,CACA,OAAO5I,MAAM2I,UAAUnT,EAAKoT,EAC7B,EACC,EAEK,SAAS6H,GAAkB1V,EAAK2V,GACtC9L,GAAiB7J,EACjB8J,GAAe6L,CAChB,CC7MA,IAMIhM,GAAUC,GANVgM,GAAkC,mBAAX9b,SAAyBA,QAKpD4b,GAAkB,GAAgB,IAElC,MACQxU,OAAM,qEAA8DqB,EACxE6Q,WAAWyC,cACdC,GAAe1C,WAAWyC,eAE1BzC,WAAWyC,cAAgBE,KAI5B,MAAMC,GAAe,KAGfC,GAAuB,KACvBC,GAAuB,EAEhBC,GAAS,IAAIvD,IAC1B,IAAIwD,GAEAC,GACG,SAAS,GAAKvhB,EAAMyV,GAC1B,GAAIhI,EAAY+T,MACf,GAAI/T,EAAY+T,OAAS,GAMxB,OADAZ,GAFA,GAAiBnT,EAAYsH,eAC7B,GAAetH,EAAYuH,cAEpBvH,EAAY+T,KAAKxhB,EAAMyV,QAG/BhI,EAAY+T,KAAO,GACnB/T,EAAYsH,eAAiB,GAC7BtH,EAAYuH,aAAe,GAEvBH,IAoXN,WACCA,GAA4B,oBAAVtM,OAAwBA,OAAOE,gBAAgBgZ,IAAmB,IAAI1a,WAAW0a,IACnG,MAAMC,EAAY7M,GAASxP,OAC3ByP,GAAeD,GAAS/O,WAAa+O,GAAS/O,SAAW,IAAIC,SAAS8O,GAASxP,OAAQ,EAAGoc,KAC1F5M,GAAS3B,OAAS,IAAIyO,YAAYD,EAAW,EAAGD,IAAmB,GACnE5M,GAAS+M,QAAU,IAAI1c,aAAawc,EAAW,EAAGD,IAAmB,GACrE5M,GAAS3B,OAAOQ,QAAUmB,GAASnB,QAAUgO,EAAUhO,QAAU7H,EAAW6V,EAC7E,CA1XEG,GACkB,iBAAR7hB,GAAqByV,IAE/BzV,GADAyV,EAAUzV,GACKA,MAGhB,IAAI8hB,GADJrM,EAAUA,GAAW,CAAC,GACGqM,WACrBC,EAActM,EACbzV,EAMOyV,IACXA,EAAU,CAAC,IANXA,EAAU1K,OAAOuK,OAAO,CACvB0M,eAAe,EACfC,QAAQ,GACNxM,GACHzV,EAAOqM,IAAW,IAAM2L,KAAKkK,MAAsB,cAAhBlK,KAAKmK,UAA0B7G,SAAS,IAAM,QAGlF,IAAI8G,EAAY,EAAWC,QAAQriB,GAC/BkC,EAAO,EAAWogB,SAAStiB,EAAMoiB,GACjCG,EAAUrhB,IAAOshB,SAAS,MAC1BC,EAAchN,EAAQgN,aAAehN,EAAQiN,gBAAkBjN,EAAQkN,QACzEJ,GAAW9M,EAAQkN,QAAU,WAC9BJ,GACGK,EAAcnN,EAAQkN,QA8B1B,SAASE,EAAgBC,GACxB,GAAIA,aAA8BnX,EACjC,OAAOmX,EACR,IAAIC,EAA0C,iBAAtBD,EACxB,GAAIC,GAAczB,GACjB,OAAOA,GACRwB,EAAqB/X,OAAOuK,OAAO,CAClC0N,UAAW,IACXrL,WAAY5X,EAAGkjB,aAAa,IAAIC,IAAI,kBAAmB,+DAAgBpf,QAAQ,uBAAwB,MACvGmQ,cAAe4D,GAAmB,IAChCiL,GACH,IAAIzM,EAActL,OAAOuK,OAAO,IAAI3J,EAAYmX,GAAqBA,GAGrE,OAFIC,IACHzB,GAAqBjL,GACfA,CACR,CA9BqC,WAdrCZ,EAAU1K,OAAOuK,OAAO,CACvBtV,OACAmjB,SAAU1gB,QAAQ2f,GAClB9F,QAAQ,EACR8G,OAAQ,GACRX,cACA5N,YACAwO,iBAAkB5N,EAAQwM,SAAUxM,EAAQ6N,UAA2B,SAANnX,EAGjEwW,QAASF,EAAc,iBACtB,OACDc,YAAyC,QAA5B1jB,QAAQS,IAAIkjB,cACvB/N,IACSgO,wBACXhO,EAAQiO,kBAAmB,GAExBjW,EAAY9N,QAAQgkB,MAAQlW,EAAY9N,QAAQikB,MAAQ,IAAMnW,EAAY9N,QAAQkkB,MAAQ,IAAQ,OACrGpO,EAAQ4N,iBAAkB,EAC1B5N,EAAQqO,cAAe,EACvBrO,EAAQsO,qBAAsB,EAC9BtO,EAAQ8N,aAAc,EACtB9N,EAAQgN,aAAc,EACjBG,IAAanN,EAAQkN,QAAU,aA8UtC,SAAgB3iB,GACf,GAAID,EAAGikB,WACN,OAAOjkB,EAAGikB,WAAWhkB,GACtB,IACC,OAAOD,EAAGkkB,SAASjkB,EACpB,CAAE,MAAOwE,GACR,OAAO,CACR,CACD,CAnVM0f,CAAOzO,EAAQ0N,SAAW,EAAWhf,QAAQnE,GAAQA,IACzDD,EAAGokB,UAAU1O,EAAQ0N,SAAW,EAAWhf,QAAQnE,GAAQA,EAAM,CAAEokB,WAAW,IAmB3E3O,EAAQY,cACXZ,EAAQY,YAAcwM,EAAgBpN,EAAQY,cAC/C,IAAIvC,GACF2B,EAAQ4N,gBAAkB,KAAS,IACnC5N,EAAQ0N,SAAW,MAAS,IAC5B1N,EAAQwM,OAAS,MAAU,IAC3BxM,EAAQ6N,SAAW,OAAU,IAC7B7N,EAAQ4O,WAAa,OAAU,IAC/B5O,EAAQ6O,YAAc,OAAU,IAChC7O,EAAQ8O,SAAW,QAAW,IAC9B9O,EAAQ+O,YAAc,QAAW,IACjC/O,EAAQgP,UAAY,SAAY,IAChChP,EAAQsO,oBAAsB,SAAY,IAC1CtO,EAAQgN,YAAc,SAAY,IAClChN,EAAQ8N,YAAc,KAAQ,IAC9B9N,EAAQqO,aAAe,KAAQ,GAE7BxjB,EAAM,IAAIkL,EACVkZ,GAAWjP,EAAQ4N,gBAAkB,KAAS,IAChD5N,EAAQkP,gBAAkB,EAAI,IAC9BlP,EAAQuM,cAAgB,EAAI,GAC1B9L,EAAK5V,EAAIkhB,KAAK/L,EAAS3B,EAAO4Q,GAClCpkB,EAAIN,KAAOA,EACLkW,GACL5J,EAAU4J,UACJT,EAAQZ,SACf,IAAIhB,EAAavT,EAAIskB,gBAGrB,GAFA/Q,EAAamE,KAAKC,IAAIpE,EAAY4B,EAAQoP,SAAW3D,GAAeC,IACpErN,EAAQgR,GAAYxkB,EAAIoT,SACZ,KAARI,GACH,GAAIiO,EAAYE,OAEf,MADA3hB,EAAIya,QACE,IAAIpW,MAAM,8EAEX,GAAI8Q,EAAQ4N,gBAAiB,CACnC,GAAItB,EAAYsB,gBAEf,MADA/iB,EAAIya,QACE,IAAIpW,MAAM,kFAEjB8Q,EAAQ4N,iBAAkB,EAC1BqB,GAAoB,IACpBK,GAAWzkB,EAAIoT,QAASgR,EACzB,CAEApkB,EAAI0kB,eACCvP,EAAQ4N,iBAAmB5N,EAAQuM,iBAAmBT,IAAuB1hB,QAAQkf,KACzFwC,IAAsB,EACtB1hB,QAAQkf,GAAG,OAAQ,KAGpB,MAAMnK,UAAkBrI,EACvB2D,YAAY2O,EAAQoG,GAEnB,GADA9U,aACelG,IAAX4U,EACH,MAAM,IAAIla,MAAM,mFAOjB,GALI8Q,EAAQY,cAAyC,IAA1B4O,EAAU5O,aAAyD,iBAAzB4O,EAAU5O,YAC9E4O,EAAU5O,YAAcZ,EAAQY,YACxB4O,EAAU5O,cAClB4O,EAAU5O,YAAcwM,EAAgBoC,EAAU5O,cAE/C4O,EAAUC,UAAYD,EAAUhO,aAAegO,EAAU7F,OAC5D,MAAM,IAAIza,MAAM,iEAEjB,IAAIwgB,EAAcF,EAAUE,YACC,UAAzBF,EAAUG,YACbH,EAAUI,aAAc,EACdJ,EAAUK,WAChBL,EAAUK,WAAWnd,sBACxB8c,EAAUK,WAAWnd,wBAErBgd,GAAc,EACoB,UAAzBF,EAAUG,cACpBD,GAAc,GAEf,IAgDII,EAhDAzR,GAASmR,EAAUO,WAAa,EAAO,IACzCP,EAAUC,QAAU,EAAO,IAC3BD,EAAUQ,SAAW,GAAO,IAC5BR,EAAUS,WAAa,GAAO,IAC9BT,EAAUU,WAAa,GAAO,IAC7BlQ,EAAQ6N,WAAiC,IAArB2B,EAAUW,OAA6B,EAAV,SAClDX,EAAUhO,YAAc,IAAQ,GAC9B4O,EAAWZ,EAAUI,aAAwC,UAAzBJ,EAAUG,YAA2B,EAAID,EAAc,EAAI,EAmBnG,GAlBe,GAAXU,IACH/R,GAAS,GAEN2B,EAAQ6N,UAMXlT,KAAKoI,eACLpI,KAAKyI,gBACLzI,KAAKsG,GAAK,IAAIhL,EAAIpL,EAAKwT,EAAO+K,EAAQgH,EAASZ,EAAU5O,cAEzDjG,KAAK0V,iBAAgB,KACpB1V,KAAKsG,GAAK,IAAIhL,EAAIpL,EAAKwT,EAAO+K,EAAQgH,EAASZ,EAAU5O,YAAY,GACnEZ,EAAQ4N,gBAAkB,MAAU,GAExCjT,KAAKqI,kBACArI,KAAKsG,IAAqB,YAAftG,KAAKsG,GAAGC,IACvB,MAAM,IAAIhS,MAAM,sBHvMb,IAA0B6V,EGyM9BpK,KAAK0F,UAAY1F,KAAKsG,GAAGhD,QACzBtD,KAAKsG,GAAGxU,KAAO2c,GAAU,KACzBzO,KAAKlO,KAAO2c,EACZzO,KAAKiM,OAAS,OACdjM,KAAK9P,IAAMA,EACX8P,KAAK2V,MAAQ,EACb3V,KAAK4V,OAAS,EACd5V,KAAK6V,aAAe,EACpB7V,KAAK8V,uBAAyB,EAC1BjB,EAAUkB,oBACblK,QAAQmK,KAAK,6CACVnB,EAAUoB,yBACbpK,QAAQmK,KAAK,kDACdhW,KAAKkW,YAAclF,GACnBrW,OAAOuK,OAAOlF,KAAM,CACnBpQ,KAAMyV,EAAQzV,KACdrC,SAAU8X,EAAQ9X,SAClB+lB,iBAAkBjO,EAAQiO,kBACxBuB,GAEC7U,KAAKpI,SAAWoI,KAAKpI,QAAQud,UAChCA,EAAUnV,KAAKpI,QAAQud,QACvBnV,KAAKpI,QAAU,MAEXud,GAAanV,KAAKpI,SAAWoI,KAAKpI,QAAQgR,QAAa5I,KAAKzS,UAA6B,WAAjByS,KAAKzS,UAA0C,QAAjByS,KAAKzS,WAC/G4nB,EAA4B,QAAjBnV,KAAKzS,SAAqBmjB,GAAc,UAAUyE,QAAU9Y,GAEpE8Y,IACHnV,KAAKpI,QAAU,IAAIud,EAAQxa,OAAOuK,OA6LtC,SAAqCiR,EAAmB9hB,GACvD,IAAK,IAAIrB,EAAI,EAAGA,EAAIojB,UAAUlkB,OAAQc,IAAK,CAC1C,IAAI8N,EAASsV,UAAUpjB,GACvB,IAAK,IAAIuC,KAAOuL,EACXqV,EAAkBtoB,SAAS0H,KAC9BlB,EAAOkB,GAAOuL,EAAOvL,GAExB,CACA,OAAOlB,CACR,CArMKgiB,CAA4B,CAAC,cAAe,gBAAiB,iBAAkB,aAAc,aAAc,kBAAmB,kBAAmB,iBAAkB,qBAAsB,uBAAwB,gBAAiB,gBAAiB,gBAAiB,mBAAoB,OAAQ,sBAAuB,uBAAwB,wBAAyB,cACxWrW,KAAKsW,oBAAsBtW,KAAKuW,wBAA0B,CACzDC,aAAa,GACXnR,EAASwP,GAAY7U,KAAKpI,WAEV,QAAjBoI,KAAKzS,SACRyS,KAAKpI,QAAU,CACdgR,OAAQ3B,KAAKwP,WAEJzW,KAAKpI,UACfoI,KAAK8G,QAAU9G,KAAKpI,QACpBoI,KAAKkI,eAAiBlI,KAAKpI,QAAQ8e,mBAEpC1W,KAAKyD,WAAaA,EHlPG,mBADS2G,EGoPbpK,MHnPRzS,WACV6c,EAAMxS,QAAUwS,EAAMtD,QAAU,CAC/BxR,SAAU8G,EAAc9G,SACxB0B,QAASoF,EAAcpF,UAGrBoT,EAAMxS,SAAWwS,EAAMxS,QAAQtC,WAAa8U,EAAMxS,QAAQgR,SAC7DwB,EAAMxS,QAAQgR,OAAS,SAASzR,EAAOwf,GAQtC,MAPqB,iBAAVxf,GAAsBA,GAASA,IAAUwL,KAInDA,GAAmBxL,EACnByL,GAAQW,GAAQpM,EAAO6I,KAAK1K,UAAU,EAAO8U,EAAM3G,aAEhDb,GAAM1L,IAAM,KAAO,GAAoByf,GACnC/T,GAAMxM,SAASwM,GAAM3L,MAAO2L,GAAM1L,KAEnC0L,EACR,EACAwH,EAAMxS,QAAQ4e,aAAc,GAEzBpM,EAAMtD,SAAWsD,EAAMtD,QAAQ9P,UAAYoT,EAAMtD,QAAQC,SAC5DqD,EAAMtD,QAAQC,OAAS,SAAS9R,GAAU,OAAO+K,KAAKhJ,QAAQ/B,EAAQ,EAAGA,EAAO/C,OAAS,EACzFkY,EAAMlC,eAAgB,GAEnBkC,EAAM6K,aAAoC,UAArB7K,EAAM4K,aAC9B5K,EAAM9U,SAAW+M,GACjB+H,EAAMpT,QAAUsL,IACN8H,EAAM2K,aAAoC,UAArB3K,EAAM4K,aACrC5K,EAAM9U,SAAWkN,GACjB4H,EAAMpT,QAAU0L,IACN0H,EAAM8K,YAChB9K,EAAM9U,SAAW8U,EAAM8K,WAAW5f,SAClC8U,EAAMpT,QAAUoT,EAAM8K,WAAWle,UAEjCoT,EAAM9U,SAAW8G,EAAc9G,SAC/B8U,EAAMpT,QAAUoF,EAAcpF,SG+M7Bia,GAAOra,IAAI6X,EAAS3c,EAAO,IAAM2c,EAAS3c,EAAMkO,KACjD,CACA4W,OAAOnI,EAAQoG,GACd,GAAI7U,KAAK8U,SAAwB,MAAb9U,KAAKlO,KACxB,MAAM,IAAIyC,MAAM,gEACI,iBAAVka,GAAuBoG,EAIjCA,EAAYA,GAAa,CAAC,EAF1BpG,GADAoG,EAAYpG,GACO3c,KAGpB,IACC,OAAO+iB,EAAU7F,MAChB,IAAKV,GAAa9J,EAAWtU,GAA7B,CAAmCue,EAAQoG,GAC3C,IAAIrQ,EAAUiK,EAAQoG,EACxB,CAAE,MAAMzgB,GACP,GAAqB,sBAAjBA,EAAM6Y,QACT,OAID,MAHI7Y,EAAM6Y,QAAQ4J,QAAQ,iBAAmB,IAC5CziB,EAAM6Y,SAAW,kCAEZ7Y,CACP,CACD,CACAgd,KAAKyD,EAAWlX,GACf,IAAI2I,EAAKtG,KAAK4W,OAAO/B,GAGrB,OAFIlX,GACHA,EAAS,KAAM2I,GACTA,CACR,CACAwQ,OAAOlnB,EAAMmnB,GACZ,IAAIrF,EAGJ,OADA/hB,EAAGokB,UAAU,EAAWhgB,QAAQnE,GAAO,CAAEokB,WAAW,IAC7C,IAAIhnB,SAAQ,CAACC,EAASiV,IAAWhS,EAAI8mB,KAAKpnB,GAAM,GAAQwE,IAC1DA,EACH8N,EAAO9N,GAEPnH,GACD,KAEF,CACAgqB,gBACC,MAAsB,QAAfjX,KAAKiM,MACb,CACAiL,KAAKvZ,GACJ,OAAOzN,EAAIgnB,KAAKvZ,GAAY,SAASvJ,GAChCA,GACHyX,QAAQzX,MAAMA,EAEhB,EACD,CACA+iB,WAEC,OADAtL,QAAQmK,KAAK,0DACNhW,KAAKoX,UACb,CACAA,WACCpX,KAAK0V,iBAAgB,IACpB1V,KAAKsG,GAAG+Q,KAAK,CACZC,eAAe,KACZjS,EAAQ4N,gBAAkB,MAAU,EAC1C,CACA9S,MAAMxC,GACL,GAAuB,mBAAZA,EACV,OAAOqC,KAAKmQ,WAAWxS,GACxBkO,QAAQmK,KAAK,8DACbhW,KAAKoQ,WACN,CACAA,YACKpQ,KAAKpI,UACJoI,KAAKpI,QAAQ2f,gBAChBvX,KAAKpI,QAAQ2f,kBACLvX,KAAKpI,QAAQ4f,aACrBxX,KAAKpI,QAAQ4f,WAAa,KAE5BxX,KAAK0V,iBAAgB,IACpB1V,KAAKsG,GAAG+Q,KAAK,CACZC,eAAe,KACZjS,EAAQ4N,gBAAkB,MAAU,EAC1C,CACA2B,cACC,OAAO1kB,EAAI0kB,aACZ,CACA6C,aACC,OAAOvnB,EAAIunB,aAAa7lB,KAAK,GAC9B,CACA2kB,wBAUC,MAAO,CACNmB,eAAgB,CAACF,EAAYG,IACrB3X,KAAK0V,iBAAgB,KAC3B,IAAIkC,EAA2B5X,KAAK+H,UAAU/H,KAAKsW,qBAC/CuB,EAAqBD,GAA4B5X,KAAK8G,QAAQC,OAAO6Q,GACzE,GAA2B,mBAAhBD,GACRA,EAAaE,GACbA,GAAsBA,EAAmB3lB,QAAUylB,EACrD,OAAO,EACR3X,KAAKC,IAAID,KAAKsW,oBAAqBkB,EAAW,GAC3CnS,EAAQ4N,gBAAkB,MAAU,GAEzC6E,cArBqB,KACrB,IAAIC,EACA/X,KAAK6G,cACRkR,EAAc,MACf,IAAI9iB,EAAS+K,KAAK+H,UAAU/H,KAAKsW,qBAuD9B,IAAwB/mB,EApD3B,OAFIyQ,KAAK6G,cAsDkBtX,EArDXwoB,EAsDZrT,GAAazB,WAAW,GAAI1T,GAAS,IArDlC0F,GAAU+K,KAAK8G,QAAQC,OAAO9R,EAAO,EAe5CuhB,aAAa,EAEf,EAGehS,EAAUnN,UAAU2Y,QACjBxL,EAAUnN,UAAU6Y,WACvC3L,GAAeC,EAAW,CAAEtU,MAAKuT,aAAYgB,YAAUC,gBAAcC,eAAc,KAC9EU,EAAQ6N,UL7VP,SAAyB1O,GAAW,IAAEtU,EAAG,YAAE8nB,EAAW,aAAE5P,EAAY,YAAE8L,EAAW,WAAEzQ,EAAU,kBACnGwU,EAAiB,kBAAEC,EAAiB,oBAAEC,EAAmB,gBAAElF,EAAe,YAAEiD,EAAW,gBAAE3B,EAAe,cAAE6D,IAE1G,IAAIC,EACJ,SAASC,EAA0BC,GAIlC,IAAItjB,EAAS,IAAIkK,GAAuBS,IACpC4Y,EAAYH,EAEZvV,GADJuV,EAAe,IAAI9Y,GAAUtK,IACH6N,OAAS,IAAIyO,YAAYtc,EAAQ,EAAG2K,IAAqB,GAUnF,OATAkD,EAAO,GAAK,EACZuV,EAAa7G,QAAU,IAAI1c,aAAaG,EAAQ,EAAG2K,IAAqB,GACxE3K,EAAOqO,QAAU5H,EAAiB2c,GAClCvV,EAAOQ,QAAUrO,EAAOqO,QAAUR,EAAOlN,WACzCyiB,EAAajjB,SAAW,EACpBmjB,IACHC,EAAUhH,QAAQ+G,EAAe,GAAKF,EAAavV,OAAOQ,SAAW+U,EAAajjB,UAAY,GAC9FojB,EAAU1V,OAAOyV,GAAgB,GAAK,GAEhCF,CACR,CACA,IAIII,EACAC,EAEAC,EAAeC,EAGfC,EAVAC,EAAsBlZ,GAAoB6D,EAAa,IAAO,EAC9DsV,EAAwB,EACxBjO,EAAe,EACfvF,EAAW,KAGXyT,EAAmB,GACUC,EAAiB,GAAIC,EAAsB,GAC5EhD,EAAcA,GAAe,EAC7B+B,GAA0C,IAAtBA,EAEpB,IAEIkB,EAEAC,EACAC,EAAiBC,EAAuBC,EACxCC,EANAC,EAAuB,GACvBC,EAAwB,GAExBC,EAAa,EAIjBzB,EAAoBA,GAAqB,EACzCC,EAAsBA,GAAuB,IAC7CC,EAAgBA,GAAiB,IAEjCE,IACAD,EAAavV,OAAO,GAAK7E,EAAgBC,EAAgBC,EACzD,IAAIyb,EAAeC,EAAiB,CACnC/W,OAAQuV,EAAavV,OAAQgX,aAAc,EAAG/K,KAAM,EAAGgL,YAAa,KAAM/Y,KAAM,KAAM8N,KAAM,MACzFkL,GAAwB,CAC3BlX,OAAQ,KAAMgX,aAAc,EAAG/K,KAAM,EAAGgL,YAAa,KAAM/Y,KAAM6Y,EAAgB/K,KAAM,MACpFmL,GAAsBJ,EACtBK,GAAyBF,GACzBG,GAAuBH,GAC3B,SAASI,GAAkB1W,EAAO0G,EAAO7U,EAAK4B,EAAO5H,EAASsgB,GAC7D,IAAIwK,EACAC,EAAallB,EAAUwC,EACvBsX,EAAW6K,EAAaQ,EAC5B,GAAY,EAAR7W,EAAW,CAGd,GADA9L,EAAUwS,EAAMxS,QACZT,GAASA,EAAM,iBAClB4iB,EAAc5iB,EAAM,sBAChB,GAAIS,EACJA,EAAQ4e,YACXuD,EAAcniB,EAAQgR,OAAOzR,EAAOmH,GAAqBiH,EAAWhH,EAAoB,KAExFwb,EAAcniB,EAAQgR,OAAOzR,GACH,iBAAf4iB,IACVA,EAAc5hB,OAAOqH,KAAKua,UAEtB,GAAoB,iBAAT5iB,EACjB4iB,EAAc5hB,OAAOqH,KAAKrI,OACpB,MAAIA,aAAiBR,YAG3B,MAAM,IAAIpC,MAAM,oCAAsC4C,EAAQ,YAAeA,EAAQ,6BAFrF4iB,EAAc5iB,CAEmG,CAMlH,GALAojB,EAAmBR,EAAY9iB,MAE9BiY,EADGqL,GAAoB,EACXR,EAAY7iB,IAAMqjB,EAElBR,EAAY7nB,OACrBkY,EAAM0K,SAAW5F,EAAYzL,EAChC,MAAM,IAAIlP,MAAM,8CAAgDkP,EAAa,sCAC/E,MACCyL,EAAY,EACT3J,GACH+U,EAActC,EACd5iB,EAAW,IAEP6iB,IAAsBkB,GAAwC,GAAdQ,IACnDR,EAAyB1Z,IAAU,KAClC,IACC,IAAK,IAAIzM,EAAI,EAAG0D,EAAIgjB,EAAsBxnB,OAAQc,EAAI0D,EAAG1D,IACxD,IACC0mB,EAAsB1mB,IACvB,CAAE,MAAMoB,GACPyX,QAAQzX,MAAM,2BAA4BA,EAC3C,CAEF,CAAE,MAAMA,GACPyX,QAAQzX,MAAMA,EACf,CACA+kB,EAAyB,KACzBQ,IACAa,KACInB,GACHA,GAAiB,IAEnBV,EAAgB,KAChBC,EAAe,KACfS,EAAkBe,GAAkB,EAAGhQ,GACvCkP,EAAwB,EACxBK,KAEDW,EAAcjC,EACdjjB,EAAWklB,EAAYllB,UAExB,IAmFIqlB,EAnFA3X,EAASwX,EAAYxX,OAAQ0O,EAAU8I,EAAY9I,QACnDsI,EAAe1kB,GAAY,EAG/B,IAAK0N,EACJ,MAAM,IAAIvO,MAAM,wCAGjB,GADAuO,EAAOgX,EAAe,GAAK1P,EAAM9D,GAAGC,IACxB,EAAR7C,EAAW,CACd,IACIgX,EADAC,EAAqC,IAAjBvlB,GAAY,GAEpC,IAEC,GADAslB,EAActQ,EAAM9U,SAASC,EAAK+kB,EAAaK,KACzCA,EAAmBD,IAAiC,KAAR,GAARhX,GACzC,MAAM,IAAInP,MAAM,yDAA2DgB,EAC7E,CAAE,MAAMnB,GAIP,MAHAkmB,EAAY3W,KAAK,EAAGgX,GACF,cAAdvmB,EAAMtC,OACTsC,EAAQ,IAAIG,MAAM,iDAAmDkP,EAAa,MAC7ErP,CACP,CACA,IAAIyW,EAAU6P,EAAcC,EAC5B,GAAI9P,EAAUpH,EAEb,MADA6W,EAAY3W,KAAK,EAAGgX,GACd,IAAIpmB,MAAM,iDAAmDkP,EAAa,KAIjF,GAFAX,EAAOgX,EAAe,GAAKjP,EAC3BzV,EAAYslB,EAAc,IAAO,EACrB,EAARhX,EAAW,CACd,IAAIkX,EACJ,GAAIL,GAAoB,EAEvB/I,EAAQpc,IAAa2kB,EAAYzW,UAC/ByW,EAAYzW,QAAU7H,EAAWse,EAAY9kB,UAAYslB,EAC3DK,EAAeb,EAAYQ,IAAqB,QAC1C,CACN,IAAIM,EAAmBd,EAAY9kB,OAE/BqO,GAAWuX,EAAiBvX,UACP,IAAvByW,EAAY7nB,OAAe,EAC5B2oB,EAAiBvX,QAAU7H,EAAWof,KACnCd,EAAYnkB,WACZ0N,GAAW,GAAKyW,EAAY7nB,OAAS,GACxC2Z,QAAQzX,MAAM,yCAA0CkP,GACzDkO,EAAQpc,GAAYkO,EACpBsX,EAAeb,EAAY,IAAM,GAClC,CACAjX,GAAQ1N,KAAc,GAAK,GAAK8Z,EAC5B9E,EAAMnE,cAAgBiJ,GAAa9E,EAAMnE,YAAY2M,WAAagI,KACrElX,GAAS,QACT8N,EAAQpc,GAAYgV,EAAMnE,YAAY3C,QACjCiC,GACJnI,EAASlN,EAAIoT,QAASR,EAAOQ,SAAWlO,GAAY,IAAI,KAGvD,IAAKoc,EACJ,MAAM,IAAIjd,MAAM,uBAAuB,IAE1Ca,IAEF,MACkByE,IAAdgW,IACe,OAAdA,EACHnM,GAAS,IAETA,GAAS,IACT8N,EAAQpc,KAAcya,SAGRhW,IAAZtK,IACHmU,GAAS,IACT8N,EAAQpc,KAAc7F,GAAW,EAEnC,MACC6F,IAED,GADAklB,EAAYllB,SAAWA,EACnBmQ,EAGH,OAFAzC,EAAO,GAAKY,EACZ/G,EAAMzM,EAAIoT,QAASR,EAAOQ,SACnB,IAAOR,EAAO,GAAKzE,EAAoBQ,GAAoBD,GAK/DxJ,EAAW0jB,GAGdwB,EAAchC,EAA0BljB,GACxCA,EAAWklB,EAAYllB,SACvBqlB,EAAaH,EAAYxX,QAEzB2X,EAAa3X,EACd,IAAIgY,GAAajB,EAEjBA,EAAiBiB,GAAW9Z,KAAO,CAClC8B,OAAQ2X,EACRX,aAAc1kB,GAAY,EAC1B2Z,KAAM,EACNgL,YAAa/B,EACbhX,KAAM,KACN8N,KAAM,MAEPqL,GAAuBW,GAEvB,IAAIC,GAAoBpB,EAExB,OAAQhc,IAyEP,GAxEIod,IAIHV,EAAcvX,EAAOgX,GACrBhX,EAAOgX,GAAgBpW,EAEnB2V,IAAoBgB,IACvBf,GAAyB,GAAKpK,GAAa,KACfiJ,IAC3BmB,EAAwB,EACxBD,IACAA,EAAkB,OAMpBgB,EAAcnN,QAAQ8N,GAAGlY,EAAQgX,EAAcpW,GAEhDqV,IACIsB,EAAcpc,IACjB0a,EAAgB,KAChBC,EAAe,KACfK,EAAiB,GACjBgC,GAAsBH,IACjBhQ,IACJA,EAAehI,EAAOQ,SAAWwW,GAAgB,MAG9CiB,IAAqB7B,EAAoBhnB,OAAS,IACtD+mB,EAAenhB,QAAQohB,GACvBA,EAAsB,KAElBN,GAAgB3F,IACpB2F,EAAe,IAAI5rB,SAAQC,IACtB8tB,GACH7B,EAAoBphB,KAAK7K,GAEzBgsB,EAAenhB,KAAK7K,EACrB,KAGEotB,EAActc,GACjBpB,EAAMzM,EAAIoT,QAAS,GAEhByV,EAAwB/a,IAA2Bqb,IACjDvb,IACJA,EAAoB,IAAI9I,WAAW,IAAIsK,kBAAkB,GAAI,EAAG,IACjE4N,QAAQC,KAAKrP,EAAmB,EAAG,EAAG8J,KAAKsT,MAAMnC,EAAwB/a,KAEtE8M,IACCmN,EACHkD,MACStC,GAAkBX,EAC3BW,EAAiC,GAAf3C,GAA2C,oBAAhBxW,aAA+BA,cAAa,IAAMyb,OAAkBxb,YAAW,IAAMwb,MAAgBjF,GACxI6C,EAAwBb,GAClCiD,MAGkC,IAAP,EAAxBpC,IACJqC,KAEGhR,EAAM4E,QACT8L,GAAWhM,KAAO,CACjBvZ,MACA6U,QACA8E,UAAW6K,EAAcA,EAAY7nB,OAAS,IAGhD4oB,GAAWf,YAAcA,EAErBpc,EAAU,CACb,GAAIA,IAAasB,GAEZ,CACJ,IAAI6P,EAAOgM,GAAWhM,OAASgM,GAAWhM,KAAO,CAAC,GAGlD,OAFAA,EAAK5M,OAASvE,OACdmR,EAAK7hB,QAAWkK,GAAUwG,EAAS,KAAMxG,GAE1C,CANC0Y,EAAY5Q,EAOd,CACA,YAAkBpF,IAAdgW,EACCkL,GAAoB,GAClBD,GAAW/L,MAAS3E,EAAM4E,QAC9B8L,GAAW/L,KAAOvQ,IACZO,KAEJ4Z,EACEmC,GAAW/L,OACf+L,GAAW/L,KAAOvQ,KAEnBma,EAAgB,IAAI3rB,SAAQ,CAACC,EAASiV,KACrC,IAAI4M,EAAOgM,GAAWhM,OAASgM,GAAWhM,KAAO,CAAC,GAClDA,EAAK7hB,QAAUA,EACfA,EAAQouB,eAAgB,EACxBvM,EAAK5M,OAASA,CAAM,IAEjBqS,IACHoE,EAAc2C,QAAUrI,EAAkB2F,EAAeD,IAEpDA,IAERS,EAAmB,IAAIpsB,SAAQ,CAACC,EAASiV,KACxC,IAAI4M,EAAOgM,GAAWhM,OAASgM,GAAWhM,KAAO,CAAC,GAClDA,EAAK7hB,QAAUA,EACf6hB,EAAK5M,OAASA,CAAM,IAEjBqS,IACH6E,EAAiBkC,QAAUrI,EAAkB2F,EAAeQ,GACtDA,EAAgB,CAEzB,CAEA,SAAS+B,KACJtC,IACH0C,eAAe1C,GACfA,EAAiB,MAElB,IAAI2C,EAAYvC,EACJwC,KAAKC,MACjBxrB,EAAIirB,aAAarQ,GAAemB,IAK/B,OAJIoM,EAAavV,OAAOuV,EAAajjB,UAAY,GAAK6I,GACrDgd,GAAsBpB,GAEvBuB,IAAc,GACNnP,GACP,KAAK,EACJ,IAAK,IAAI0P,KAAYH,EACpBG,IAED,MACD,KAAK,EACJ,MACD,KAAK,EAGJ,OAFAnC,GAAoB,EA8HxB7qB,iBACCuB,EAAIqV,SAAWA,EAAW,CAAE5I,OAAO,GACnCqc,EAAiB4C,aAAc,EAC/B,IAAK,IAAI5oB,EAAI,EAAGA,EAAIgmB,EAAiB9mB,OAAQc,IAAK,CACjD,IAAI6oB,EAAe7C,EAAiBhmB,GACpC,IAAK,IAAI8oB,EAAI,EAAGplB,EAAImlB,EAAa3pB,OAAQ4pB,EAAIplB,EAAGolB,IAAK,CACpD,IAAIC,EAAkBF,EAAaC,GAEnC,GADcC,EAAgBC,QACjB,CACZ9rB,EAAI+rB,SAAS,GACb,IAAIC,EAAY3W,EAChBrV,EAAIqV,SAAWA,EAAW,CAAE5I,OAAO,GACnC,IACC,IAAInE,EAASujB,EAAgBpe,WACzBnF,GAAUA,EAAOqF,OACpB2b,GAAoB,QACdhhB,GAEHA,IAAWwG,GACd9O,EAAIisB,WAEJjsB,EAAIksB,YACLC,GAAcH,GACdL,EAAaC,GAAKtjB,CACnB,CAAE,MAAMpE,GACPioB,GAAcH,GACdhsB,EAAIisB,WACJG,EAASloB,EAAOynB,EAAcC,EAC/B,CACD,MACC,IACC,IAAItjB,EAASujB,IACbF,EAAaC,GAAKtjB,EACdA,GAAUA,EAAOqF,OACpB2b,GAAoB,QACdhhB,EAER,CAAE,MAAMpE,GACPkoB,EAASloB,EAAOynB,EAAcC,EAC/B,CAEF,CACD,CAMA,SAASQ,EAASloB,EAAOynB,EAAc7oB,IACrC6oB,EAAaU,SAAWV,EAAaU,OAAS,KAAKvpB,GAAKoB,EACzDynB,EAAa7oB,GAAKkM,EACnB,CARA8Z,EAAmB,GACnBqD,GAAc,MACV7C,GACHtpB,EAAIssB,eAMN,CAjLIC,GACOjD,EAER,QACC,IACCtd,EAAU+P,EACX,CAAE,MAAM7X,GACPyX,QAAQzX,MAAMA,GACVsoB,KACHA,GAAoBxa,OAAO9N,GAC3BsoB,GAAsB,KAExB,EACF,IAED5R,EAAe,CAChB,CAEA,SAASmQ,GAAsBH,GACxBA,EAAW/L,KAAOtQ,KACvBqc,EAAW/L,KAAOtQ,GACdmb,EACHA,EAAc+C,QAAU7B,EAIxBlB,EAAgBkB,EAEnB,CAnDwC9tB,QAAQC,UAoDhD,IAkDIyvB,GAlDAE,GAAW1e,EAAgBE,EAC/B,SAASgd,GAAczsB,GAEtB,IAAIkuB,EACJ,KACI,UADIA,EAAoB5C,GAAoBnX,OAAOmX,GAAoBH,gBAC5D,CAMd,GALIG,GAAoB6C,YACvB9D,EAAiBlhB,KAAKmiB,GAAoB6C,WAC1C7C,GAAoB6C,UAAY,MAEjC/D,IACIkB,GAAoBlL,OAAStQ,GAAS,CACzC,GAAIwb,GAAoBlL,OAASvQ,KAAeyb,GAAoBnL,KAAM,CAEzEoL,GAAuBlZ,KAAOiZ,GAAsBA,GAAoBjZ,KACxE,QACD,CACAiZ,GAAoBnX,OAAS,IAC9B,CACAmX,GAAoBF,YAAc,KAClCE,GAAoBlL,KAAO8N,EAC3B3C,GAAyBD,GACzBA,GAAsBA,GAAoBjZ,IAC3C,CACA,KAAO4Y,IACLiD,EAAoBjD,EAAc9W,OAAO8W,EAAcE,cAAgB8C,KACpEC,EAAoBze,EACvB2e,KAEAC,GAAcruB,EAEjB,CAEA,SAASquB,GAAcruB,GACtBsuB,GAAYrD,EAAc9W,OAAO8W,EAAcE,aAAe,IAC1DnrB,EACHyZ,IAEA8U,eAAe9U,GAChB,GACC,GAAI4R,GAAsBlL,MAAQkL,GAAsBlL,KAAK7hB,QAAS,CACrE,IAAIA,EAAU+sB,GAAsBlL,KAAK7hB,QACrC+sB,GAAsBjL,KAAO1Q,IAAqBpR,EAAQouB,cAC7DpuB,GAAQ,GAERA,GAAQ,EACV,SACQ+sB,GAAwBA,GAAsBhZ,OAASgZ,IAAyBJ,GACzFA,EAAgBA,EAAc+C,OAC/B,CAEA,SAASI,KAER,GADAE,MACKP,GAAqB,CACzB,IAAIS,GACJT,GAAsB,IAAI1vB,SAAQ,CAACC,EAASiV,IAAWib,EAAiBjb,KACpDA,OAASib,CAC9B,CACA,GACC,GAAInD,GAAsBlL,MAAQkL,GAAsBlL,KAAK5M,OAAQ,CACzD8X,GAAsBjL,KAAjC,IACI3a,EAAQ,IAAIG,MAAM,+CACtBH,EAAMgpB,YAAcV,GACpB1C,GAAsBlL,KAAK5M,OAAO9N,EACnC,SACQ4lB,GAAwBA,GAAsBhZ,OAASgZ,IAAyBJ,GACzFA,EAAgBA,EAAc+C,OAC/B,CAoBA,SAASM,GAAYpO,GACpB,IAAK,IAAI7b,EAAI,EAAG0D,EAAI+iB,EAAqBvnB,OAAQc,EAAI0D,EAAG1D,IACvD,IACCymB,EAAqBzmB,GAAG,CAACgO,KAAMgZ,GAAuBpL,KAAMgL,EAAe/K,SAC5E,CAAE,MAAMza,GACPyX,QAAQzX,MAAM,0BAA2BA,EAC1C,CAEF,CAsDA,SAASomB,KACRnC,EAAavV,OAAQuV,EAAajjB,SAAW,GAAM,GAAK,EACxD,IAAIilB,EAnFL,SAAsBvX,EAAQgX,EAAcuD,GAC3C,GAAI1D,EAAY,CAIf,IAAIU,EAAcvX,EAAOgX,GAEzB,OADAhX,EAAOgX,GA6E4E,EA5E5EO,CAER,CAGC,IACC,OAAOnN,QAAQ8N,GAAGlY,EAAQgX,EAsEwD,EArEnF,CAAE,MAAM1lB,GAER,YADAyX,QAAQzX,MAAMA,EAEd,CACF,CAiEmBkpB,CAAajF,EAAavV,OAASuV,EAAajjB,YAAe,GACjFykB,EAAeC,cAAgB,EAC3BO,EAActc,GACjBpB,EAAMzM,EAAIoT,QAAS,GAEhB+U,EAAajjB,SAAW0jB,IAC3BR,EAA0BD,EAAajjB,UACvCykB,EAAeC,aAAezB,EAAajjB,UAAY,EACvDykB,EAAe/W,OAASuV,EAAavV,OAEvC,CACA,SAASuZ,GAAcH,GAGlB3W,GAAYA,EAASa,SAAW,IACnCb,EAASiF,QAAS,GACnBta,EAAIqV,SAAWA,EAAW2W,GAAa,IACxC,CACAvhB,OAAOuK,OAAOV,EAAUnN,UAAW,CAClC4I,IAAI1K,EAAK4B,EAAOomB,EAAkB1N,GACjC,IAAIlS,EAAU+F,EAAQ,GAAI7S,SAAc0sB,EAgBxC,MAfY,UAAR1sB,GAAoB0sB,GACnBA,EAAiBC,cACpB9Z,GAAS,IACN6Z,EAAiBE,YACpB/Z,GAAS,IACN6Z,EAAiBG,SACpBha,GAAS,QACwB7J,MAA9B0jB,EAAiB1N,YACpBA,EAAY0N,EAAiB1N,WAC9B0N,EAAmBA,EAAiBhuB,QACZ,mBAAbsgB,IACVlS,EAAWkS,IACM,YAARhf,IACV8M,EAAW4f,GAELnD,GAAkB1W,EAAO1D,KAAMzK,EAAK4B,EAAO6I,KAAK6G,YAAc0W,GAAoB,OAAI1jB,EAAWgW,EAAjGuK,CAA4Gzc,EACpH,EACAsS,OAAO1a,EAAKooB,EAAkBhgB,GAC7B,IACIkS,EAAW1Y,EADXuM,EAAQ,GAeZ,YAbyB7J,IAArB8jB,IAC4B,mBAApBA,EACVhgB,EAAWggB,EACHA,IAAqB1e,IAActB,EAGnCqC,KAAK6G,YACbgJ,EAAY8N,GAEZja,EAAQ,GACRvM,EAAQwmB,GALRhgB,EAAWggB,GAQNvD,GAAkB1W,EAAO1D,KAAMzK,EAAK4B,OAAO0C,EAAWgW,EAAtDuK,CAAiEzc,EACzE,EACAuC,IAAI3K,EAAK8P,EAAS1H,GACjB,OAAOqC,KAAKiQ,OAAO1a,EAAK8P,EAAS1H,EAClC,EACAigB,WAAWroB,EAAKoI,GACf,OAAOqC,KAAK6P,UAAUta,EAAK,KAAMoI,EAClC,EACAkS,UAAUta,EAAKhG,EAASoO,EAAU0H,GACjC,IAAK1H,EACJ,OAAO,IAAIkC,IAAM,CAACge,EAAYlgB,KAC7B,IAAID,EAAUsC,KAAK6P,UAAUta,EAAKhG,EAASsuB,EAAYxY,GAGvD,OAFI1H,GACHD,EAAQG,KAAKF,GACPD,CAAO,IAGhB,GAAI6H,EACH,YAAgB1L,IAAZtK,GAAyByQ,KAAK0I,UAAUnT,EAAKhG,IAChDoO,IACOiB,IAEDC,GAER,IAAI6E,OAAgB7J,IAARtE,QAAiCsE,IAAZtK,EAAwB,EAAI,EACzD8V,GAASyY,aACZpa,GAAShF,IACN2G,GAAS0Y,gBACZra,GAAS/E,IACV,IACIjB,EADAsgB,EAAmB5D,GAAkB1W,EAAO1D,KAAMzK,OAAKsE,OAAWA,EAAWtK,IAEjFoqB,GAAc,GACG,EAChBjc,EAAUsgB,KAEV3E,EAAkB,KACjB3b,EAAUsgB,GAAkB,EAE7B1E,EAAwB,GAEzB,IACC,GAAwB,mBAAb3b,EACVA,SAEA,IAAK,IAAI3K,EAAI,EAAG0D,EAAIiH,EAASzL,OAAQc,EAAI0D,EAAG1D,IAAK,CAChD,IAAIirB,EAAYtgB,EAAS3K,GACzBgN,KAAKie,EAAUptB,MAAMotB,EAAU1oB,IAAK0oB,EAAU9mB,MAC/C,CAEF,CAAE,QACIuG,GAMJic,GAAc,EACda,OANAA,KACAb,GAAc,EACdjc,EAAUsgB,IACV3E,EAAkB,KAKpB,CACA,OAAO3b,CACR,EACAwgB,MAAMC,GACL,OAAOne,KAAK6P,eAAUhW,OAAWA,EAAWskB,EAC7C,EACA9G,KAAK1Z,GACJ,OAAOyc,GAAkB,KAAWpa,KAAM7H,OAAOqH,KAAK,SAAK3F,OAAWA,OAAWA,EAA1EugB,CAAqFzc,EAC7F,EACAwS,WAAWxS,GAOV,OANIqC,KAAKpI,UACJoI,KAAKpI,QAAQ2f,gBAChBvX,KAAKpI,QAAQ2f,kBACLvX,KAAKpI,QAAQ4f,aACrBxX,KAAKpI,QAAQ4f,WAAa,KAErB4C,GAAkB,GAAIpa,KAAM7H,OAAOqH,KAAK,SAAK3F,OAAWA,OAAWA,EAAnEugB,CAA8Ezc,EACtF,EACAygB,gBACC5D,IACD,EAEAxK,QAAQza,EAAK4B,EAAOomB,EAAkB1N,GACrC,OAAItK,EACIvF,KAAKC,IAAI1K,EAAK4B,EAAOomB,EAAkB1N,KAAejR,GAEtDoB,KAAK0V,iBAAgB,IAC3B1V,KAAKC,IAAI1K,EAAK4B,EAAOomB,EAAkB1N,KAAejR,IAAsBqU,EAAiB,MAAU,EAC1G,EACA/C,WAAW3a,EAAKooB,GACf,OAAIpY,EACIvF,KAAKiQ,OAAO1a,EAAKooB,KAAsB/e,GAEvCoB,KAAK0V,iBAAgB,IAC3B1V,KAAKiQ,OAAO1a,EAAKooB,KAAsB/e,IAAsBqU,EAAiB,MAAU,EAC3F,EACAzN,YAAY7H,GACX,OAAI4H,IAAayT,EAAiB4C,YAE1Bje,IAEDqC,KAAKqe,iBAAiB1gB,EAC9B,EACA0S,iBAAiB1S,GAChB,GAAIuW,EACH,MAAM,IAAI3f,MAAM,yDACjB,GAAIgR,EAAU,CACb,IAGI+Y,EAAcC,EAHdrC,EAAY3W,EACZiZ,EAAUtuB,EAAIqV,SAAWA,EAAW,CAAE5I,OAAO,GACjDzM,EAAI+rB,SAAS,GAEb,IACC,OAAO1W,EAASkZ,aAAehhB,EAAKE,IAAY4gB,EAAa/lB,GACxD+M,IAAaiZ,EACTjZ,EAASkZ,aAAa5gB,MAAK,IAAM0gB,EAAU/lB,MACnD8lB,GAAe,EACX9lB,IAAWwG,GACd9O,EAAIisB,WAEJjsB,EAAIksB,YACLC,GAAcH,GACP1jB,IACJpE,IAGH,MAFAlE,EAAIisB,WACJE,GAAcH,GACR9nB,CAAK,GAEb,CAAE,MAAMA,GAIP,MAHKkqB,GACJpuB,EAAIisB,WACLE,GAAcH,GACR9nB,CACP,CACD,CACA,OAAO4L,KAAKqe,iBAAiB1gB,GAAU,EACxC,EACA0gB,iBAAiB1gB,EAAUqe,GAC1B,IAAI0C,EACA7C,EACJ,GAAI1B,GAAqB2C,UACxBjB,EAAe1B,GAAqB2C,UACpC4B,EAAW7C,EAAa/jB,KAAKkkB,EAAU,CAAEre,WAAUqe,WAAYre,GAAY,OACrE,GAAIqb,EAAiB4C,YAC3BC,EAAe,CAACG,EAAU,CAAEre,WAAUqe,WAAYre,GAClDke,EAAaxQ,QAAUsN,EACvBK,EAAiBlhB,KAAK+jB,GACtB6C,EAAW,MACL,CACN,GAAInZ,EACH,MAAM,IAAIhR,MAAM,gDACjB,IAAIoqB,EAAcvE,GAAkB,GAAKpa,KAAKsT,iBAAmB,QAAW,GAAItT,MAChF6b,EAAe,CAACG,EAAU,CAAEre,WAAUqe,WAAYre,GAClDwc,GAAqB2C,UAAYjB,EACjC1B,GAAqB/U,GAAKwC,KAAKmK,SAC/B8J,EAAaxQ,QAAUsT,IACvBD,EAAW,CACZ,CACA,OAAO7C,EAAaxQ,QAAQxN,MAAMwN,IACjC,IAAI7S,EAASqjB,EAAa6C,GAC1B,GAAIlmB,IAAW0G,GACd,MAAM2c,EAAaU,OAAOmC,GAC3B,OAAOlmB,CAAM,GAEf,EACAkd,gBAAgB/X,EAAU+F,GACzB,GAAI6B,EAAU,CACb,IAAK2O,IAAyBra,MAAT6J,GAA+B,EAARA,GAE3C,OAAO1D,KAAKqQ,iBAAiB1S,GAC9B,IAAInF,EAASmF,IAKb,OAJInF,GAAUwG,IAAU0Z,IACvB7M,QAAQmK,KAAK,gEAAkEhW,KAAKgP,MAAQ,kBAAoB,wBAChH0J,GAAiC,GAE3BlgB,CACR,CACA,IAAI8lB,EAAcC,EAElB,GADAve,KAAK6V,gBACA3lB,EAAIoT,QACR,MAAM,IAAI/O,MAAM,+DACjBrE,EAAI+rB,SAAkBpiB,MAAT6J,EAAqB,EAAIA,GACtC,IAAI8a,EAAUjZ,EAAWrV,EAAIqV,SAAW,CAAE5I,OAAO,GACjD,IAEC,OADAqD,KAAKoN,KAAK,qBACH7H,EAASkZ,aAAehhB,EAAKE,IAAY4gB,EAAa/lB,IAC5D,GAAI+M,IAAaiZ,EAChB,OAAOjZ,EAASkZ,aAAa5gB,MAAK,IAAM0gB,EAAU/lB,KACnD,IAQC,OAPA8lB,GAAe,EACX9lB,IAAWwG,GACd9O,EAAIisB,YAEJjsB,EAAIksB,YACJhU,KAEM5P,CACR,CAAE,QACD6jB,GAAc,KACf,IACGjoB,IACH,IAAMlE,EAAIisB,UAAY,CAAE,MAAMyC,GAAI,CAElC,MADAvC,GAAc,MACRjoB,CAAK,GAEb,CAAE,MAAMA,GACP,IAAKkqB,EACJ,IAAMpuB,EAAIisB,UAAY,CAAE,MAAMyC,GAAI,CAEnC,MADAvC,GAAc,MACRjoB,CACP,CACD,EACAyqB,qBAAqBlhB,GACpB,OAAOqC,KAAK0V,gBAAgB/X,EAAU,EACvC,EAEA8a,UAAWA,EAAY,CACtB5a,KAAI,CAACihB,EAAaC,IACbpG,EACIA,EAAc9a,KAAKihB,EAAaC,GACpC3F,EACIA,EAAiBvb,MAAK,IAAMihB,GAAY,IAAOC,GAChDngB,GAAqBf,KAAKihB,EAAaC,IAGhDzD,QAAS,CAERzd,KAAI,CAACihB,EAAaC,KACbnG,IACHA,EAAaoG,cAAe,GACtBhyB,QAAQiyB,IAAI,CAACrG,GAAgBH,EAAWc,IAAmB1b,KAAKihB,EAAaC,KAGtF3S,WAAW8S,EAAiBC,GAC3Bnf,KAAKC,IAAMD,KAAKiQ,OAASjQ,KAAKE,IAAMF,KAAKke,MAAQle,KAAKkQ,WAAalQ,KAAKgQ,QAAUhQ,KAAKqe,iBAAmBre,KAAKqX,KAAOrX,KAAKmQ,WAAa,KAAQ,MAAM,IAAI5b,MAAM,qBAAoB,EAEpL,IAAI6qB,EAAexG,GAAgBD,GAAiBS,EAChDR,IACHA,EAAaoG,cAAe,GAC7B,IAAIK,EAAmB9F,EACvB,GAAI6F,GAAgBF,GAAmBE,EAEtC,OAAOpyB,QAAQiyB,IAAI,CAACG,EAAcC,IAAmBxhB,MAAK,IAAMmC,KAAKoM,WAAWgT,EAAcC,KAAmB,IAAMrf,KAAKoM,WAAWgT,EAAcC,KAEtJ1kB,OAAOC,eAAe1K,EAAK,OAAQ,CAAEiH,MAAO,MAC7C,EACAwX,GAAG2Q,EAAO3hB,GACI,gBAAT2hB,GACHrH,GAAoB,EACpByB,EAAsB5hB,KAAK6F,IACR,eAAT2hB,EACV7F,EAAqB3hB,KAAK6F,GAE1BoC,MAAM4O,GAAG2Q,EAAO3hB,EAClB,GAEF,CKnfE4hB,CAAgB/a,EAAW,CAAEtU,MAAKuT,aAAYuU,YAAavT,GAC1D2D,aAAc5D,EAAUnN,UAAU+Q,gBAAiB/C,IACrDb,EAAUnN,UAAUmoB,SAAW,CAC9BC,YAAY,EACZC,YAAY,EACZC,UAAU,EACVC,WAAW,EACXzf,OAAO,EACP8L,QAAQ,EACR4T,cAAc,EACdC,cAAc,GAEf,IAAIC,EAAQ1a,EAAQ2J,MAAQV,GAAa9J,EAAWtU,GAAOsU,EAC3D,OAAOa,EAAQ2a,QAAUD,EAAQ,IAAIA,EAAM1a,EAAQvT,MAAQ,KAAMuT,EAClE,CAWO,SAAS,KACf,OAAOX,GAAaub,WAAW,IAAI,EACpC,CAKO,SAAS,KACf,OAAOvb,GAAanC,UAAU,IAAI,EACnC,CAEA,MAAM8O,GAAkB,KClalB,GAA+Bzc,QAAQ,UCAvC,GAA+BA,QAAQ,M,ICAzCkS,GAIA1N,GACA8mB,G,4BAJJ,IACCpZ,GAAU,IAAIqZ,WACf,CAAE,MAAM/rB,GAAQ,CAGhB,IAAIgB,GAAW,EAEf,MAAMgrB,GAAc,GACpB,IAGIC,GACAC,GAGAC,GACAC,GAEA9qB,GAVA+qB,GAAUL,GACVM,GAAiB,EACjBC,GAAiB,CAAC,EAGlBC,GAAiB,EACjBC,GAAe,EAGfC,GAAoB,GAEpB9X,GAAiB,CACpB+X,YAAY,EACZC,eAAe,GAET,MAAMC,IACN,MAAMC,GAAK,IAAID,GACtBC,GAAGpvB,KAAO,mBACV,IAEIqvB,GAAYC,GAAoBC,GAFhCC,IAAiB,EACjBC,GAA4B,EAIhC,IACC,IAAIC,SAAS,GACd,CAAE,MAAMptB,GAEPmtB,GAA4BE,GAC7B,CAEO,MAAM,GACZ3hB,YAAYuF,GACPA,KACwB,IAAvBA,EAAQ0b,iBAAkDlnB,IAA1BwL,EAAQ2b,gBAC3C3b,EAAQ2b,eAAgB,GACrB3b,EAAQqc,aAAkC,IAApBrc,EAAQsc,UACjCtc,EAAQsc,SAAU,EACbtc,EAAQmS,YAAoC,GAAtBnS,EAAQ0b,aAClC1b,EAAQmS,WAAa,GAChBnS,EAAQuc,sBACZvc,EAAQuc,oBAAsB,KAG7Bvc,EAAQmS,WACXnS,EAAQmS,WAAWqK,aAAexc,EAAQmS,WAAWtlB,OAC7CmT,EAAQyS,iBACfzS,EAAQmS,WAAa,IAAIsK,eAAgB,EAC1Czc,EAAQmS,WAAWqK,aAAe,GAE/Bxc,EAAQ0c,gBACX1c,EAAQ2c,YAAc,WAGxBrnB,OAAOuK,OAAOlF,KAAMqF,EACrB,CACA4c,OAAOnhB,EAAQuE,GACd,GAAIjM,GAEH,OAAO8oB,IAAU,KAChBC,KACOniB,KAAOA,KAAKiiB,OAAOnhB,EAAQuE,GAAW,GAAQhO,UAAU4qB,OAAO3qB,KAAK0R,GAAgBlI,EAAQuE,MAGhGvE,EAAO7L,QAAU6L,EAAOhB,cAAgBT,cAC5CyB,EAA2B,oBAAX3I,OAAyBA,OAAOqH,KAAKsB,GAAU,IAAInK,WAAWmK,IACxD,iBAAZuE,GACV6a,GAAS7a,EAAQnO,KAAO4J,EAAO5O,OAC/BkD,GAAWiQ,EAAQpO,OAAS,IAE5B7B,GAAW,EACX8qB,GAAS7a,GAAW,EAAIA,EAAUvE,EAAO5O,QAE1CwuB,GAAiB,EACjBG,GAAe,EACfP,GAAY,KACZG,GAAUL,GACVG,GAAiB,KACjBnnB,GAAM0H,EAIN,IACCpL,GAAWoL,EAAOpL,WAAaoL,EAAOpL,SAAW,IAAIC,SAASmL,EAAO7L,OAAQ6L,EAAOlL,WAAYkL,EAAOjL,YACxG,CAAE,MAAMzB,GAGP,GADAgF,GAAM,KACF0H,aAAkBnK,WACrB,MAAMvC,EACP,MAAM,IAAIG,MAAM,oDAAuDuM,GAA2B,iBAAVA,EAAsBA,EAAOhB,YAAYhO,YAAcgP,GAChJ,CACA,GAAId,gBAAgB,GAAS,CAE5B,GADA2gB,GAAiB3gB,KACbA,KAAKwX,WAER,OADA6I,GAAoBrgB,KAAKwX,WAClB4K,GAAY/c,KACRgb,IAAqBA,GAAkBnuB,OAAS,KAC3DmuB,GAAoB,GAEtB,MACCM,GAAiB3X,KACZqX,IAAqBA,GAAkBnuB,OAAS,KACpDmuB,GAAoB,IAEtB,OAAO+B,GAAY/c,EACpB,CACAgd,eAAevhB,EAAQS,GACtB,IAAI8H,EAAQkP,EAAe,EAC3B,IACC+I,IAAiB,EACjB,IAAI3pB,EAAOmJ,EAAO5O,OACdiF,EAAQ6I,KAAOA,KAAKiiB,OAAOnhB,EAAQnJ,GAAQ2qB,GAAeL,OAAOnhB,EAAQnJ,GAC7E,IAAI4J,EASC,CAEJ,IADA8H,EAAS,CAAElS,GACL/B,GAAWuC,GAChB4gB,EAAenjB,GACfiU,EAAOvR,KAAKsqB,MAEb,OAAO/Y,CACR,CAfC,IAA+C,IAA3C9H,EAAQpK,EAAOohB,EAAcnjB,IAAqB,OACtD,KAAMA,GAAWuC,GAEhB,GADA4gB,EAAenjB,IACwC,IAAnDmM,EAAQ6gB,KAAe7J,EAAcnjB,IACxC,MAYJ,CAAE,MAAMhB,GAGP,MAFAA,EAAMmkB,aAAeA,EACrBnkB,EAAMiV,OAASA,EACTjV,CACP,CAAE,QACDktB,IAAiB,EACjBa,IACD,CACD,CACAI,iBAAiBC,EAAkB3K,GAC9BuJ,KACHoB,EAAmBpB,GAAmB9pB,KAAK0I,KAAMwiB,IAClDA,EAAmBA,GAAoB,GACnC7nB,OAAO8nB,SAASD,KACnBA,EAAmBA,EAAiBhuB,KAAIkuB,GAAaA,EAAUvvB,MAAM,MACtE,IAAK,IAAIH,EAAI,EAAG0D,EAAI8rB,EAAiBtwB,OAAQc,EAAI0D,EAAG1D,IAAK,CACxD,IAAI0vB,EAAYF,EAAiBxvB,GAC7B0vB,IACHA,EAAUC,UAAW,EACjB3vB,GAAK,KACR0vB,EAAUE,SAAY5vB,EAAI,IAAO,GAEpC,CACAwvB,EAAiBX,aAAeW,EAAiBtwB,OACjD,IAAK,IAAIkT,KAAMyS,GAAsB,GACpC,GAAIzS,GAAM,EAAG,CACZ,IAAIsd,EAAYF,EAAiBpd,GAC7Byd,EAAWhL,EAAmBzS,GAC9Byd,IACCH,KACFF,EAAiBM,oBAAsBN,EAAiBM,kBAAoB,KAAK1d,GAAMsd,GACzFF,EAAiBpd,GAAMyd,EAEzB,CAED,OAAO7iB,KAAKwX,WAAagL,CAC1B,CACAzb,OAAOjG,EAAQ5J,GACd,OAAO8I,KAAKiiB,OAAOnhB,EAAQ5J,EAC5B,EAKM,SAASkrB,GAAY/c,GAC3B,IACC,IAAKsb,GAAegB,UAAYL,GAAgB,CAC/C,IAAIO,EAAexB,GAAkBwB,cAAgB,EACjDA,EAAexB,GAAkBnuB,SACpCmuB,GAAkBnuB,OAAS2vB,EAC7B,CACA,IAAIrpB,EAkBJ,GAjBImoB,GAAeoC,uBAAyB3pB,GAAIhE,IAAY,IAAQgE,GAAIhE,KAAa,IAAQ+rB,IAC5F3oB,EAAS2oB,GAAW/nB,GAAKhE,GAAU8qB,GAAQS,IAC3CvnB,GAAM,KACAiM,GAAWA,EAAQ2d,OAASxqB,IACjCA,EAASA,EAAOuJ,UACjB3M,GAAW8qB,IAEX1nB,EAASyqB,KACN1C,KACHnrB,GAAWmrB,GAAe2C,mBAC1B3C,GAAiB,MAEde,KAGHjB,GAAkByC,kBAAoB,MAEnC1tB,IAAY8qB,GAEXG,IAAqBA,GAAkByC,mBAC1CA,KACDzC,GAAoB,KACpBjnB,GAAM,KACFonB,KACHA,GAAe,UACV,IAAIprB,GAAW8qB,GAErB,MAAM,IAAI3rB,MAAM,sCACV,IAAK+sB,GAAgB,CAC3B,IAAI6B,EACJ,IACCA,EAAWlc,KAAKwP,UAAUje,GAAQ,CAAC4qB,EAAGjsB,IAA2B,iBAAVA,EAAqB,GAAGA,KAAWA,IAAOhE,MAAM,EAAG,IAC3G,CAAE,MAAMiB,GACP+uB,EAAW,4BAA8B/uB,EAAQ,GAClD,CACA,MAAM,IAAIG,MAAM,4CAA8C4uB,EAC/D,EAEA,OAAO3qB,CACR,CAAE,MAAMpE,GAOP,MANIisB,IAAqBA,GAAkByC,mBAC1CA,KACDX,MACI/tB,aAAiBkC,YAAclC,EAAM6Y,QAAQoW,WAAW,6BAA+BjuB,GAAW8qB,MACrG9rB,EAAMkvB,YAAa,GAEdlvB,CACP,CACD,CAEA,SAAS0uB,KACR,IAAK,IAAI1d,KAAMib,GAAkByC,kBAChCzC,GAAkBjb,GAAMib,GAAkByC,kBAAkB1d,GAE7Dib,GAAkByC,kBAAoB,IACvC,CAEO,SAASG,KACf,IAAIM,EAAQnqB,GAAIhE,MAChB,GAAImuB,EAAQ,IAAM,CACjB,GAAIA,EAAQ,IAAM,CACjB,GAAIA,EAAQ,GACX,OAAOA,EACH,CACJ,IAAIb,EAAYrC,GAA0B,GAARkD,IACjC5C,GAAe7I,eAAiB0L,KAAyB,GAARD,GAClD,OAAIb,GACEA,EAAUO,OACdP,EAAUO,KAAOQ,GAAsBf,EAAmB,GAARa,IAE5Cb,EAAUO,QAEVM,CACT,CACD,CAAO,GAAIA,EAAQ,IAAM,CAGxB,GADAA,GAAS,IACL5C,GAAeK,cAAe,CACjC,IAAI0C,EAAS,CAAC,EACd,IAAK,IAAI1wB,EAAI,EAAGA,EAAIuwB,EAAOvwB,IAAK,CAC/B,IAAIuC,EAAMyB,KACE,cAARzB,IACHA,EAAM,YACPmuB,EAAOnuB,GAAO0tB,IACf,CACA,OAAOS,CACR,CAAO,CACN,IAAIlvB,EAAM,IAAIkZ,IACd,IAAK,IAAI1a,EAAI,EAAGA,EAAIuwB,EAAOvwB,IAC1BwB,EAAIoC,IAAIqsB,KAAQA,MAEjB,OAAOzuB,CACR,CACD,CAAO,CACN+uB,GAAS,IACT,IAAIphB,EAAQ,IAAIjU,MAAMq1B,GACtB,IAAK,IAAIvwB,EAAI,EAAGA,EAAIuwB,EAAOvwB,IAC1BmP,EAAMnP,GAAKiwB,KAEZ,OAAItC,GAAegD,WACXhpB,OAAOipB,OAAOzhB,GACfA,CACR,CACD,CAAO,GAAIohB,EAAQ,IAAM,CAExB,IAAIrxB,EAASqxB,EAAQ,IACrB,GAAI1C,IAAgBzrB,GACnB,OAAOkrB,GAAUntB,MAAMiC,GAAWwrB,IAAiBxrB,IAAYlD,GAAU0uB,IAE1E,GAAoB,GAAhBC,IAAqBX,GAAS,IAAK,CAEtC,IAAIlmB,EAAS9H,EAAS,GAAK2xB,GAAgB3xB,GAAU4xB,GAAe5xB,GACpE,GAAc,MAAV8H,EACH,OAAOA,CACT,CACA,OAAO+pB,GAAgB7xB,EACxB,CAAO,CACN,IAAIiF,EACJ,OAAQosB,GACP,KAAK,IAAM,OAAO,KAClB,KAAK,IACJ,OAAIhD,IACHppB,EAAQ8rB,KACJ9rB,EAAQ,EACJopB,GAAe,GAAGptB,MAAMotB,GAAeyD,UAAWzD,GAAeyD,WAAa7sB,GAE9EopB,GAAe,GAAGptB,MAAMotB,GAAe0D,UAAW1D,GAAe0D,WAAa9sB,IAEhF+pB,GACR,KAAK,IAAM,OAAO,EAClB,KAAK,IAAM,OAAO,EAClB,KAAK,IAGJ,GADA/pB,EAAQiC,GAAIhE,WACEyE,IAAV1C,EACH,MAAM,IAAI5C,MAAM,4BACjB,OAAO2vB,GAAQ/sB,GAChB,KAAK,IAIJ,OAFAA,EAAQzB,GAASyuB,UAAU/uB,IAC3BA,IAAY,EACL8uB,GAAQ/sB,GAChB,KAAK,IAIJ,OAFAA,EAAQzB,GAAS6M,UAAUnN,IAC3BA,IAAY,EACL8uB,GAAQ/sB,GAChB,KAAK,IAEJ,OAAOitB,GAAQhrB,GAAIhE,OACpB,KAAK,IAIJ,OAFA+B,EAAQzB,GAASyuB,UAAU/uB,IAC3BA,IAAY,EACLgvB,GAAQjtB,GAChB,KAAK,IAIJ,OAFAA,EAAQzB,GAAS6M,UAAUnN,IAC3BA,IAAY,EACLgvB,GAAQjtB,GAChB,KAAK,IAEJ,GADAA,EAAQzB,GAAS2uB,WAAWjvB,IACxBurB,GAAe2D,WAAa,EAAG,CAElC,IAAIC,EAAaC,IAAyB,IAAhBprB,GAAIhE,MAAqB,EAAMgE,GAAIhE,GAAW,IAAM,GAE9E,OADAA,IAAY,GACHmvB,EAAaptB,GAASA,EAAQ,EAAI,IAAO,KAAS,GAAKotB,CACjE,CAEA,OADAnvB,IAAY,EACL+B,EACR,KAAK,IAGJ,OAFAA,EAAQzB,GAASuqB,WAAW7qB,IAC5BA,IAAY,EACL+B,EAER,KAAK,IACJ,OAAOiC,GAAIhE,MACZ,KAAK,IAGJ,OAFA+B,EAAQzB,GAASyuB,UAAU/uB,IAC3BA,IAAY,EACL+B,EACR,KAAK,IAGJ,OAFAA,EAAQzB,GAAS6M,UAAUnN,IAC3BA,IAAY,EACL+B,EACR,KAAK,IAYJ,MAXmC,WAA/BwpB,GAAeqB,aAClB7qB,EAAuC,WAA/BzB,GAAS6M,UAAUnN,IAC3B+B,GAASzB,GAAS6M,UAAUnN,GAAW,IACE,WAA/BurB,GAAeqB,YACzB7qB,EAAQzB,GAAS+uB,aAAarvB,IAAU8V,WACC,SAA/ByV,GAAeqB,aACzB7qB,EAAQzB,GAAS+uB,aAAarvB,IAC1B+B,GAAOutB,OAAO,IAAIA,OAAO,MAAKvtB,EAAML,OAAOK,KAE/CA,EAAQzB,GAAS+uB,aAAarvB,IAC/BA,IAAY,EACL+B,EAGR,KAAK,IACJ,OAAOzB,GAASivB,QAAQvvB,MACzB,KAAK,IAGJ,OAFA+B,EAAQzB,GAASkvB,SAASxvB,IAC1BA,IAAY,EACL+B,EACR,KAAK,IAGJ,OAFAA,EAAQzB,GAASgC,SAAStC,IAC1BA,IAAY,EACL+B,EACR,KAAK,IAYJ,MAXmC,WAA/BwpB,GAAeqB,aAClB7qB,EAAsC,WAA9BzB,GAASgC,SAAStC,IAC1B+B,GAASzB,GAAS6M,UAAUnN,GAAW,IACE,WAA/BurB,GAAeqB,YACzB7qB,EAAQzB,GAASmvB,YAAYzvB,IAAU8V,WACE,SAA/ByV,GAAeqB,aACzB7qB,EAAQzB,GAASmvB,YAAYzvB,IACzB+B,GAAOutB,QAAQ,IAAIA,OAAO,KAAKvtB,GAAOutB,OAAO,IAAIA,OAAO,MAAKvtB,EAAML,OAAOK,KAE9EA,EAAQzB,GAASmvB,YAAYzvB,IAC9BA,IAAY,EACL+B,EAER,KAAK,IAGJ,GADAA,EAAQiC,GAAIhE,MACC,KAAT+B,EACH,OAAO2tB,GAAmC,GAAlB1rB,GAAIhE,OACtB,CACN,IAAI4c,EAAY8O,GAAkB3pB,GAClC,GAAI6a,EACH,OAAIA,EAAUiR,MACb7tB,KACO4c,EAAUiR,KAAKA,OACZjR,EAAU+S,UACpB3vB,KACO4c,KAEAA,EAAU5Y,GAAIhD,SAAShB,KAAYA,KAE3C,MAAM,IAAIb,MAAM,qBAAuB4C,EACzC,CACD,KAAK,IAGJ,OADAA,EAAQiC,GAAIhE,IACC,KAAT+B,GACH/B,KACO0vB,GAAmC,GAAlB1rB,GAAIhE,MAAoBgE,GAAIhE,QAE7CgvB,GAAQ,GACjB,KAAK,IAEJ,OAAOA,GAAQ,GAChB,KAAK,IAEJ,OAAOA,GAAQ,GAChB,KAAK,IAEJ,OAAOA,GAAQ,IAChB,KAAK,IAGJ,OADAjtB,EAAQiC,GAAIhE,MACRyrB,IAAgBzrB,GACZkrB,GAAUntB,MAAMiC,GAAWwrB,IAAiBxrB,IAAY+B,GAASypB,IAElEoE,GAAY7tB,GACpB,KAAK,IAIJ,OAFAA,EAAQzB,GAASyuB,UAAU/uB,IAEvByrB,KADJzrB,IAAY,GAEJkrB,GAAUntB,MAAMiC,GAAWwrB,IAAiBxrB,IAAY+B,GAASypB,IAElEqE,GAAa9tB,GACrB,KAAK,IAIJ,OAFAA,EAAQzB,GAAS6M,UAAUnN,IAEvByrB,KADJzrB,IAAY,GAEJkrB,GAAUntB,MAAMiC,GAAWwrB,IAAiBxrB,IAAY+B,GAASypB,IAElEsE,GAAa/tB,GACrB,KAAK,IAIJ,OAFAA,EAAQzB,GAASyuB,UAAU/uB,IAC3BA,IAAY,EACL+vB,GAAUhuB,GAClB,KAAK,IAIJ,OAFAA,EAAQzB,GAAS6M,UAAUnN,IAC3BA,IAAY,EACL+vB,GAAUhuB,GAClB,KAAK,IAIJ,OAFAA,EAAQzB,GAASyuB,UAAU/uB,IAC3BA,IAAY,EACLgwB,GAAQjuB,GAChB,KAAK,IAIJ,OAFAA,EAAQzB,GAAS6M,UAAUnN,IAC3BA,IAAY,EACLgwB,GAAQjuB,GAChB,QACC,GAAIosB,GAAS,IACZ,OAAOA,EAAQ,IAChB,QAAc1pB,IAAV0pB,EAAqB,CACxB,IAAInvB,EAAQ,IAAIG,MAAM,sCAEtB,MADAH,EAAMkvB,YAAa,EACblvB,CACP,CACA,MAAM,IAAIG,MAAM,6BAA+BgvB,GAGlD,CACD,CACA,MAAM8B,GAAY,4BAClB,SAAS5B,GAAsBf,EAAW4C,GACzC,SAASC,IAER,GAAIA,EAAWtb,QAAUsX,GAA2B,CACnD,IAAIgE,EAAa7C,EAAUO,KAAO,IAAKzB,SAAS,IAAK,6BAA+Bb,GAAegD,WAAa,gBAAkB,IACjI,KAAOjB,EAAUluB,KAAIe,GAAe,cAARA,EAAsB,eAAiB8vB,GAAUtzB,KAAKwD,GAAOA,EAAM,OAAU,IAAM0R,KAAKwP,UAAUlhB,GAAO,UAAU3D,KAAK,KAAO,MAD1H,CACkIqxB,IAGpK,OAF2B,IAAvBP,EAAUE,WACbF,EAAUO,KAAOuC,GAAuBF,EAAS5C,EAAUO,OACrDsC,GACR,CACA,IAAI7B,EAAS,CAAC,EACd,IAAK,IAAI1wB,EAAI,EAAG0D,EAAIgsB,EAAUxwB,OAAQc,EAAI0D,EAAG1D,IAAK,CACjD,IAAIuC,EAAMmtB,EAAU1vB,GACR,cAARuC,IACHA,EAAM,YACPmuB,EAAOnuB,GAAO0tB,IACf,CACA,OAAItC,GAAegD,WACXhpB,OAAOipB,OAAOF,GACfA,CACR,CAEA,OADA6B,EAAWtb,MAAQ,EACQ,IAAvByY,EAAUE,SACN4C,GAAuBF,EAASC,GAEjCA,CACR,CAEA,MAAMC,GAAyB,CAACF,EAASG,IACjC,WACN,IAAI7C,EAAWxpB,GAAIhE,MACnB,GAAiB,IAAbwtB,EACH,OAAO6C,IACR,IAAIrgB,EAAKkgB,EAAU,KAAOA,GAAW1C,GAAY,IAAM0C,GAAW1C,GAAY,GAC1EF,EAAYrC,GAAkBjb,IAAOoe,KAAiBpe,GAC1D,IAAKsd,EACJ,MAAM,IAAInuB,MAAM,gCAAkC6Q,GAInD,OAFKsd,EAAUO,OACdP,EAAUO,KAAOQ,GAAsBf,EAAW4C,IAC5C5C,EAAUO,MAClB,EAGM,SAASO,KACf,IAAIhB,EAAmBN,IAAU,KAEhC9oB,GAAM,KACCunB,GAAe7I,mBAEvB,OAAOuI,GAAoBM,GAAe4B,iBAAiBC,EAAkBnC,GAC9E,CAEA,IAAI0D,GAAkB2B,GAClBV,GAAcU,GACdT,GAAeS,GACfR,GAAeQ,GACZ,IAAIC,IAA8B,EAyCzC,SAASD,GAAaxzB,GACrB,IAAIsG,EACJ,GAAItG,EAAS,KACRsG,EAASqrB,GAAgB3xB,IAC5B,OAAOsG,EAET,GAAItG,EAAS,IAAM4U,GAClB,OAAOA,GAAQC,OAAO3N,GAAIhD,SAAShB,GAAUA,IAAYlD,IAC1D,MAAMgF,EAAM9B,GAAWlD,EACjB0zB,EAAQ,GAEd,IADAptB,EAAS,GACFpD,GAAW8B,GAAK,CACtB,MAAMiC,EAAQC,GAAIhE,MAClB,GAAuB,IAAV,IAAR+D,GAEJysB,EAAM9tB,KAAKqB,QACL,GAAuB,MAAV,IAARA,GAAwB,CAEnC,MAAM0sB,EAA0B,GAAlBzsB,GAAIhE,MAClBwwB,EAAM9tB,MAAe,GAARqB,IAAiB,EAAK0sB,EACpC,MAAO,GAAuB,MAAV,IAAR1sB,GAAwB,CAEnC,MAAM0sB,EAA0B,GAAlBzsB,GAAIhE,MACZ0wB,EAA0B,GAAlB1sB,GAAIhE,MAClBwwB,EAAM9tB,MAAe,GAARqB,IAAiB,GAAO0sB,GAAS,EAAKC,EACpD,MAAO,GAAuB,MAAV,IAAR3sB,GAAwB,CAKnC,IAAIE,GAAiB,EAARF,IAAiB,IAHE,GAAlBC,GAAIhE,QAG8B,IAFhB,GAAlBgE,GAAIhE,QAEgD,EADlC,GAAlBgE,GAAIhE,MAEdiE,EAAO,QACVA,GAAQ,MACRusB,EAAM9tB,KAAOuB,IAAS,GAAM,KAAS,OACrCA,EAAO,MAAiB,KAAPA,GAElBusB,EAAM9tB,KAAKuB,EACZ,MACCusB,EAAM9tB,KAAKqB,GAGRysB,EAAM1zB,QAAU,OACnBsG,GAAUG,GAAaotB,MAAMntB,OAAQgtB,GACrCA,EAAM1zB,OAAS,EAEjB,CAMA,OAJI0zB,EAAM1zB,OAAS,IAClBsG,GAAUG,GAAaotB,MAAMntB,OAAQgtB,IAG/BptB,CACR,CACO,SAASf,GAAWqJ,EAAQ7J,EAAO/E,GACzC,IAAI8zB,EAAc5sB,GAClBA,GAAM0H,EACN1L,GAAW6B,EACX,IACC,OAAOyuB,GAAaxzB,EACrB,CAAE,QACDkH,GAAM4sB,CACP,CACD,CAEA,SAASb,GAAUjzB,GAClB,IAAIiQ,EAAQ,IAAIjU,MAAMgE,GACtB,IAAK,IAAIc,EAAI,EAAGA,EAAId,EAAQc,IAC3BmP,EAAMnP,GAAKiwB,KAEZ,OAAItC,GAAegD,WACXhpB,OAAOipB,OAAOzhB,GACfA,CACR,CAEA,SAASijB,GAAQlzB,GAChB,GAAIyuB,GAAeK,cAAe,CACjC,IAAI0C,EAAS,CAAC,EACd,IAAK,IAAI1wB,EAAI,EAAGA,EAAId,EAAQc,IAAK,CAChC,IAAIuC,EAAMyB,KACE,cAARzB,IACHA,EAAM,YACPmuB,EAAOnuB,GAAO0tB,IACf,CACA,OAAOS,CACR,CAAO,CACN,IAAIlvB,EAAM,IAAIkZ,IACd,IAAK,IAAI1a,EAAI,EAAGA,EAAId,EAAQc,IAC3BwB,EAAIoC,IAAIqsB,KAAQA,MAEjB,OAAOzuB,CACR,CACD,CAEA,IAAImE,GAAeC,OAAOD,aAC1B,SAASmrB,GAAe5xB,GACvB,IAAI+E,EAAQ7B,GACRwN,EAAQ,IAAI1U,MAAMgE,GACtB,IAAK,IAAIc,EAAI,EAAGA,EAAId,EAAQc,IAAK,CAChC,MAAMizB,EAAO7sB,GAAIhE,MACjB,IAAY,IAAP6wB,GAAe,EAElB,YADA7wB,GAAW6B,GAGZ2L,EAAM5P,GAAKizB,CACZ,CACA,OAAOttB,GAAaotB,MAAMntB,OAAQgK,EACpC,CACA,SAASihB,GAAgB3xB,GACxB,GAAIA,EAAS,EAAG,CACf,GAAIA,EAAS,EAAG,CACf,GAAe,IAAXA,EACH,MAAO,GACH,CACJ,IAAIO,EAAI2G,GAAIhE,MACZ,OAAS,IAAJ3C,GAAY,OAChB2C,IAAY,GAGNuD,GAAalG,EACrB,CACD,CAAO,CACN,IAAIA,EAAI2G,GAAIhE,MACR1C,EAAI0G,GAAIhE,MACZ,IAAS,IAAJ3C,GAAY,IAAU,IAAJC,GAAY,EAElC,YADA0C,IAAY,GAGb,GAAIlD,EAAS,EACZ,OAAOyG,GAAalG,EAAGC,GACxB,IAAIwzB,EAAI9sB,GAAIhE,MACZ,OAAS,IAAJ8wB,GAAY,OAChB9wB,IAAY,GAGNuD,GAAalG,EAAGC,EAAGwzB,EAC3B,CACD,CAAO,CACN,IAAIzzB,EAAI2G,GAAIhE,MACR1C,EAAI0G,GAAIhE,MACR8wB,EAAI9sB,GAAIhE,MACRoF,EAAIpB,GAAIhE,MACZ,IAAS,IAAJ3C,GAAY,IAAU,IAAJC,GAAY,IAAU,IAAJwzB,GAAY,IAAU,IAAJ1rB,GAAY,EAEtE,YADApF,IAAY,GAGb,GAAIlD,EAAS,EAAG,CACf,GAAe,IAAXA,EACH,OAAOyG,GAAalG,EAAGC,EAAGwzB,EAAG1rB,GACzB,CACJ,IAAIokB,EAAIxlB,GAAIhE,MACZ,OAAS,IAAJwpB,GAAY,OAChBxpB,IAAY,GAGNuD,GAAalG,EAAGC,EAAGwzB,EAAG1rB,EAAGokB,EACjC,CACD,CAAO,GAAI1sB,EAAS,EAAG,CACtB,IAAI0sB,EAAIxlB,GAAIhE,MACRxH,EAAIwL,GAAIhE,MACZ,IAAS,IAAJwpB,GAAY,IAAU,IAAJhxB,GAAY,EAElC,YADAwH,IAAY,GAGb,GAAIlD,EAAS,EACZ,OAAOyG,GAAalG,EAAGC,EAAGwzB,EAAG1rB,EAAGokB,EAAGhxB,GACpC,IAAIu4B,EAAI/sB,GAAIhE,MACZ,OAAS,IAAJ+wB,GAAY,OAChB/wB,IAAY,GAGNuD,GAAalG,EAAGC,EAAGwzB,EAAG1rB,EAAGokB,EAAGhxB,EAAGu4B,EACvC,CAAO,CACN,IAAIvH,EAAIxlB,GAAIhE,MACRxH,EAAIwL,GAAIhE,MACR+wB,EAAI/sB,GAAIhE,MACRgxB,EAAIhtB,GAAIhE,MACZ,IAAS,IAAJwpB,GAAY,IAAU,IAAJhxB,GAAY,IAAU,IAAJu4B,GAAY,IAAU,IAAJC,GAAY,EAEtE,YADAhxB,IAAY,GAGb,GAAIlD,EAAS,GAAI,CAChB,GAAe,IAAXA,EACH,OAAOyG,GAAalG,EAAGC,EAAGwzB,EAAG1rB,EAAGokB,EAAGhxB,EAAGu4B,EAAGC,GACrC,CACJ,IAAIpzB,EAAIoG,GAAIhE,MACZ,OAAS,IAAJpC,GAAY,OAChBoC,IAAY,GAGNuD,GAAalG,EAAGC,EAAGwzB,EAAG1rB,EAAGokB,EAAGhxB,EAAGu4B,EAAGC,EAAGpzB,EAC7C,CACD,CAAO,GAAId,EAAS,GAAI,CACvB,IAAIc,EAAIoG,GAAIhE,MACR0mB,EAAI1iB,GAAIhE,MACZ,IAAS,IAAJpC,GAAY,IAAU,IAAJ8oB,GAAY,EAElC,YADA1mB,IAAY,IAGb,GAAIlD,EAAS,GACZ,OAAOyG,GAAalG,EAAGC,EAAGwzB,EAAG1rB,EAAGokB,EAAGhxB,EAAGu4B,EAAGC,EAAGpzB,EAAG8oB,GAChD,IAAIuK,EAAIjtB,GAAIhE,MACZ,OAAS,IAAJixB,GAAY,OAChBjxB,IAAY,IAGNuD,GAAalG,EAAGC,EAAGwzB,EAAG1rB,EAAGokB,EAAGhxB,EAAGu4B,EAAGC,EAAGpzB,EAAG8oB,EAAGuK,EACnD,CAAO,CACN,IAAIrzB,EAAIoG,GAAIhE,MACR0mB,EAAI1iB,GAAIhE,MACRixB,EAAIjtB,GAAIhE,MACRsB,EAAI0C,GAAIhE,MACZ,IAAS,IAAJpC,GAAY,IAAU,IAAJ8oB,GAAY,IAAU,IAAJuK,GAAY,IAAU,IAAJ3vB,GAAY,EAEtE,YADAtB,IAAY,IAGb,GAAIlD,EAAS,GAAI,CAChB,GAAe,KAAXA,EACH,OAAOyG,GAAalG,EAAGC,EAAGwzB,EAAG1rB,EAAGokB,EAAGhxB,EAAGu4B,EAAGC,EAAGpzB,EAAG8oB,EAAGuK,EAAG3vB,GACjD,CACJ,IAAI4vB,EAAIltB,GAAIhE,MACZ,OAAS,IAAJkxB,GAAY,OAChBlxB,IAAY,IAGNuD,GAAalG,EAAGC,EAAGwzB,EAAG1rB,EAAGokB,EAAGhxB,EAAGu4B,EAAGC,EAAGpzB,EAAG8oB,EAAGuK,EAAG3vB,EAAG4vB,EACzD,CACD,CAAO,CACN,IAAIA,EAAIltB,GAAIhE,MACRmxB,EAAIntB,GAAIhE,MACZ,IAAS,IAAJkxB,GAAY,IAAU,IAAJC,GAAY,EAElC,YADAnxB,IAAY,IAGb,GAAIlD,EAAS,GACZ,OAAOyG,GAAalG,EAAGC,EAAGwzB,EAAG1rB,EAAGokB,EAAGhxB,EAAGu4B,EAAGC,EAAGpzB,EAAG8oB,EAAGuK,EAAG3vB,EAAG4vB,EAAGC,GAC5D,IAAI7rB,EAAItB,GAAIhE,MACZ,OAAS,IAAJsF,GAAY,OAChBtF,IAAY,IAGNuD,GAAalG,EAAGC,EAAGwzB,EAAG1rB,EAAGokB,EAAGhxB,EAAGu4B,EAAGC,EAAGpzB,EAAG8oB,EAAGuK,EAAG3vB,EAAG4vB,EAAGC,EAAG7rB,EAC/D,CACD,CACD,CACD,CACD,CAEA,SAAS8rB,KACR,IACIt0B,EADAqxB,EAAQnqB,GAAIhE,MAEhB,GAAImuB,EAAQ,IAEXrxB,EAASqxB,EAAQ,SAEjB,OAAOA,GACN,KAAK,IAEJrxB,EAASkH,GAAIhE,MACb,MACD,KAAK,IAEJlD,EAASwD,GAASyuB,UAAU/uB,IAC5BA,IAAY,EACZ,MACD,KAAK,IAEJlD,EAASwD,GAAS6M,UAAUnN,IAC5BA,IAAY,EACZ,MACD,QACC,MAAM,IAAIb,MAAM,mBAGnB,OAAOmxB,GAAaxzB,EACrB,CAGA,SAASgyB,GAAQhyB,GAChB,OAAOyuB,GAAenK,YAErB7f,WAAWU,UAAUlE,MAAMmE,KAAK8B,GAAKhE,GAAUA,IAAYlD,GAC3DkH,GAAIhD,SAAShB,GAAUA,IAAYlD,EACrC,CACA,SAASkyB,GAAQlyB,GAChB,IAAIrB,EAAOuI,GAAIhE,MACf,GAAI0rB,GAAkBjwB,GAAO,CAC5B,IAAIqG,EACJ,OAAO4pB,GAAkBjwB,GAAMuI,GAAIhD,SAAShB,GAAU8B,EAAO9B,IAAYlD,IAAWu0B,IACnFrxB,GAAWqxB,EACX,IACC,OAAOxD,IACR,CAAE,QACD7tB,GAAW8B,CACZ,IAEF,CAEC,MAAM,IAAI3C,MAAM,0BAA4B1D,EAC9C,CAEA,IAAI61B,GAAW,IAAIx4B,MAAM,MACzB,SAAS8I,KACR,IAAI9E,EAASkH,GAAIhE,MACjB,KAAIlD,GAAU,KAAQA,EAAS,KAS9B,OADAkD,KACO6tB,KAAO/X,WANd,GADAhZ,GAAkB,IACd2uB,IAAgBzrB,GACnB,OAAOkrB,GAAUntB,MAAMiC,GAAWwrB,IAAiBxrB,IAAYlD,GAAU0uB,IACrE,KAAsB,GAAhBC,IAAqBX,GAAS,KACxC,OAAO6D,GAAgB7xB,GAKzB,IAIIy0B,EAJApxB,EAAuG,MAA/FrD,GAAU,GAAMA,EAAS,EAAIwD,GAASyuB,UAAU/uB,IAAYlD,EAAS,EAAIkH,GAAIhE,IAAY,IACjG+Z,EAAQuX,GAASnxB,GACjBqxB,EAAgBxxB,GAChB8B,EAAM9B,GAAWlD,EAAS,EAE1Bc,EAAI,EACR,GAAImc,GAASA,EAAMvM,OAAS1Q,EAAQ,CACnC,KAAO00B,EAAgB1vB,GAAK,CAE3B,GADAyvB,EAAQjxB,GAAS6M,UAAUqkB,GACvBD,GAASxX,EAAMnc,KAAM,CACxB4zB,EAAgB,WAChB,KACD,CACAA,GAAiB,CAClB,CAEA,IADA1vB,GAAO,EACA0vB,EAAgB1vB,GAEtB,GADAyvB,EAAQvtB,GAAIwtB,KACRD,GAASxX,EAAMnc,KAAM,CACxB4zB,EAAgB,WAChB,KACD,CAED,GAAIA,IAAkB1vB,EAErB,OADA9B,GAAWwxB,EACJzX,EAAMnV,OAEd9C,GAAO,EACP0vB,EAAgBxxB,EACjB,CAIA,IAHA+Z,EAAQ,GACRuX,GAASnxB,GAAO4Z,EAChBA,EAAMvM,MAAQ1Q,EACP00B,EAAgB1vB,GACtByvB,EAAQjxB,GAAS6M,UAAUqkB,GAC3BzX,EAAMrX,KAAK6uB,GACXC,GAAiB,EAGlB,IADA1vB,GAAO,EACA0vB,EAAgB1vB,GACtByvB,EAAQvtB,GAAIwtB,KACZzX,EAAMrX,KAAK6uB,GAGZ,IAAI3sB,EAAS9H,EAAS,GAAK2xB,GAAgB3xB,GAAU4xB,GAAe5xB,GACpE,OACQid,EAAMnV,OADA,MAAVA,EACmBA,EACD+pB,GAAgB7xB,EACvC,CAGA,MAAM4yB,GAAmB,CAAC1f,EAAIwd,KAC7B,IAAIF,EAAYO,KAAOzuB,KAAIqyB,GAAYA,EAAS3b,aAC5C4b,EAAY1hB,OACCvL,IAAb+oB,IACHxd,EAAKA,EAAK,MAAQwd,GAAY,GAAKxd,IAAQwd,GAAY,GAAKxd,EAC5Dsd,EAAUE,SAAWA,GAEtB,IAAImE,EAAoB1G,GAAkBjb,GAS1C,OALI2hB,IAAsBA,EAAkBpE,UAAYrB,OACtDjB,GAAkByC,oBAAsBzC,GAAkByC,kBAAoB,KAAK1d,GAAM2hB,GAE3F1G,GAAkBjb,GAAMsd,EACxBA,EAAUO,KAAOQ,GAAsBf,EAAWoE,GAC3CpE,EAAUO,MAAK,EAEvBnC,GAAkB,GAAK,OACvBA,GAAkB,GAAGiE,UAAW,EAEhC,IAAIxI,GAAS,CAAEhoB,MAAOyyB,UAAWC,gBACjCnG,GAAkB,KAAQ,KACzB,IAAI1Z,EAAO6b,KACX,OAAQ1G,GAAOnV,EAAK,KAAO7S,OAAO6S,EAAK,GAAE,EAG1C0Z,GAAkB,KAAS1Z,IAE1B,IAAIhC,EAAK1P,GAAS6M,UAAUnN,GAAW,GAClCorB,KACJA,GAAe,IAAI9S,KACpB,IACIrZ,EADAkvB,EAAQnqB,GAAIhE,IAKff,EADGkvB,GAAS,KAAQA,EAAQ,KAAiB,KAATA,GAA0B,KAATA,EAC5C,GAEA,CAAC,EAEX,IAAI2D,EAAW,CAAE7yB,UACjBmsB,GAAa5pB,IAAIwO,EAAI8hB,GACrB,IAAIC,EAAmBlE,KACvB,OAAIiE,EAAS9X,KACLzU,OAAOuK,OAAO7Q,EAAQ8yB,IAC9BD,EAAS7yB,OAAS8yB,EACXA,IAGRrG,GAAkB,KAAS1Z,IAE1B,IAAIhC,EAAK1P,GAAS6M,UAAUnN,GAAW,GACnC8xB,EAAW1G,GAAa1lB,IAAIsK,GAEhC,OADA8hB,EAAS9X,MAAO,EACT8X,EAAS7yB,QAGjBysB,GAAkB,KAAQ,IAAM,IAAIvQ,IAAI0S,MAEjC,MAAMmE,GAAc,CAAC,OAAO,QAAQ,eAAe,QAAQ,SAAS,QAAQ,SAAS,UAAU,UAAU,WAAW,aAAa5yB,KAAI3D,GAAQA,EAAO,UAE3J,IAAIw2B,GAA6B,iBAAfnZ,WAA0BA,WAAatd,OACzDkwB,GAAkB,KAAS1Z,IAC1B,IAAIkgB,EAAWlgB,EAAK,GAChBmgB,EAAiBH,GAAYE,GACjC,IAAKC,EACJ,MAAM,IAAIhzB,MAAM,uCAAyC+yB,GAE1D,OAAO,IAAID,GAAKE,GAAgB5wB,WAAWU,UAAUlE,MAAMmE,KAAK8P,EAAM,GAAGnS,OAAM,EAEhF6rB,GAAkB,KAAQ,KACzB,IAAI1Z,EAAO6b,KACX,OAAO,IAAIuE,OAAOpgB,EAAK,GAAIA,EAAK,GAAE,EAEnC,MAAMqgB,GAAc,GAgCpB,SAASvF,GAAUvkB,GACd0jB,IACHA,KACD,IAAIqG,EAAcxH,GACdyH,EAAgBvyB,GAChBwyB,EAAsBlH,GACtBmH,EAAsBjH,GACtBkH,EAAoBjH,GACpBkH,EAAiBzH,GACjB0H,EAAevH,GACfwH,EAAoBzH,GACpB0H,EAAsB3H,GAGtB4H,EAAW,IAAIxxB,WAAWyC,GAAIjG,MAAM,EAAG+sB,KACvCkI,EAAkB/H,GAClBgI,EAA0BhI,GAAkBltB,MAAM,EAAGktB,GAAkBnuB,QACvEo2B,EAAa3H,GACb4H,EAAsBjH,GACtBnqB,EAAQwG,IAgBZ,OAfAuiB,GAASwH,EACTtyB,GAAWuyB,EACXjH,GAAiBkH,EACjBhH,GAAiBiH,EACjBhH,GAAeiH,EACfxH,GAAYyH,EACZtH,GAAUuH,EACVxH,GAAeyH,EACf1H,GAAiB2H,EACjB9uB,GAAM+uB,EACN7G,GAAiBiH,GACjBlI,GAAoB+H,GACFhoB,OAAO,EAAGigB,GAAkBnuB,UAAWm2B,GACzD1H,GAAiB2H,EACjB5yB,GAAW,IAAIC,SAASyD,GAAInE,OAAQmE,GAAIxD,WAAYwD,GAAIvD,YACjDsB,CACR,CACO,SAASgrB,KACf/oB,GAAM,KACNonB,GAAe,KACfH,GAAoB,IACrB,CAxEAS,GAAkB,IAAS1Z,IAC1B,IAAIohB,GAAYphB,EAAK,IAAM,KAAOA,EAAK,IAAM,KAAOA,EAAK,IAAM,GAAKA,EAAK,GACrEqhB,EAAerzB,GAQnB,OAPAA,IAAYozB,EAAWphB,EAAKlV,OAC5BquB,GAAiBkH,IACjBlH,GAAiB,CAACiG,KAAoBA,OACvBvC,UAAY,EAC3B1D,GAAeyD,UAAY,EAC3BzD,GAAe2C,mBAAqB9tB,GACpCA,GAAWqzB,EACJxF,IAAK,EAGbnC,GAAkB,KAAS1Z,GAEP,GAAfA,EAAKlV,OACD,IAAIupB,KAA0E,KAA1D,SAAVrU,EAAK,IAAkBA,EAAK,IAAM,KAAOA,EAAK,IAAM,GAAKA,EAAK,KACxD,GAAfA,EAAKlV,OACN,IAAIupB,OACRrU,EAAK,IAAM,KAAOA,EAAK,IAAM,KAAOA,EAAK,IAAM,IAAMA,EAAK,IAAM,IAAM,IAC6B,KAAlF,YAAP,EAAVA,EAAK,IAAoC,SAAVA,EAAK,IAAkBA,EAAK,IAAM,KAAOA,EAAK,IAAM,GAAKA,EAAK,KACzE,IAAfA,EAAKlV,OACN,IAAIupB,OACRrU,EAAK,IAAM,KAAOA,EAAK,IAAM,KAAOA,EAAK,IAAM,GAAKA,EAAK,IAAM,IACoG,MAAxJ,IAAVA,EAAK,IAAc,gBAAkB,GAAe,cAAVA,EAAK,GAA+B,WAAVA,EAAK,GAA6B,SAAVA,EAAK,IAAkBA,EAAK,IAAM,KAAOA,EAAK,KAAO,GAAKA,EAAK,MAExJ,IAAIqU,KAAK,WAuDX,MAAM+I,GAAS,IAAIt2B,MAAM,KAChC,IAAK,IAAI8E,EAAI,EAAGA,EAAI,IAAKA,IACxBwxB,GAAOxxB,KAAO,KAAO4U,KAAKkK,MAAM,MAAY,OAAJ9e,IAGzC,IAAIsvB,GAAiB,IAAI,GAAQ,CAAEvB,YAAY,IACzBuB,GAAeL,OACPK,GAAeD,eACvBC,GAAeL,OAOrC,ICpnCI9sB,GAIAuzB,GAAYC,GDgnCZC,GAAW,IAAIC,aAAa,GAClB,IAAIlyB,WAAWiyB,GAAS3zB,OAAQ,EAAG,GCpnCjD,IACCE,GAAc,IAAIE,WACnB,CAAE,MAAOjB,GAAQ,CAEjB,MAAM8D,GAAkC,oBAAXC,OACvBC,GAAoBF,GACzB,SAAShG,GAAU,OAAOiG,OAAOE,gBAAgBnG,EAAQ,EAAIyE,WACxD,GAAYuB,GAAgBC,OAASxB,WACrCmyB,GAAkB5wB,GAAgB,WAAc,WACtD,IAAI7D,GAAQ00B,GACRtzB,GAEAuzB,GAEAC,GAHA,GAAW,EAEX,GAAiB,KAErB,MACMC,GAAc,kBACPC,GAAgB5xB,OAAO,aAC7B,MAAM,WAAc,GAC1BuI,YAAYuF,GAGX,IACIpO,EACAmyB,EACA5R,EACAgJ,EANJzgB,MAAMsF,GACNrF,KAAKyG,OAAS,EAMd,IAAI4iB,EAAa,GAAUhyB,UAAUnB,UAAY,SAAS8D,EAAQ5E,GACjE,OAAOf,GAAO6B,UAAU8D,EAAQ5E,EAAU,WAC3C,KAAKD,KAAeA,GAAYgB,aAC/B,SAAS6D,EAAQ5E,GAChB,OAAOD,GAAYgB,WAAW6D,EAAQ3F,GAAO+B,SAAShB,IAAWiB,OAClE,EAEGizB,EAAQtpB,KACPqF,IACJA,EAAU,CAAC,GACZ,IAAIkkB,EAAelkB,GAAWA,EAAQqc,WAClC8H,EAAsBnkB,EAAQmS,YAAcnS,EAAQqS,eACpDkK,EAAsBvc,EAAQuc,oBAGlC,GAF2B,MAAvBA,IACHA,EAAsB4H,EAAsB,GAAK,GAC9C5H,EAAsB,KACzB,MAAM,IAAIrtB,MAAM,sCACb8Q,EAAQokB,iBAAwC5vB,MAArBwL,EAAQqkB,YACtC1pB,KAAK0pB,WAAY,GAElB,IAAIC,EAAmBtkB,EAAQskB,iBACP,MAApBA,IACHA,EAAmBH,EAAsB,GAAK,IAC1CxpB,KAAKwX,YAAoC,GAAtBnS,EAAQ0b,aAC/B/gB,KAAKwX,WAAa,IAEnB,IAAIoS,EAAoBhI,EAAsB,IAAO+H,EAAmB/H,EAAsB,GAC1FiI,EAAgBjI,EAAsB,GACtCkI,EAAiBlI,EAAsB+H,EAAmB,GAC9D,GAAIG,EAAiB,KACpB,MAAM,IAAIv1B,MAAM,wDAEjB,IAAIw1B,EAAoB,GACpBC,EAAmB,EACnBC,EAAuC,EAE3CjqB,KAAKkqB,KAAOlqB,KAAK4I,OAAS,SAASzR,EAAOgzB,GAuBzC,GAtBK91B,KACJA,GAAS,IAAI+D,GAAkB,MAC/B3C,GAAapB,GAAOqB,WAAarB,GAAOqB,SAAW,IAAIC,SAAStB,GAAOY,OAAQ,EAAG,OAClF,GAAW,GAEZ+zB,GAAU30B,GAAOnC,OAAS,GACtB82B,GAAU,GAAW,MAExB30B,GAAS,IAAI+D,GAAkB/D,GAAOnC,QACtCuD,GAAapB,GAAOqB,WAAarB,GAAOqB,SAAW,IAAIC,SAAStB,GAAOY,OAAQ,EAAGZ,GAAOnC,SACzF82B,GAAU30B,GAAOnC,OAAS,GAC1B,GAAW,GAEX,GAAY,GAAW,EAAK,WAC7B+E,EAAQ,GACRupB,EAAe8I,EAAMG,gBAAkB,IAAI/b,IAAQ,KAC/C4b,EAAMc,eAAkC,iBAAVjzB,GACjC,GAAiB,GACjB,GAAeQ,KAAO8pB,KAEtB,GAAiB,KAClBjK,EAAa8R,EAAM9R,WACfA,EAAY,CACXA,EAAWsK,gBACdtK,EAAa8R,EAAM/G,iBAAiB+G,EAAMxR,kBAC3C,IAAI+J,EAAerK,EAAWqK,cAAgB,EAC9C,GAAIA,EAAeD,EAElB,MAAM,IAAIrtB,MAAM,qGAAuGijB,EAAWqK,cAEnI,IAAKrK,EAAW6S,YAAa,CAE5B7S,EAAW6S,YAAc1vB,OAAO6a,OAAO,MACvC,IAAK,IAAIxiB,EAAI,EAAGA,EAAI6uB,EAAc7uB,IAAK,CACtC,IAAIoY,EAAOoM,EAAWxkB,GACtB,IAAKoY,EACJ,SACD,IAAIkf,EAAgBC,EAAa/S,EAAW6S,YAC5C,IAAK,IAAIvO,EAAI,EAAGplB,EAAI0U,EAAKlZ,OAAQ4pB,EAAIplB,EAAGolB,IAAK,CAC5C,IAAIvmB,EAAM6V,EAAK0Q,GACfwO,EAAiBC,EAAWh1B,GACvB+0B,IACJA,EAAiBC,EAAWh1B,GAAOoF,OAAO6a,OAAO,OAElD+U,EAAaD,CACd,CACAC,EAAWpB,IAAiBn2B,EAAI,EACjC,CACAgN,KAAKwqB,0BAA4B3I,CAClC,CACK0H,IACJ/R,EAAWiT,OAAS5I,EAAe,GAErC,CACIuH,IACHA,GAAkB,GACnB,IACKE,EAAMvG,uBAAyB5rB,GAASA,EAAM2I,aAAe3I,EAAM2I,cAAgBnF,OACtF+vB,EAAYvzB,GAEZ+yB,EAAK/yB,GACN,IAAIwzB,EAAa,GAGjB,GAFI,IACHC,GAAa3zB,EAAOizB,EAAM,GACvB1J,GAAgBA,EAAaqK,YAAa,CAC7C,IAAIA,EAAcrK,EAAaqK,YAAYp2B,MAAK,CAAChC,EAAGC,IAAMD,EAAEgU,OAAS/T,EAAE+T,OAAS,GAAK,IACjFzT,EAAI63B,EAAY34B,OAChB44B,GAAqB,EACzB,KAAOH,GAAc33B,EAAI,GAAG,CAC3B,IAAI+3B,EAAiBF,IAAc73B,GAAGyT,OAASxP,EAC3C8zB,EAAkBJ,EAAWK,gBAAkB/zB,IAAiC,IAAvB6zB,IAC5DA,EAAoB,GACjBC,EAAkBJ,EAAWv1B,SAAW6B,EACvC6zB,GAAqB,IACxBA,GAAqB,IAElBA,GAAqB,IAExBr1B,GAAWoB,UAAU8zB,EAAWv1B,SAAW6B,EAC1CxB,GAAW8M,UAAUooB,EAAWv1B,SAAW6B,GAAS6zB,GACrDA,GAAqB,GAEtBH,EAAaA,EAAW5xB,SACxB/F,IAEF,CACI83B,GAAqB,GAAKH,GAE7Bl1B,GAAWoB,UAAU8zB,EAAWv1B,SAAW6B,EAC1CxB,GAAW8M,UAAUooB,EAAWv1B,SAAW6B,GAAS6zB,GAEtD,IAAiC,EAArBD,EAAY34B,OACpB,GAAW82B,IACdiC,EAAS,IACV3B,EAAM7iB,OAAS,GACf,IAAIykB,EAszBT,SAAmBA,EAAYL,GAE9B,IAAIJ,EACAU,EAAsC,EAArBN,EAAY34B,OAC7Bk5B,EAAUF,EAAWh5B,OAASi5B,EAClC,KAAOV,EAASI,EAAY93B,OAAO,CAClC,IAAI0T,EAASgkB,EAAOhkB,OAChBrB,EAAKqlB,EAAOrlB,GAChB8lB,EAAWG,WAAW5kB,EAAS0kB,EAAgB1kB,EAAQ2kB,GACvDD,GAAkB,EAClB,IAAI/1B,EAAWqR,EAAS0kB,EACxBD,EAAW91B,KAAc,IACzB81B,EAAW91B,KAAc,IACzB81B,EAAW91B,KAAcgQ,GAAM,GAC/B8lB,EAAW91B,KAAegQ,GAAM,GAAM,IACtC8lB,EAAW91B,KAAegQ,GAAM,EAAK,IACrC8lB,EAAW91B,KAAmB,IAALgQ,EACzBgmB,EAAU3kB,CACX,CACA,OAAOykB,CACR,CA10BsBI,CAAUj3B,GAAO+B,SAASa,EAAO,IAAW4zB,GAE7D,OADArK,EAAe,KACR0K,CACR,CAEA,OADA5B,EAAM7iB,OAAS,GACX0jB,EAAgB,IACnB91B,GAAO4C,MAAQA,EACf5C,GAAO6C,IAAM,GACN7C,IAEDA,GAAO+B,SAASa,EAAO,GAC/B,CAAE,QACD,GAAIugB,EAAY,CACXyS,EAAuC,IAC1CA,IACD,IAAIpI,EAAerK,EAAWqK,cAAgB,EAG9C,GAFIrK,EAAWtlB,OAAS2vB,IAAiB0H,IACxC/R,EAAWtlB,OAAS2vB,GACjBmI,EAAmB,IAEtBxS,EAAW6S,YAAc,KACzBJ,EAAuC,EACvCD,EAAmB,EACfD,EAAkB73B,OAAS,IAC9B63B,EAAoB,SACf,GAAIA,EAAkB73B,OAAS,IAAMq3B,EAAc,CACzD,IAAK,IAAIv2B,EAAI,EAAG0D,EAAIqzB,EAAkB73B,OAAQc,EAAI0D,EAAG1D,IACpD+2B,EAAkB/2B,GAAGm2B,IAAiB,EAEvCY,EAAoB,EACrB,CACA,GAAIX,GAAmBE,EAAM5R,eAAgB,CAE5C,IAAI6T,EAAel3B,GAAO+B,SAASa,EAAO,IACtCu0B,EAAgBC,GAAkBjU,EAAY8R,GAClD,OAAwE,IAApEA,EAAM5R,eAAe8T,EAAeA,EAAc7T,cAE9C2R,EAAMY,KAAK/yB,IAEnBmyB,EAAMkB,0BAA4B3I,EAC3B0J,EACR,CACD,CACIpB,EAAgB,KACnB,GAAWlzB,EACb,CACD,EACA,MAAMy0B,EAAav0B,IAClB,IAAIjF,EAASiF,EAAMjF,OACfA,EAAS,GACZmC,GAAO,MAAc,IAAOnC,EAClBA,EAAS,OACnBmC,GAAO,MAAc,IACrBA,GAAO,MAAcnC,GAAU,EAC/BmC,GAAO,MAAuB,IAATnC,IAErBmC,GAAO,MAAc,IACrBoB,GAAWoB,UAAU,GAAU3E,GAC/B,IAAY,GAEb,IAAK,IAAIc,EAAI,EAAGA,EAAId,EAAQc,IAC3Bk3B,EAAK/yB,EAAMnE,GACZ,EAEKk3B,EAAQ/yB,IACT,GAAW6xB,KACd30B,GAAS42B,EAAS,KAEnB,IACI/4B,EADArB,SAAcsG,EAElB,GAAa,WAATtG,EAAmB,CACtB,IAkCI86B,EAlCA71B,EAAYqB,EAAMjF,OACtB,GAAI,IAAkB4D,GAAa,GAAKA,EAAY,KAAQ,CAC3D,IAAK,GAAe6B,MAAQ7B,GAzNT,MAyNuC,CACzD,IAAI81B,EAIAjB,EAHAkB,GAAY,GAAe,GAAgC,EAA3B,GAAe,GAAG35B,OAAa,GAAe,GAAGA,OAAS,GAAK,GAC/F,GAAW25B,EAAW7C,KACzB30B,GAAS42B,EAAS,GAAWY,IAE1B,GAAez2B,UAClBu1B,EAAa,GACbt2B,GAAO,IAAY,IACnB,IAAY,EACZA,GAAO,MAAc,GACrBu3B,EAAW,GAAW30B,EACtB,IAAY,EACZ2zB,GAAa3zB,EAAOizB,EAAM,GAC1Bz0B,GAAWq2B,UAAUF,EAAW30B,EAAQ,EAAG,GAAWA,EAAQ20B,KAE9Dv3B,GAAO,MAAc,IACrBA,GAAO,MAAc,GACrBu3B,EAAW,GAAW30B,EACtB,IAAY,GAEb,GAAiB,CAAC,GAAI,IACtB,GAAe8B,SAAW4xB,EAC1B,GAAehzB,KAAO,EACtB,GAAevC,SAAWw2B,CAC3B,CACA,IAAIG,EAAU7C,GAAYn3B,KAAKoF,GAI/B,OAHA,GAAe40B,EAAU,EAAI,IAAM50B,EACnC9C,GAAO,MAAc,SACrB61B,EAAK6B,GAAWj2B,EAAYA,EAE7B,CAIC61B,EADG71B,EAAY,GACF,EACHA,EAAY,IACT,EACHA,EAAY,MACT,EAEA,EAEd,IAAI+1B,EAAuB,EAAZ/1B,EAIf,GAHI,GAAW+1B,EAAW7C,KACzB30B,GAAS42B,EAAS,GAAWY,IAE1B/1B,EAAY,KAASuzB,EAAY,CACpC,IAAIr2B,EAAG+C,EAAIE,EAAI+1B,EAAc,GAAWL,EACxC,IAAK34B,EAAI,EAAGA,EAAI8C,EAAW9C,IAC1B+C,EAAKoB,EAAMnB,WAAWhD,GAClB+C,EAAK,IACR1B,GAAO23B,KAAiBj2B,EACdA,EAAK,MACf1B,GAAO23B,KAAiBj2B,GAAM,EAAI,IAClC1B,GAAO23B,KAAsB,GAALj2B,EAAY,KAElB,QAAZ,MAALA,IAC6C,QAAZ,OAAhCE,EAAKkB,EAAMnB,WAAWhD,EAAI,MAE5B+C,EAAK,QAAiB,KAALA,IAAgB,KAAY,KAALE,GACxCjD,IACAqB,GAAO23B,KAAiBj2B,GAAM,GAAK,IACnC1B,GAAO23B,KAAiBj2B,GAAM,GAAK,GAAO,IAC1C1B,GAAO23B,KAAiBj2B,GAAM,EAAI,GAAO,IACzC1B,GAAO23B,KAAsB,GAALj2B,EAAY,MAEpC1B,GAAO23B,KAAiBj2B,GAAM,GAAK,IACnC1B,GAAO23B,KAAiBj2B,GAAM,EAAI,GAAO,IACzC1B,GAAO23B,KAAsB,GAALj2B,EAAY,KAGtC7D,EAAS85B,EAAc,GAAWL,CACnC,MACCz5B,EAASm3B,EAAWlyB,EAAO,GAAWw0B,GAGnCz5B,EAAS,GACZmC,GAAO,MAAc,IAAOnC,EAClBA,EAAS,KACfy5B,EAAa,GAChBt3B,GAAOg3B,WAAW,GAAW,EAAG,GAAW,EAAG,GAAW,EAAIn5B,GAE9DmC,GAAO,MAAc,IACrBA,GAAO,MAAcnC,GACXA,EAAS,OACfy5B,EAAa,GAChBt3B,GAAOg3B,WAAW,GAAW,EAAG,GAAW,EAAG,GAAW,EAAIn5B,GAE9DmC,GAAO,MAAc,IACrBA,GAAO,MAAcnC,GAAU,EAC/BmC,GAAO,MAAuB,IAATnC,IAEjBy5B,EAAa,GAChBt3B,GAAOg3B,WAAW,GAAW,EAAG,GAAW,EAAG,GAAW,EAAIn5B,GAE9DmC,GAAO,MAAc,IACrBoB,GAAWoB,UAAU,GAAU3E,GAC/B,IAAY,GAEb,IAAYA,CACb,MAAO,GAAa,WAATrB,EACV,GAAIsG,IAAU,IAAMA,EAEfA,EAAQ,IAASA,EAAQ,MAA4B,IAApB6I,KAAK+gB,YAA0B5pB,EAAQ,KAAS6I,KAAK+iB,sBACzF1uB,GAAO,MAAc8C,EACXA,EAAQ,KAClB9C,GAAO,MAAc,IACrBA,GAAO,MAAc8C,GACXA,EAAQ,OAClB9C,GAAO,MAAc,IACrBA,GAAO,MAAc8C,GAAS,EAC9B9C,GAAO,MAAsB,IAAR8C,IAErB9C,GAAO,MAAc,IACrBoB,GAAWoB,UAAU,GAAUM,GAC/B,IAAY,QAEP,GAAIA,GAAS,IAAMA,EACrBA,IAAU,GACb9C,GAAO,MAAc,IAAQ8C,EACnBA,IAAU,KACpB9C,GAAO,MAAc,IACrBA,GAAO,MAAc8C,EAAQ,KACnBA,IAAU,OACpB9C,GAAO,MAAc,IACrBoB,GAAWw2B,SAAS,GAAU90B,GAC9B,IAAY,IAEZ9C,GAAO,MAAc,IACrBoB,GAAWgB,SAAS,GAAUU,GAC9B,IAAY,OAEP,CACN,IAAImtB,EACJ,IAAKA,EAAatkB,KAAKskB,YAAc,GAAKntB,EAAQ,YAAeA,IAAU,WAAY,CAGtF,IAAI+0B,EACJ,GAHA73B,GAAO,MAAc,IACrBoB,GAAW02B,WAAW,GAAUh1B,GAE5BmtB,EAAa,IAEb4H,EAAW/0B,EAAQqtB,IAA4B,IAAnBnwB,GAAO,MAAqB,EAAMA,GAAO,GAAW,IAAM,KAAQ,IAAO63B,EAExG,YADA,IAAY,GAGZ,IACF,CACA73B,GAAO,MAAc,IACrBoB,GAAWwN,WAAW,GAAU9L,GAChC,IAAY,CACb,MACM,GAAa,WAATtG,GAA8B,aAATA,EAC/B,GAAKsG,EAEA,CACJ,GAAIqpB,EAAc,CACjB,IAAI4L,EAAU5L,EAAa1lB,IAAI3D,GAC/B,GAAIi1B,EAAS,CACZ,IAAKA,EAAQhnB,GAAI,CAChB,IAAIylB,EAAcrK,EAAaqK,cAAgBrK,EAAaqK,YAAc,IAC1EuB,EAAQhnB,GAAKylB,EAAY/yB,KAAKs0B,EAC/B,CAKA,OAJA/3B,GAAO,MAAc,IACrBA,GAAO,MAAc,IACrBoB,GAAWoB,UAAU,GAAUu1B,EAAQhnB,SACvC,IAAY,EAEb,CACCob,EAAa5pB,IAAIO,EAAO,CAAEsP,OAAQ,GAAWxP,GAC/C,CACA,IAAI6I,EAAc3I,EAAM2I,YACxB,GAAIA,IAAgBnF,OACnB0xB,EAAYl1B,GAAO,QACb,GAAI2I,IAAgB5R,MAC1Bw9B,EAAUv0B,QACJ,GAAI2I,IAAgB4N,IAC1B,GAAI1N,KAAKssB,iBAAkBj4B,GAAO,MAAc,QAC3C,EACJnC,EAASiF,EAAMQ,MACF,GACZtD,GAAO,MAAc,IAAOnC,EAClBA,EAAS,OACnBmC,GAAO,MAAc,IACrBA,GAAO,MAAcnC,GAAU,EAC/BmC,GAAO,MAAuB,IAATnC,IAErBmC,GAAO,MAAc,IACrBoB,GAAWoB,UAAU,GAAU3E,GAC/B,IAAY,GAEb,IAAK,IAAKqD,EAAKg3B,KAAep1B,EAC7B+yB,EAAK30B,GACL20B,EAAKqC,EAEP,KACM,CACN,IAAK,IAAIv5B,EAAI,EAAG0D,EAAIgyB,GAAWx2B,OAAQc,EAAI0D,EAAG1D,IAE7C,GAAImE,aADiBwxB,GAAiB31B,GACD,CACpC,IAAIgf,EAAY0W,GAAW11B,GAC3B,GAAIgf,EAAUrV,MAAO,CAChBqV,EAAUnhB,OACbwD,GAAO,MAAc,IACrBA,GAAO,MAAc2d,EAAUnhB,KAC/BwD,GAAO,MAAc,GAEtB,IAAIm4B,EAAcxa,EAAUrV,MAAMrF,KAAK0I,KAAM7I,GAU7C,YATIq1B,IAAgBr1B,EACfjJ,MAAMC,QAAQgJ,GACjBu0B,EAAUv0B,GAEVk1B,EAAYl1B,GAGb+yB,EAAKsC,GAGP,CACA,IAIIh0B,EAJAi0B,EAAgBp4B,GAChBq4B,EAAoBj3B,GACpBk3B,EAAkB,GACtBt4B,GAAS,KAET,IACCmE,EAASwZ,EAAUkY,KAAK5yB,KAAK0I,KAAM7I,GAAQQ,IAE1CtD,GAASo4B,EACTA,EAAgB,KAChB,IAAY90B,EACR,GAAWqxB,IACdiC,EAAS,IACH,CACN52B,UAAQoB,cAAYL,SAAU,GAAWuC,KAExCuyB,EACJ,CAAE,QAEGuC,IACHp4B,GAASo4B,EACTh3B,GAAai3B,EACb,GAAWC,EACX3D,GAAU30B,GAAOnC,OAAS,GAE5B,CAMA,YALIsG,IACCA,EAAOtG,OAAS,GAAW82B,IAC9BiC,EAASzyB,EAAOtG,OAAS,IAC1B,GAAW06B,GAAmBp0B,EAAQnE,GAAQ,GAAU2d,EAAUnhB,OAGpE,CAGD,GAAI3C,MAAMC,QAAQgJ,GACjBu0B,EAAUv0B,OACJ,CAEN,GAAIA,EAAM4K,OAAQ,CACjB,MAAM8qB,EAAO11B,EAAM4K,SAEnB,GAAI8qB,IAAS11B,EACZ,OAAO+yB,EAAK2C,EACd,CAGA,GAAa,aAATh8B,EACH,OAAOq5B,EAAKlqB,KAAK8sB,eAAiB9sB,KAAK8sB,cAAc31B,IAGtDk1B,EAAYl1B,GAAQA,EAAM8D,eAC3B,CACD,CACD,MAvHC5G,GAAO,MAAc,SAwHhB,GAAa,YAATxD,EACVwD,GAAO,MAAc8C,EAAQ,IAAO,SAC9B,GAAa,WAATtG,EAAmB,CAC7B,GAAIsG,EAASutB,OAAO,IAAIA,OAAO,KAAQvtB,KAAWutB,OAAO,IAAIA,OAAO,KAEnErwB,GAAO,MAAc,IACrBoB,GAAWs3B,YAAY,GAAU51B,QAC3B,GAAIA,EAASutB,OAAO,IAAIA,OAAO,KAAQvtB,EAAQ,EAErD9C,GAAO,MAAc,IACrBoB,GAAWu3B,aAAa,GAAU71B,OAC5B,CAEN,IAAI6I,KAAKitB,mBAIR,MAAM,IAAI32B,WAAWa,EAAQ,6GAH7B9C,GAAO,MAAc,IACrBoB,GAAWwN,WAAW,GAAUnM,OAAOK,GAIzC,CACA,IAAY,CACb,KAAO,IAAa,cAATtG,EASV,MAAM,IAAI0D,MAAM,iBAAmB1D,GAR/BmP,KAAKktB,qBACR74B,GAAO,MAAc,KAErBA,GAAO,MAAc,IACrBA,GAAO,MAAc,EACrBA,GAAO,MAAc,EAIvB,GAGK84B,EAAoBntB,KAAKotB,iBAAmBptB,KAAKqtB,qBAAyB3J,IAE/E,IAaInuB,EAbA6V,EAAOzQ,OAAOyQ,KAAKsY,GACnBxxB,EAASkZ,EAAKlZ,OAalB,GAZIA,EAAS,GACZmC,GAAO,MAAc,IAAOnC,EAClBA,EAAS,OACnBmC,GAAO,MAAc,IACrBA,GAAO,MAAcnC,GAAU,EAC/BmC,GAAO,MAAuB,IAATnC,IAErBmC,GAAO,MAAc,IACrBoB,GAAWoB,UAAU,GAAU3E,GAC/B,IAAY,GAGT8N,KAAKqtB,qBACR,IAAK,IAAIr6B,EAAI,EAAGA,EAAId,EAAQc,IAAK,CAChCuC,EAAM6V,EAAKpY,GACX,IAAIs6B,EAAMx2B,OAAOvB,GACjB20B,EAAKqD,MAAMD,GAAO/3B,EAAM+3B,GACxBpD,EAAKxG,EAAOnuB,GACb,MAGA,IAAK,IAAIvC,EAAI,EAAGA,EAAId,EAAQc,IAC3Bk3B,EAAK30B,EAAM6V,EAAKpY,IAChBk3B,EAAKxG,EAAOnuB,GAEd,EAED,CAACmuB,EAAQ8J,KACRn5B,GAAO,MAAc,IACrB,IAAIo5B,EAAe,GAAWx2B,EAC9B,IAAY,EACZ,IAAIU,EAAO,EACX,IAAK,IAAIpC,KAAOmuB,GACX8J,GAAiB9J,EAAOzoB,eAAe1F,MAC1C20B,EAAK30B,GACL20B,EAAKxG,EAAOnuB,IACZoC,KAGFtD,GAAOo5B,IAAiBx2B,GAASU,GAAQ,EACzCtD,GAAOo5B,EAAex2B,GAAgB,IAAPU,CAAO,EAGjC+1B,GAAkC,IAApB1tB,KAAK+gB,WAAuBoM,EAC/C9nB,EAAQsoB,qBAAuB/D,EAChC,CAAClG,EAAQ8J,KACR,IAAIlD,EAEAsD,EAFgBrD,EAAa/S,EAAW6S,cAAgB7S,EAAW6S,YAAc1vB,OAAO6a,OAAO,OAC/FiY,EAAe,KAAax2B,EAEhC,IAAK,IAAI1B,KAAOmuB,EACf,GAAI8J,GAAiB9J,EAAOzoB,eAAe1F,GAAM,CAEhD,GADA+0B,EAAiBC,EAAWh1B,GACxB+0B,EACHC,EAAaD,MACT,CAEJ,IAAIlf,EAAOzQ,OAAOyQ,KAAKsY,GACnBmK,EAAiBtD,EACrBA,EAAa/S,EAAW6S,YACxB,IAAIyD,EAAiB,EACrB,IAAK,IAAI96B,EAAI,EAAG0D,EAAI0U,EAAKlZ,OAAQc,EAAI0D,EAAG1D,IAAK,CAC5C,IAAIuC,EAAM6V,EAAKpY,GACfs3B,EAAiBC,EAAWh1B,GACvB+0B,IACJA,EAAiBC,EAAWh1B,GAAOoF,OAAO6a,OAAO,MACjDsY,KAEDvD,EAAaD,CACd,CACImD,EAAex2B,EAAQ,GAAK,IAE/B,KACA82B,EAAUxD,EAAYnf,EAAM0iB,IAE5BE,EAAgBzD,EAAYnf,EAAMqiB,EAAcK,GACjDF,GAAY,EACZrD,EAAasD,EAAet4B,EAC7B,CACA20B,EAAKxG,EAAOnuB,GACb,CAED,IAAKq4B,EAAW,CACf,IAAIK,EAAW1D,EAAWpB,IACtB8E,EACH55B,GAAOo5B,EAAex2B,GAASg3B,EAE/BD,EAAgBzD,EAAY5vB,OAAOyQ,KAAKsY,GAAS+J,EAAc,EACjE,GAED,CAAC/J,EAAQ8J,KACR,IAAIlD,EAAgBC,EAAa/S,EAAW6S,cAAgB7S,EAAW6S,YAAc1vB,OAAO6a,OAAO,OAC/FsY,EAAiB,EACrB,IAAK,IAAIv4B,KAAOmuB,GAAY8J,GAAiB9J,EAAOzoB,eAAe1F,MAClE+0B,EAAiBC,EAAWh1B,GACvB+0B,IACJA,EAAiBC,EAAWh1B,GAAOoF,OAAO6a,OAAO,MACjDsY,KAEDvD,EAAaD,GAEd,IAAI2D,EAAW1D,EAAWpB,IACtB8E,EACCA,GAAY,IAAQrE,GACvBv1B,GAAO,MAA4C,IAAR,IAApB45B,GAAY,KACnC55B,GAAO,MAAc45B,GAAY,GAEjC55B,GAAO,MAAc45B,EAEtBF,EAAUxD,EAAYA,EAAW2D,UAAYvzB,OAAOyQ,KAAKsY,GAASoK,GAGnE,IAAK,IAAIv4B,KAAOmuB,GACX8J,GAAiB9J,EAAOzoB,eAAe1F,KAC1C20B,EAAKxG,EAAOnuB,GAAI,EAIb44B,EAA4C,mBAAnBnuB,KAAK+gB,YAA4B/gB,KAAK+gB,WAE/DsL,EAAc8B,EAAkB,CAACzK,EAAQ8J,KAC9CW,EAAgBzK,GAAUgK,EAAYhK,EAAO8J,GAAiBL,EAAiBzJ,EAAO8J,EAAa,EAChGE,EAEEzC,EAAY/zB,IACjB,IAAIk3B,EACJ,GAAIl3B,EAAM,SAAW,CAEpB,GAAKA,EAAMD,EAAS6xB,GACnB,MAAM,IAAIv0B,MAAM,0DACjB65B,EAAUxmB,KAAKC,IAAIihB,GACsE,KAAxFlhB,KAAKsT,MAAMtT,KAAKE,KAAK5Q,EAAMD,IAAUC,EAAM,SAAY,KAAO,GAAI,SAAY,MAChF,MACCk3B,EAAqE,GAAzDxmB,KAAKE,IAAK5Q,EAAMD,GAAU,EAAG5C,GAAOnC,OAAS,IAAM,KAAY,GAC5E,IAAIqG,EAAY,IAAIH,GAAkBg2B,GAUtC,OATA34B,GAAa8C,EAAU7C,WAAa6C,EAAU7C,SAAW,IAAIC,SAAS4C,EAAUtD,OAAQ,EAAGm5B,IAC3Fl3B,EAAM0Q,KAAKC,IAAI3Q,EAAK7C,GAAOnC,QACvBmC,GAAO2iB,KACV3iB,GAAO2iB,KAAKze,EAAW,EAAGtB,EAAOC,GAEjCqB,EAAU3B,IAAIvC,GAAOlB,MAAM8D,EAAOC,IACnC,IAAYD,EACZA,EAAQ,EACR+xB,GAAUzwB,EAAUrG,OAAS,GACtBmC,GAASkE,GAEXw1B,EAAY,CAACxD,EAAYnf,EAAM0iB,KACpC,IAAIG,EAAWzW,EAAWiT,OACrBwD,IACJA,EAAW,IACRA,EAAWpE,GAAiB7pB,KAAKquB,uBAAyBruB,KAAKquB,qBAAqBjjB,IACvF6iB,EAAWzW,EAAW8W,UAChBL,EAAWnE,IAChBmE,EAAWpE,GACZrS,EAAW8W,UAAYL,EAAW,IAE9BA,GAAYnE,IACfmE,EAAWpE,GACZrS,EAAWiT,OAASwD,EAAW,GAEhC,IAAIrL,EAAWxX,EAAKwX,SAAWqL,GAAY,IAAQrE,EAAqBqE,EAAW,IAAS,GAAK,EACjG1D,EAAWpB,IAAiB8E,EAC5B1D,EAAW2D,SAAW9iB,EACtBoM,EAAWyW,EAAW,IAAQ7iB,EAE1B6iB,EAAWpE,GACdze,EAAKuX,UAAW,EAChBnL,EAAWqK,aAAeoM,EAAW,GACrC7E,GAAkB,EACdxG,GAAY,GACfvuB,GAAO,MAAkC,IAAR,GAAX45B,GACtB55B,GAAO,MAAcuuB,GAErBvuB,GAAO,MAAc45B,IAGlBrL,GAAY,GACfvuB,GAAO,MAAc,IACrBA,GAAO,MAAc,IACrBA,GAAO,MAAkC,IAAR,GAAX45B,GACtB55B,GAAO,MAAcuuB,IAErBvuB,GAAO,MAAc,IACrBA,GAAO,MAAc,IACrBA,GAAO,MAAc45B,GAGlBH,IACH9D,GAAoBC,EAAuC6D,GAExD/D,EAAkB73B,QAAUy3B,IAC/BI,EAAkBwE,QAAQpF,IAAiB,GAC5CY,EAAkBjyB,KAAKyyB,GACvBL,EAAK9e,GACN,EAEK4iB,EAAkB,CAACzD,EAAYnf,EAAMojB,EAAiBV,KAC3D,IAAIW,EAAap6B,GACbq6B,EAAe,GACfC,EAAc3F,GACd4F,EAAY33B,EAChB5C,GAAS00B,GACT,GAAW,EACX9xB,EAAQ,EACH5C,KACJ00B,GAAa10B,GAAS,IAAI+D,GAAkB,OAC7C4wB,GAAU30B,GAAOnC,OAAS,GAC1B67B,EAAUxD,EAAYnf,EAAM0iB,GAC5B/E,GAAa10B,GACb,IAAIw6B,EAAe,GAKnB,GAJAx6B,GAASo6B,EACT,GAAWC,EACX1F,GAAU2F,EACV13B,EAAQ23B,EACJC,EAAe,EAAG,CACrB,IAAIC,EAAS,GAAWD,EAAe,EACnCC,EAAS9F,IACZiC,EAAS6D,GACV,IAAIC,EAAoBP,EAAkBv3B,EAC1C5C,GAAOg3B,WAAW0D,EAAoBF,EAAcE,EAAoB,EAAG,IAC3E16B,GAAOuC,IAAImyB,GAAW51B,MAAM,EAAG07B,GAAeE,GAC9C,GAAWD,CACZ,MACCz6B,GAAOm6B,EAAkBv3B,GAAS8xB,GAAW,EAC9C,EAEK2B,EAAc,CAAChH,EAAQ8J,KAC5B,IAAIwB,EAAc/F,GAAiBvF,EAAQrvB,GAAQ,GAAUmjB,EAAYyT,GAAU,CAAC9zB,EAAO63B,EAAaC,KACvG,GAAIA,EACH,OAAO7F,GAAkB,EAC1B,GAAW4F,EACX,IAAIE,EAAc76B,GAElB,OADA61B,EAAK/yB,GACD+3B,IAAgB76B,GACZ,CAAEe,SAAQ,4BAEX,EAAQ,GACb4K,MACH,GAAoB,IAAhBgvB,EACH,OAAO3C,EAAY3I,GAAQ,GAC5B,GAAWsL,CAAW,CAExB,CACAG,UAAUl6B,GAETZ,GAASY,EACTQ,GAAa,IAAIE,SAAStB,GAAOY,OAAQZ,GAAOuB,WAAYvB,GAAOwB,YACnE,GAAW,CACZ,CACA0hB,kBACKvX,KAAKwX,aACRxX,KAAKwX,WAAa,IACfxX,KAAKovB,eACRpvB,KAAKovB,aAAe,GACtB,EAuGD,SAASC,GAAeC,EAAYz+B,EAAM0+B,EAAkB3mB,GAC3D,IAAI1W,EAASo9B,EAAWz5B,WACxB,GAAI3D,EAAS,EAAI,IAAO,CACvB,IAAI,OAAEmC,EAAM,SAAEe,GAAam6B,EAAiB,EAAIr9B,GAChDmC,EAAOe,KAAc,IACrBf,EAAOe,KAAclD,EAAS,CAC/B,MAAO,GAAIA,EAAS,EAAI,MAAS,CAChC,IAAI,OAAEmC,EAAM,SAAEe,GAAam6B,EAAiB,EAAIr9B,GAChDmC,EAAOe,KAAc,IACrBf,EAAOe,KAAelD,EAAS,GAAM,EACrCmC,EAAOe,KAAelD,EAAS,EAAK,GACrC,KAAO,CACN,IAAI,OAAEmC,EAAM,SAAEe,EAAQ,WAAEK,GAAe85B,EAAiB,EAAIr9B,GAC5DmC,EAAOe,KAAc,IACrBK,EAAWoB,UAAUzB,EAAUlD,EAAS,GACxCkD,GAAY,CACb,CACAf,EAAOe,KAAc,IACrBf,EAAOe,KAAcvE,EACrBwD,EAAOuC,IAAI,IAAID,WAAW24B,EAAWr6B,OAAQq6B,EAAW15B,WAAY05B,EAAWz5B,YAAaT,EAC7F,CACA,SAASo6B,GAAYv6B,EAAQs6B,GAC5B,IAAIr9B,EAAS+C,EAAOY,WACpB,IAAIxB,EAAQe,EACZ,GAAIlD,EAAS,IAAO,CACnB,IAAI,OAAEmC,EAAM,SAAEe,GAAam6B,EAAiBr9B,EAAS,GACrDmC,EAAOe,KAAc,IACrBf,EAAOe,KAAclD,CACtB,MAAO,GAAIA,EAAS,MAAS,CAC5B,IAAI,OAAEmC,EAAM,SAAEe,GAAam6B,EAAiBr9B,EAAS,GACrDmC,EAAOe,KAAc,IACrBf,EAAOe,KAAclD,GAAU,EAC/BmC,EAAOe,KAAuB,IAATlD,CACtB,KAAO,CACN,IAAI,OAAEmC,EAAM,SAAEe,EAAQ,WAAEK,GAAe85B,EAAiBr9B,EAAS,GACjEmC,EAAOe,KAAc,IACrBK,EAAWoB,UAAUzB,EAAUlD,GAC/BkD,GAAY,CACb,CACAf,EAAOuC,IAAI3B,EAAQG,EACpB,CAEA,SAASw3B,GAAmBp0B,EAAQnE,EAAQe,EAAUvE,GACrD,IAAIqB,EAASsG,EAAOtG,OACpB,OAAQA,GACP,KAAK,EACJmC,EAAOe,KAAc,IACrB,MACD,KAAK,EACJf,EAAOe,KAAc,IACrB,MACD,KAAK,EACJf,EAAOe,KAAc,IACrB,MACD,KAAK,EACJf,EAAOe,KAAc,IACrB,MACD,KAAK,GACJf,EAAOe,KAAc,IACrB,MACD,QACKlD,EAAS,KACZmC,EAAOe,KAAc,IACrBf,EAAOe,KAAclD,GACXA,EAAS,OACnBmC,EAAOe,KAAc,IACrBf,EAAOe,KAAclD,GAAU,EAC/BmC,EAAOe,KAAuB,IAATlD,IAErBmC,EAAOe,KAAc,IACrBf,EAAOe,KAAclD,GAAU,GAC/BmC,EAAOe,KAAelD,GAAU,GAAM,IACtCmC,EAAOe,KAAelD,GAAU,EAAK,IACrCmC,EAAOe,KAAuB,IAATlD,GAMxB,OAHAmC,EAAOe,KAAcvE,EACrBwD,EAAOuC,IAAI4B,EAAQpD,GACnBA,EAAYlD,CAEb,CAwBA,SAAS04B,GAAa3zB,EAAOizB,EAAMY,GAClC,GAAI,GAAe54B,OAAS,EAAG,CAC9BuD,GAAWoB,UAAU,GAAezB,SAAW6B,EAAO,GAAW6zB,EAAoB,GAAe11B,SAAW6B,GAC/G,GAAe+zB,gBAAkB,GAAW/zB,EAC5C,IAAIw4B,EAAe,GACnB,GAAiB,KACjBvF,EAAKuF,EAAa,IAClBvF,EAAKuF,EAAa,GACnB,CACD,CAaA,SAAShE,GAAkBjU,EAAY8R,GAOtC,OANA9R,EAAWG,aAAgBE,IAC1B,IAAI6X,GAAc7X,IAAwByR,EAAMkB,2BAA6B,KAAO3S,EAAmB3lB,OAGvG,OAFKw9B,GACJpG,EAAM/G,iBAAiB1K,GACjB6X,CAAU,EAEXlY,CACR,CApOAmR,GAAmB,CAAElN,KAAMlL,IAAKhc,MAAOizB,OAAQnoB,YAAa1E,OAAOg1B,eAAeh5B,WAAWU,WAAWyI,YAA4BmhB,IACpIyH,GAAa,CAAC,CACbwB,KAAK0F,EAAML,EAAkBrF,GAC5B,IAAI2F,EAAUD,EAAKE,UAAY,IAC/B,IAAK9vB,KAAK+vB,gBAA6C,IAA3BH,EAAKI,oBAA4BH,GAAW,GAAKA,EAAU,WAAa,CAEnG,IAAI,OAAEx7B,EAAM,WAAEoB,EAAU,SAAEL,GAAYm6B,EAAiB,GACvDl7B,EAAOe,KAAc,IACrBf,EAAOe,KAAc,IACrBK,EAAWoB,UAAUzB,EAAUy6B,EAChC,MAAO,GAAIA,EAAU,GAAKA,EAAU,WAAa,CAEhD,IAAI,OAAEx7B,EAAM,WAAEoB,EAAU,SAAEL,GAAYm6B,EAAiB,IACvDl7B,EAAOe,KAAc,IACrBf,EAAOe,KAAc,IACrBK,EAAWoB,UAAUzB,EAAmC,IAAzBw6B,EAAKI,mBAAgCH,EAAU,IAAO,YAAgB,IACrGp6B,EAAWoB,UAAUzB,EAAW,EAAGy6B,EACpC,MAAO,GAAItC,MAAMsC,GAAU,CAC1B,GAAI7vB,KAAKiwB,cAER,OADAV,EAAiB,GACVrF,EAAKlqB,KAAKiwB,iBAGlB,IAAI,OAAE57B,EAAM,WAAEoB,EAAU,SAAEL,GAAYm6B,EAAiB,GACvDl7B,EAAOe,KAAc,IACrBf,EAAOe,KAAc,IACrBf,EAAOe,KAAc,GACtB,KAAO,CAEN,IAAI,OAAEf,EAAM,WAAEoB,EAAU,SAAEL,GAAYm6B,EAAiB,IACvDl7B,EAAOe,KAAc,IACrBf,EAAOe,KAAc,GACrBf,EAAOe,KAAc,IACrBK,EAAWoB,UAAUzB,EAAmC,IAAzBw6B,EAAKI,mBACpCv6B,EAAWs3B,YAAY33B,EAAW,EAAGsvB,OAAO9c,KAAKkK,MAAM+d,IACxD,CACD,GACE,CACF3F,KAAKtzB,EAAK24B,EAAkBrF,GAC3B,GAAIlqB,KAAKkwB,iBAER,OADAX,EAAiB,GACVrF,EAAK,CAAC,GAEd,IAAI/nB,EAAQjU,MAAMsR,KAAK5I,IACnB,OAAEvC,EAAM,SAAEe,GAAYm6B,EAAiBvvB,KAAK0pB,UAAY,EAAI,GAC5D1pB,KAAK0pB,YACRr1B,EAAOe,KAAc,IACrBf,EAAOe,KAAc,IACrBf,EAAOe,KAAc,GAEtB80B,EAAK/nB,EACN,GACE,CACF+nB,KAAK91B,EAAOm7B,EAAkBrF,GAC7B,IAAI,OAAE71B,EAAM,SAAEe,GAAYm6B,EAAiBvvB,KAAK0pB,UAAY,EAAI,GAC5D1pB,KAAK0pB,YACRr1B,EAAOe,KAAc,IACrBf,EAAOe,KAAc,IACrBf,EAAOe,KAAc,GAEtB80B,EAAK,CAAE91B,EAAMtC,KAAMsC,EAAM6Y,SAC1B,GACE,CACFid,KAAKiG,EAAOZ,EAAkBrF,GAC7B,IAAI,OAAE71B,EAAM,SAAEe,GAAYm6B,EAAiBvvB,KAAK0pB,UAAY,EAAI,GAC5D1pB,KAAK0pB,YACRr1B,EAAOe,KAAc,IACrBf,EAAOe,KAAc,IACrBf,EAAOe,KAAc,GAEtB80B,EAAK,CAAEiG,EAAMrvB,OAAQqvB,EAAMzsB,OAC5B,GACE,CACFwmB,KAAKkG,EAAab,GACbvvB,KAAK0pB,UACR2F,GAAee,EAAa,GAAMb,GAElCC,GAAYt3B,GAAgBC,OAAOqH,KAAK4wB,GAAe,IAAIz5B,WAAWy5B,GAAcb,EACtF,GACE,CACFrF,KAAKoF,EAAYC,GAChB,IAAIzvB,EAAcwvB,EAAWxvB,YACzBA,IAAgB,IAAaE,KAAK0pB,UACrC2F,GAAeC,EAAYlI,GAAYvQ,QAAQ/W,EAAYhO,MAAOy9B,GAElEC,GAAYF,EAAYC,EAC1B,GACE,CACFrF,KAAKn0B,EAAIw5B,GACR,IAAI,OAAEl7B,EAAM,SAAEe,GAAYm6B,EAAiB,GAC3Cl7B,EAAOe,GAAY,GACpB,IA+ID,IAAIi7B,GAAe,IAAI,GAAM,CAAEtP,YAAY,IACvBsP,GAAanG,KACXmG,GAAanG,KAD5B,MAEM/U,GAAU,IAGV,MAAEmb,GAAK,OAAEC,GAAM,cAAEC,GAAa,YAAEC,IDwFd,CAC9BH,MAAO,EACPC,OAAQ,EACRC,cAAe,EACfC,YAAa,GC3FD,GAAoB,IACpB,GAAoB,KC7+B3BC,GAAa,CAAC,MAAO,SAAU,SAAU,SAC/CA,GAFa,IAEM,OACnB,MAAMC,GAAiB,EAAC,GAAO,GAAM,GAAM,GAAO,GAAO,GAAM,GAAM,GACrE,IAAIC,GAQAC,GAPJ,IACC,IAAIrP,SAAS,IACboP,IAAgB,CACjB,CAAE,MAAMx8B,GAER,CAGA,MAAM,GAAkC,oBAAX+D,OAC7B,IAAI,GAAa24B,GACjB,IACC,GAAc,IAAIz7B,WACnB,CAAE,MAAOjB,GAAQ,CACjB,MAAMi1B,GAAa,GAAgB,SAASh1B,EAAQ2F,EAAQ5E,GAC3D,OAAOf,EAAO6B,UAAU8D,EAAQ5E,EAAU,WAC3C,KAAK,KAAe,GAAYe,aAC/B,SAAS9B,EAAQ2F,EAAQ5E,GACxB,OAAO,GAAYe,WAAW6D,EAAQ3F,EAAO+B,SAAShB,IAAWiB,OAClE,ED08BM,IAA6B06B,GCnnBpC,SAASC,GAAQzG,EAAYn1B,EAAUK,EAAY0B,GAClD,IAAImzB,EACJ,OAAKA,EAAiBC,EAAW0G,QAAU1G,EAAW2G,OACrDz7B,EAAW07B,QAAQ/7B,EAAU+B,GAAO,GACpC05B,GAAkBz7B,EAAW,EACtBk1B,IAEHA,EAAiBC,EAAW6G,UAAY7G,EAAW8G,WACvD57B,EAAWw2B,SAAS72B,EAAU+B,GAAO,GACrC05B,GAAkBz7B,EAAW,EACtBk1B,IAEJA,EAAiBC,EAAW+G,QAC/B77B,EAAWoB,UAAUzB,EAAU,WAAa+B,GAAO,GACnD05B,GAAkBz7B,EAAW,EACtBk1B,IAGJA,EAAiBC,EAAWgH,QAC/B97B,EAAWwN,WAAW7N,EAAUo8B,KAAK,GACrC/7B,EAAW07B,QAAQ/7B,EAAU+B,GAC7B05B,GAAkBz7B,EAAW,EACtBk1B,QAERuG,GAAkBz7B,EAGnB,CACA,SAASq8B,GAAqBlH,EAAY15B,EAAM8G,GAC/C,IAAI+5B,EAAWhB,GAAW7/B,IAAS8G,GAAQ,GACvCg6B,EAAgBpH,EAAWmH,KAAcnH,EAAWmH,GAAY/2B,OAAO6a,OAAO,OAIlF,OAHAmc,EAAcC,OAAS/gC,EACvB8gC,EAAcE,OAASl6B,EACvBg6B,EAAcG,SAAWvH,EAClBoH,CACR,CAxXap6B,OAAO,QACLA,OAAO,UDu8Bcw5B,GCr8BpC,SAASrG,EAAYhH,EAAQrvB,EAAQe,EAAUoiB,EAAYyT,EAAUf,EAAMZ,GAC1E,IAAI8F,EAAe9F,EAAM8F,eAAiB9F,EAAM8F,aAAe,IAE3D35B,EAAapB,EAAOqB,SACpBq8B,GAAqB3C,EAAa4C,iBAAmB,KAAO58B,EAC5D4zB,EAAU30B,EAAOnC,OAAS,GAC1B+E,EAAQ7B,EACZ,GAAIA,EAAW4zB,EAAS,CACvB,IAAIiJ,EAAYh7B,EAEhBxB,GADApB,EAAS42B,EAAS71B,IACEM,SACpBN,GAAY68B,EACZF,GAAqBE,EACrBh7B,EAAQ,EACR+xB,EAAU30B,EAAOnC,OAAS,EAC3B,CAEA,IAAIggC,EAAWC,EAAcJ,EAEzBxH,EAAa6E,EAAa/E,cAAgB+E,EAAa/E,YAAc1vB,OAAO6a,OAAO,OACnFiV,EAAS2E,EAAa3E,QAAU2E,EAAal9B,OAC7Cy5B,EACHlB,EAAS,GAAM,EACdA,EAAS,IAAO,EACfA,EAAS,MAAS,EACjBA,EAAS,SAAW,EAAI,EAC5B,GAAmB,IAAfkB,EACH,OAAO,EACRv2B,GAAYu2B,EACZ,IACIyG,EADAC,EAAmB,GAEnBC,EAAW,EACf,IAAK,IAAI/8B,KAAOmuB,EAAQ,CACvB,IAAIvsB,EAAQusB,EAAOnuB,GACf+0B,EAAiBC,EAAWh1B,GAgBhC,GAfK+0B,IACJC,EAAWh1B,GAAO+0B,EAAiB,CAClC/0B,MACAg9B,OAAQhI,EACRiI,kBAAmB,EACnBC,OAAQ,KACRxB,OAAQ,KACRC,KAAM,KACNE,SAAU,KACVC,SAAU,KACVC,MAAO,KACP9f,QAAS,KACTkhB,OAAQ,OAGNt9B,EAAW4zB,EAAS,CACvB,IAAIiJ,EAAYh7B,EAEhBxB,GADApB,EAAS42B,EAAS71B,IACEM,SACpBN,GAAY68B,EACZF,GAAqBE,EACrBE,GAAeF,EACfh7B,EAAQ,EACR+xB,EAAU30B,EAAOnC,OAAS,EAC3B,CACA,cAAeiF,GACd,IAAK,SACJ,IAAI4C,EAAS5C,EACb,GAAI4C,GAAU,IAAMA,GAAUA,EAAS,WAAcA,GAAU,UAAY,CACtEA,EAAS,KAAQA,GAAU,IAAMuwB,EAAe4G,MAAQn3B,EAAS,KAASuwB,EAAegH,QAC5F/G,EAAaD,EAAe4G,MAAQO,GAAqBnH,EAhGhD,EAgGwE,GACjFj2B,EAAOe,KAAc2E,IAErBwwB,EAAaD,EAAegH,OAASG,GAAqBnH,EAnGjD,EAmGyE,GAClF70B,EAAWoB,UAAUzB,EAAU2E,GAAQ,GACvC3E,GAAY,GAEb,KACD,CAAO,GAAI2E,EAAS,YAAeA,IAAW,aAC7CtE,EAAW02B,WAAW/2B,EAAU2E,GAAQ,GACpC42B,GAAet8B,EAAOe,EAAW,KAAO,IAAI,CAC/C,IAAI82B,EAEJ,IAAMA,EAAWnyB,EAASyqB,IAAgC,IAAvBnwB,EAAOe,EAAW,KAAc,EAAMf,EAAOe,EAAW,IAAM,KAAQ,IAAO82B,EAAU,CACzH3B,EAAaD,EAAegH,OAASG,GAAqBnH,EA9GlD,EA8G0E,GAClFl1B,GAAY,EACZ,KACD,CACD,CAEDm1B,EAAaD,EAAeiH,OAASE,GAAqBnH,EApH/C,EAoHuE,GAClF70B,EAAWwN,WAAW7N,EAAU2E,GAAQ,GACxC3E,GAAY,EACZ,MACD,IAAK,SACJ,IAgBIu9B,EAhBA78B,EAAYqB,EAAMjF,OAEtB,GADAggC,EAAYC,EAAcJ,GACrBj8B,GAAa,GAAKq8B,EAAcnJ,EAAS,CAC7C,IAAIiJ,EAAYh7B,EAEhBxB,GADApB,EAAS42B,GAAUn1B,GAAa,GAAKq8B,IACjBz8B,SACpBN,GAAY68B,EACZF,GAAqBE,EACrBE,GAAeF,EACfh7B,EAAQ,EACR+xB,EAAU30B,EAAOnC,OAAS,EAC3B,CACA,GAAI4D,EAAc,MAASo8B,GAAc,EAAI,CAC5CG,EAAiBv6B,KAAKvC,EAAK4B,EAAO/B,EAAW6B,GAC7C,KACD,CAEA,IAAI27B,EAAWT,EACf,GAAIr8B,EAAY,GAAM,CACrB,IAAI9C,EAAG+C,EAAIE,EACX,IAAKjD,EAAI,EAAGA,EAAI8C,EAAW9C,IAC1B+C,EAAKoB,EAAMnB,WAAWhD,GAClB+C,EAAK,IACR1B,EAAO89B,KAAiBp8B,EACdA,EAAK,MACf48B,GAAa,EACbt+B,EAAO89B,KAAiBp8B,GAAM,EAAI,IAClC1B,EAAO89B,KAAsB,GAALp8B,EAAY,KAElB,QAAZ,MAALA,IAC6C,QAAZ,OAAhCE,EAAKkB,EAAMnB,WAAWhD,EAAI,MAE5B2/B,GAAa,EACb58B,EAAK,QAAiB,KAALA,IAAgB,KAAY,KAALE,GACxCjD,IACAqB,EAAO89B,KAAiBp8B,GAAM,GAAK,IACnC1B,EAAO89B,KAAiBp8B,GAAM,GAAK,GAAO,IAC1C1B,EAAO89B,KAAiBp8B,GAAM,EAAI,GAAO,IACzC1B,EAAO89B,KAAsB,GAALp8B,EAAY,MAEpC48B,GAAa,EACbt+B,EAAO89B,KAAiBp8B,GAAM,GAAK,IACnC1B,EAAO89B,KAAiBp8B,GAAM,EAAI,GAAO,IACzC1B,EAAO89B,KAAsB,GAALp8B,EAAY,IAGvC,MACCo8B,GAAe9I,GAAWh1B,EAAQ8C,EAAOg7B,GACzCQ,EAAaR,EAAcS,EAAW98B,EAEvC,GAAIo8B,EAAY,KAASA,EAAY,MAAS5H,EAAe2G,QAAU3G,EAAeuI,SAAW,CAEhG,GAAIF,GACGpI,EAAaD,EAAeuI,WAC7BzD,EAAal9B,OAAS,KAAOq4B,EAAaD,EAAe2G,SAE5D1G,EAAWqH,OAhLN,EAiLLtH,EAAe2G,OAAS,KACxB3G,EAAeuI,QAAUtI,EACzBL,EAAK,KAAM,GAAG,IAEdK,EAAakH,GAAqBnH,EArL7B,EAqLmD,QAGpD,IAAkB,IAAd4H,IAAoBE,EAAY,CAC1CA,GAAa,EACb7H,EAAaD,EAAemI,QAAUhB,GAAqBnH,EA5LnD,EA4L0E,GAClF,KACD,EACWC,EAAaD,EAAe2G,SAAa7B,EAAal9B,OAAS,KAAOq4B,EAAaD,EAAeuI,WAC5GtI,EAAakH,GAAqBnH,EAhM1B,EAgMiD,GAAE,CAC5Dj2B,EAAOe,KAAc88B,CACtB,MAGE3H,EAAaD,EAAe8G,UAAYK,GAAqBnH,EAnMtD,EAmM4E,GAGpF70B,EAAWq2B,UAAU12B,EAAU88B,GAAW,GAC1C98B,GAAY,EAEb,MACD,IAAK,SACJ,GAAI+B,EAAO,CACNA,EAAM2I,cAAgB2b,MACzB8O,EAAaD,EAAeoI,QAAUjB,GAAqBnH,EA3MpD,GA2M0E,GACjF70B,EAAWwN,WAAW7N,EAAU+B,EAAM24B,WAAW,GACjD16B,GAAY,GAEZi9B,EAAiBv6B,KAAKvC,EAAK4B,EAAOm7B,GAEnC,KACD,CACChI,EAAiB0G,GAAQ1G,EAAgBl1B,EAAUK,GAAa,IAC5D60B,GACHC,EAAaD,EACbl1B,EAAWy7B,IACLwB,EAAiBv6B,KAAKvC,EAAK4B,EAAOm7B,GAE1C,MACD,IAAK,UACJ/H,EAAaD,EAAe4G,MAAQ5G,EAAe2G,QAAUQ,GAAqBnH,EA9NvE,EA8N+F,GAC1Gj2B,EAAOe,KAAc+B,EAAQ,IAAO,IACpC,MACD,IAAK,YACJmzB,EAAiB0G,GAAQ1G,EAAgBl1B,EAAUK,GAAa,GAC5D60B,GACHC,EAAaD,EACbl1B,EAAWy7B,IACLwB,EAAiBv6B,KAAKvC,EAAK4B,EAAOm7B,GAG3CA,GACD,CAEA,IAAK,IAAIt/B,EAAI,EAAG0D,EAAI27B,EAAiBngC,OAAQc,EAAI0D,GAAI,CACpD,IAkBIs4B,EAlBAz5B,EAAM88B,EAAiBr/B,KACvBmE,EAAQk7B,EAAiBr/B,KACzB8/B,EAAgBT,EAAiBr/B,KACjCs3B,EAAiBC,EAAWh1B,GAgBhC,GAfK+0B,IACJC,EAAWh1B,GAAO+0B,EAAiB,CAClC/0B,MACAg9B,OAAQhI,EACRiI,kBAAmBM,EAAgBR,EACnCG,OAAQ,KACRxB,OAAQ,KACRC,KAAM,KACNE,SAAU,KACVC,SAAU,KACVC,MAAO,KACP9f,QAAS,OAIPra,EAAO,CAUV,IAAIQ,EACJu6B,EAAYC,EAAcJ,EACtBG,EAAY,OACf3H,EAAaD,EAAe+G,SACxB9G,EACH5yB,EAAO,GACE4yB,EAAaD,EAAeyI,UACrCp7B,EAAO,GAEP4yB,EAAakH,GAAqBnH,EAjRnB,EAiRgD,GAC/D3yB,EAAO,KAGR4yB,EAAaD,EAAeyI,UAAYtB,GAAqBnH,EArR7C,EAqR0E,GAC1F3yB,EAAO,GAERq3B,EAAc9E,EAAK/yB,EAAOg7B,GAEC,iBAAhBnD,GAEVmD,EAAcnD,EAAY55B,SAC1BK,EAAau5B,EAAYv5B,WACzBpB,EAAS26B,EAAY36B,OACrB09B,GAAqB96B,EACrB7B,GAAY6B,EACZA,EAAQ,GAERk7B,EAAcnD,EACF,IAATr3B,GACHlC,EAAWq2B,UAAU12B,EAAU88B,GAAW,GAC1C98B,GAAY,IAEZK,EAAWoB,UAAUzB,EAAU88B,GAAW,GAC1C98B,GAAY,EAEd,MACCm1B,EAAaD,EAAe+G,UAAYI,GAAqBnH,EA5S5C,EA4SyE,GAC1F70B,EAAWw2B,SAAS72B,EAAoB,OAAV+B,GAAkB,IAAM,GAAG,GACzD/B,GAAY,EAEbk9B,GACD,CAGA,IAAIrE,EAAW1D,EAAWpB,IAC1B,GAAgB,MAAZ8E,EAAkB,CACrBA,EAAW3E,EAAM8F,aAAal9B,OAC9B,IAEIqD,EAAK1E,EAFL6xB,EAAY,GACZ4H,EAAiBC,EAErB,UAA0C1wB,KAAlChJ,EAAOy5B,EAAesH,SAAuB,CACpD,IAAIj6B,EAAO2yB,EAAeuH,OAC1BvH,EAAiBA,EAAewH,SAChCv8B,EAAM+0B,EAAe/0B,IACrB,IAAIsxB,EAAW,CAACh2B,EAAM8G,EAAMpC,GACxB+0B,EAAekI,mBAClB3L,EAAS/uB,KAAKwyB,EAAekI,mBAC9B9P,EAAU5qB,KAAK+uB,GACfyD,EAAiBA,EAAeiI,MACjC,CACA7P,EAAU7Y,UACV0gB,EAAWpB,IAAiB8E,EAC5B3E,EAAM8F,aAAanB,GAAYvL,EAC/BwH,EAAK,KAAM,GAAG,EACf,CAGA,OAAQyB,GACP,KAAK,EACJ,GAAIsC,GAAY,GAAM,OAAO,EAC7B55B,EAAO4C,GAASg3B,EAAW,GAC3B,MACD,KAAK,EACJ,GAAIA,GAAY,IAAO,OAAO,EAC9B55B,EAAO4C,GAAS,GAChB5C,EAAO4C,EAAQ,GAAKg3B,EACpB,MACD,KAAK,EACJ,GAAIA,GAAY,MAAS,OAAO,EAChC55B,EAAO4C,GAAS,GAChBxB,EAAWq2B,UAAU70B,EAAQ,EAAGg3B,GAAU,GAC1C,MACD,KAAK,EACJ,GAAIA,GAAY,SAAW,OAAO,EAClCx4B,EAAWoB,UAAUI,EAAyB,IAAjBg3B,GAAY,IAAW,GAItD,GAAI74B,EAAW28B,EAAmB,CACjC,GAAIA,IAAsBI,EACzB,OAAO/8B,EAERf,EAAOg3B,WAAWj2B,EAAU28B,EAAmBI,GAC/CA,GAAe/8B,EAAW28B,EAC1B3C,EAAa4C,gBAAkB58B,EAAW6B,CAC3C,MAAO,GAAI7B,EAAW28B,EACrB,OAAIA,IAAsBI,EAClB/8B,GACRg6B,EAAa4C,gBAAkB58B,EAAW6B,EACnCyzB,EAAYhH,EAAQrvB,EAAQ4C,EAAOugB,EAAYyT,EAAUf,EAAMZ,IAEvE,OAAO6I,CACR,EDqnBClJ,GAAmB8H,GACnBtF,GC1QD,SAA2BjU,EAAY8R,GACtC,GAAIA,EAAM8F,aAAc,CACvB,IAAI4D,EAAY,IAAItlB,IACpBslB,EAAUp8B,IAAI,QAAS4gB,GACvBwb,EAAUp8B,IAAI,QAAS0yB,EAAM8F,cAC7B5X,EAAawb,CACd,CACA,IAAIC,EAA4B3J,EAAM2J,2BAA6B,EAmBnE,OAlBAzb,EAAWG,aAAekL,IACzB,IAAI6M,GAAa,EAcjB,OAbI7M,aAAoBnV,MACXmV,EAAS/nB,IAAI,UAAY,IAC3B5I,UAAYo3B,EAAMkB,2BAA6B,KACxDkF,GAAa,IACF7M,EAAS/nB,IAAI,UAAY,IAC3B5I,SAAW+gC,IACpBvD,GAAa,KACJ7M,aAAoB30B,OAASA,MAAMC,QAAQ00B,KACjDA,EAAS3wB,UAAYo3B,EAAMkB,2BAA6B,KAC3DkF,GAAa,GAEVA,GACJpG,EAAM/G,iBAAiBM,GACjB6M,CAAU,EAElBpG,EAAM2J,0BAA4B3J,EAAM8F,cAAgB9F,EAAM8F,aAAal9B,OACpEslB,CACR,EA7TA,IAAI0b,GAAe37B,OAAOC,IAAI,UA4Q9B,SAAS27B,GAAWC,GACnB,OAAOA,GACN,KAAK,IAAM,OAAO,KAClB,KAAK,IAAM,OACX,KAAK,IAAM,OAAO,EAClB,KAAK,IAAM,OAAO,EAEnB,MAAM,IAAI7+B,MAAM,mBACjB,CACA,SAAS8+B,GAAWv4B,GACnB,OAAO,WACN,OAAOA,EAAIkF,KAAKkzB,IACjB,CACD,CC/uBA,GHinCC/R,GE1pBD,SAAoB/nB,EAAKhE,EAAU8qB,EAAQoT,GAC1C,IAAIrF,EAAW70B,EAAIhE,KAAc,GACjC,GAAI64B,GAAY,GACf,OAAOA,GACN,KAAK,GAAIA,EAAW70B,EAAIhE,KAAa,MAErC,KAAK,GAAI64B,EAAW70B,EAAIhE,MAAegE,EAAIhE,MAAe,GAAI,MAC9D,KAAK,GAAI64B,EAAW70B,EAAIhE,MAAegE,EAAIhE,MAAe,IAAMgE,EAAIhE,MAAe,IAAK,MACxF,KAAK,GAAI64B,EAAW70B,EAAIhE,MAAegE,EAAIhE,MAAe,IAAMgE,EAAIhE,MAAe,KAAOgE,EAAIhE,MAAe,IAG/G,IAAIstB,EAAY4Q,EAAQlE,cAAgBkE,EAAQlE,aAAanB,GAC7D,IAAKvL,EAAW,CAMf,GAJAtpB,EAAMzC,WAAWU,UAAUlE,MAAMmE,KAAK8B,EAAKhE,EAAU8qB,GACrDA,GAAU9qB,EACVA,EAAW,EACXk+B,EAAQ/Q,iBAAiB+Q,EAAQxb,kBAC5Bwb,EAAQlE,aACZ,MAAM,IAAI76B,MAAM,8CAGjB,GAFA++B,EAAQL,0BAA4BK,EAAQlE,aAAal9B,OACzDwwB,EAAY4Q,EAAQlE,aAAanB,IAC5BvL,EACJ,MAAM,IAAInuB,MAAM,kCAAoC05B,EACtD,CACA,IAAIsF,EAAY7Q,EAAU6Q,UAC1B,IAAKA,EAAW,CAGf,IAAIl8B,GAFJk8B,EAAY7Q,EAAU6Q,UAAY,WAClC,GAC0Bl8B,UAC1B,IAEIm8B,EAFAC,EAAa,GACbC,EAAgB,EAEpB,IAAK,IAAI1gC,EAAI,EAAG0D,EAAIgsB,EAAUxwB,OAAQc,EAAI0D,EAAG1D,IAAK,CACjD,IAAIyH,EAAaioB,EAAU1vB,IACrBnC,EAAM8G,EAAMpC,EAAKi9B,GAAsB/3B,EACjC,cAARlF,IACHA,EAAM,YACP,IAQIo+B,EA4BA74B,EApCA+rB,EAAW,CACdtxB,MACAkR,OAAQitB,GAOT,OALIlB,EACHiB,EAAWrzB,OAAOpN,EAAIw/B,EAAmB,EAAG3L,GAE5C4M,EAAW37B,KAAK+uB,GAEVlvB,GACN,KAAK,EAAGg8B,EAAS,IAAM,EAAG,MAC1B,KAAK,EACJA,EAAS,CAAC7yB,EAAQ1L,KACjB,IAAIw+B,EAAM9yB,EAAO8B,MAAMxN,EAAWyxB,EAASpgB,QAC3C,OAAOmtB,GAAO,IAAOT,GAAWS,GAAOA,CAAG,EAE3C,MACD,KAAK,EACJD,EAAS,CAAC7yB,EAAQ1L,KACjB,IAAIgE,EAAM0H,EAAO8B,MAEbgxB,GADWx6B,EAAI1D,WAAa0D,EAAI1D,SAAW,IAAIC,SAASyD,EAAInE,OAAQmE,EAAIxD,WAAYwD,EAAIvD,cACzEsuB,UAAU/uB,EAAWyxB,EAASpgB,QAAQ,GACzD,OAAOmtB,GAAO,MAAST,GAAiB,IAANS,GAAcA,CAAG,EAEpD,MACD,KAAK,EACJD,EAAS,CAAC7yB,EAAQ1L,KACjB,IAAIgE,EAAM0H,EAAO8B,MAEbgxB,GADWx6B,EAAI1D,WAAa0D,EAAI1D,SAAW,IAAIC,SAASyD,EAAInE,OAAQmE,EAAIxD,WAAYwD,EAAIvD,cACzE0M,UAAUnN,EAAWyxB,EAASpgB,QAAQ,GACzD,OAAOmtB,GAAO,WAAaT,GAAiB,IAANS,GAAcA,CAAG,EAO1D,OAHA/M,EAAS8M,OAASA,EAClBD,GAAiB/7B,EAEV9G,GACN,KAxgBU,EAygBL2iC,IAAoBA,EAAgBxyB,OACvCwyB,EAAgBxyB,KAAO6lB,GACxB2M,EAAkB3M,EAClBA,EAASgN,cAAgB,EACzB/4B,EAAM,SAASgG,GACd,IAAI1H,EAAM0H,EAAO8B,MACbxN,EAAW0L,EAAO1L,SAClB0+B,EAAWJ,EAAgBt+B,EAC3Bw+B,EAAMD,EAAO7yB,EAAQ1L,GACzB,GAAmB,iBAARw+B,EAAkB,OAAOA,EAEpC,IAAI18B,EAAK8J,EAAO6lB,EAAS7lB,KACzB,KAAMA,IACL9J,EAAM8J,EAAK2yB,OAAO7yB,EAAQ1L,GACP,iBAAR8B,IAGVA,EAAM,KACP8J,EAAOA,EAAKA,KAIb,OAFW,MAAP9J,IACHA,EAAM4J,EAAOizB,SAAWD,GACrBhzB,EAAOwf,UACHxf,EAAOwf,UAAUntB,MAAMygC,EAAK18B,GAwB7BO,GAAW2B,EAAKw6B,EAAME,EAAU58B,EAAM08B,EAE9C,EACA,MACD,KA1jBS,EA0jBE,KAzjBK,EA0jBXJ,IAAoBA,EAAgBxyB,OACvCwyB,EAAgBxyB,KAAO6lB,GACxB2M,EAAkB3M,EAClB/rB,EAAM,SAASgG,GACd,IAAI1L,EAAW0L,EAAO1L,SAClB0+B,EAAWJ,EAAgBt+B,EAC3Bw+B,EAAMD,EAAO7yB,EAAQ1L,GACzB,GAAmB,iBAARw+B,EAAkB,OAAOA,EACpC,IACI18B,EADAkC,EAAM0H,EAAO8B,MACR5B,EAAO6lB,EAAS7lB,KACzB,KAAMA,IACL9J,EAAM8J,EAAK2yB,OAAO7yB,EAAQ1L,GACP,iBAAR8B,IAGVA,EAAM,KACP8J,EAAOA,EAAKA,KAIb,GAFW,MAAP9J,IACHA,EAAM4J,EAAOizB,SAAWD,GA9kBlB,IA+kBHjjC,EACH,OAAOuI,EAAI8R,SAAS,OAAQ0oB,EAAME,EAAU58B,EAAM48B,GAElDhD,GAAgBhwB,EAChB,IACC,OAAOwyB,EAAQrR,OAAO7oB,EAAK,CAAEnC,MAAO28B,EAAME,EAAU58B,IAAKA,EAAM48B,GAChE,CAAE,QACDhD,GAAgB,IACjB,CAEF,EACA,MACD,KA5lBW,EA6lBV,OAAOn5B,GACN,KAAK,EACJmD,EAAM,SAAUgG,GACf,IAAI1H,EAAM0H,EAAO8B,MACblN,EAAW0D,EAAI1D,WAAa0D,EAAI1D,SAAW,IAAIC,SAASyD,EAAInE,OAAQmE,EAAIxD,WAAYwD,EAAIvD,aACxFT,EAAW0L,EAAO1L,SAAWyxB,EAASpgB,OACtCtP,EAAQzB,EAASgC,SAAStC,GAAU,GACxC,GAAI+B,EAAQ,UAAY,CACvB,GAAIA,GAAS,UACZ,OAAOA,EACR,GAAIA,GAAS,UACZ,OAAOg8B,GAAmB,IAARh8B,EACpB,CACA,IAAI68B,EAASt+B,EAAS2uB,WAAWjvB,GAAU,GAEvCmvB,EAAaC,IAA6B,IAApBprB,EAAIhE,EAAW,KAAc,EAAMgE,EAAIhE,EAAW,IAAM,GAClF,OAASmvB,EAAayP,GAAUA,EAAS,EAAI,IAAO,KAAS,GAAKzP,CACnE,EACA,MACD,KAAK,EACJzpB,EAAM,SAAUgG,GACf,IAAI1H,EAAM0H,EAAO8B,MAEbzL,GADWiC,EAAI1D,WAAa0D,EAAI1D,SAAW,IAAIC,SAASyD,EAAInE,OAAQmE,EAAIxD,WAAYwD,EAAIvD,cACvEoqB,WAAWnf,EAAO1L,SAAWyxB,EAASpgB,QAAQ,GACnE,GAAI8mB,MAAMp2B,GAAQ,CACjB,IAAI8uB,EAAO7sB,EAAI0H,EAAO1L,SAAWyxB,EAASpgB,QAC1C,GAAIwf,GAAQ,IACX,OAAOkN,GAAWlN,EACpB,CACA,OAAO9uB,CACR,EACA,MACD,KAAK,EACJ2D,EAAM,SAAUgG,GACf,IACI3J,EADM2J,EAAO8B,MACD9B,EAAO1L,SAAWyxB,EAASpgB,QAC3C,OAAOtP,EAAQ,IAAOA,EAAQg8B,GAAWh8B,EAC1C,EAGF,MACD,KAnoBS,GAooBR2D,EAAM,SAAUgG,GACf,IAAI1H,EAAM0H,EAAO8B,MACblN,EAAW0D,EAAI1D,WAAa0D,EAAI1D,SAAW,IAAIC,SAASyD,EAAInE,OAAQmE,EAAIxD,WAAYwD,EAAIvD,aAC5F,OAAO,IAAI4lB,KAAK/lB,EAASuqB,WAAWnf,EAAO1L,SAAWyxB,EAASpgB,QAAQ,GACxE,EAIFogB,EAAS/rB,IAAMA,CAChB,CAEA,GAAI81B,GAAe,CAClB,IAGIqD,EAHAC,EAA0B,GAC1BC,EAAO,GACPnhC,EAAI,EAER,IAAK,IAAI6zB,KAAY4M,EAAY,CAChC,GAAIH,EAAQc,oBAAsBd,EAAQc,mBAAmBvN,EAAStxB,KAAM,CAG3E0+B,GAAyB,EACzB,QACD,CACAt5B,OAAOC,eAAevD,EAAWwvB,EAAStxB,IAAK,CAAEuF,IAAKu4B,GAAWxM,EAAS/rB,KAAMD,YAAY,IAC5F,IAAIw5B,EAAgB,IAAMrhC,IAC1BmhC,EAAKr8B,KAAKu8B,GACVH,EAAwBp8B,KAAK,IAAMmP,KAAKwP,UAAUoQ,EAAStxB,KAAO,KAAO8+B,EAAgB,MAC1F,CACIJ,GACHC,EAAwBp8B,KAAK,kBAE9B,IAAIw8B,EAAW,IAAK9S,YAAY2S,EAAM,6BAA+BD,EAAwBtiC,KAAK,KAAO,MAAOm0B,MAAM,KAAM0N,EAAWj/B,KAAIwG,GAAQA,EAAKF,OACxJH,OAAOC,eAAevD,EAAW,SAAU,CAC1CF,MAAMo9B,GACL,OAAOD,EAASh9B,KAAK0I,KAAMA,KAAKkzB,IACjC,GAEF,MACCv4B,OAAOC,eAAevD,EAAW,SAAU,CAC1CF,MAAMo9B,GAEL,IAAIC,EAAW,CAAC,EAChB,IAAK,IAAIxhC,EAAI,EAAG0D,EAAI+8B,EAAWvhC,OAAQc,EAAI0D,EAAG1D,IAAK,CAElD,IAAIuC,EAAMk+B,EAAWzgC,GAAGuC,IAExBi/B,EAASj/B,GAAOyK,KAAKzK,EACtB,CACA,OAAOi/B,CACR,GAIH,CACA,IAAIC,EAAW,IAAIlB,EAOnB,OANAkB,EAASvB,IAAgB,CACxBtwB,MAAOxJ,EACPhE,WACAkrB,UAAW,GACXyT,SAAU7T,GAEJuU,CACR,EFiZCrT,GEjsBD,SAA4BsT,GAC3B,KAAMA,aAAsBhnB,KAC3B,OAAOgnB,EACR,IAAIC,EAAQD,EAAW55B,IAAI,UAAY,GACnCH,OAAO8nB,SAASkS,KACnBA,EAAQA,EAAMngC,KAAIkuB,GAAaA,EAAUvvB,MAAM,MAChD,IAAIyhC,EAAQF,EAAW55B,IAAI,SACvBuvB,EAAc1vB,OAAO6a,OAAO,MAChC,IAAK,IAAIxiB,EAAI,EAAG0D,EAAIi+B,EAAMziC,OAAQc,EAAI0D,EAAG1D,IAAK,CAC7C,IAAI0vB,EAAYiS,EAAM3hC,GAClBu3B,EAAaF,EACjB,IAAK,IAAKx5B,EAAM8G,EAAMpC,KAAQmtB,EAAW,CACxC,IAAI4H,EAAiBC,EAAWh1B,GAC3B+0B,IACJC,EAAWh1B,GAAO+0B,EAAiB,CAClC/0B,MACAg9B,OAAQhI,EACRiI,kBAAmB,EACnBC,OAAQ,KACRxB,OAAQ,KACRC,KAAM,KACNE,SAAU,KACVC,SAAU,KACVC,MAAO,KACP9f,QAAS,KACTkhB,OAAQ,OAGVnI,EAAakH,GAAqBnH,EAAgBz5B,EAAM8G,EACzD,CACA4yB,EAAWpB,IAAiBn2B,CAC7B,CAIA,OAHA2hC,EAAMtK,YAAcA,EACpBrqB,KAAKovB,aAAeuF,EACpB30B,KAAKizB,0BAA4B0B,EAAMziC,OAChC0iC,CACR,EF8pBCvT,GElYD,WACKyP,KACHA,GAAcluB,MAAQjM,WAAWU,UAAUlE,MAAMmE,KAAKw5B,GAAcluB,MAAOkuB,GAAc17B,SAAU07B,GAAciD,UACjHjD,GAAc17B,SAAW,EACzB07B,GAAciD,SAAWjD,GAAcluB,MAAM1Q,OAE/C,EEnwBqC0C,QAAQ,eDU4CiF,IAAtDpK,QAAQS,IAAI2kC,uCAA2H,SAApEplC,QAAQS,IAAI2kC,sCAAsCC,cAEvH,CAChC,IAAIC,EACJ,IAEEA,EADqB,mBAAXngC,QACEA,QAAQ,qBAER,IAAAogC,eAAc,yEAAd,CAA+B,oBACxCD,GHkiBC,SAAsBE,GAM5B,SAASx9B,EAAWy9B,GACnB,OAAO,SAAoBhjC,GAC1B,IAAI8H,EAASymB,GAAQC,MACrB,GAAc,MAAV1mB,EAAgB,CACnB,GAAIumB,GACH,OAAOmF,GAAaxzB,GACrB,IAAI0D,EAAawD,GAAIxD,WACjBu/B,EAAaF,EAAe7/B,GAAW8/B,EAAet/B,EAAYsqB,GAAStqB,EAAYwD,GAAInE,QAC/F,GAAyB,iBAAdkgC,EACVn7B,EAASm7B,EACT1U,GAAUL,QAMV,GAHAM,GAAiB,EACjBG,GAAe,EACf7mB,GAHAymB,GAAU0U,GAGO,QACFt7B,IAAXG,EACH,MAAM,IAAIzF,MAAM,2BAEnB,CACA,IAAI6gC,EAAkBp7B,EAAO9H,OAC7B,OAAIkjC,GAAmBljC,GACtBkD,IAAYlD,EACL8H,IAERsmB,GAAYtmB,EACZ4mB,GAAiBxrB,GACjByrB,GAAezrB,GAAWggC,EAC1BhgC,IAAYlD,EACL8H,EAAO7G,MAAM,EAAGjB,GACxB,CACD,CApCAyzB,IAA8B,EAC9B5B,GAAkBtsB,EAAW,GAC7ButB,GAAcvtB,EAAW,GACzBwtB,GAAextB,EAAW,GAC1BytB,GAAeztB,EAAW,EAiC3B,CGvkBG49B,CAAaN,EAAUE,eACzB,CAAE,MAAO7gC,GAET,CACD,CExBA,MAAMkhC,GAAmB,WACnBC,GAAa,WACNC,GAAgB,CAC5Bz+B,YAAa,qHAKP,MAAM0+B,GACZ31B,YAAYuF,GAEX,GADArF,KAAK01B,QAAUrwB,GAAWA,EAAQqwB,SAAW,KACzC11B,KAAK01B,QAAU,QAClB,MAAM,IAAInhC,MAAM,+FACjByL,KAAK21B,QA+HP,SAA2BC,EAAWC,GACrC,IAAIC,EAAWC,aAAY,KAC1B,IAAIC,EAAUJ,EAAU5oB,QACpBgpB,EACHA,EAAQC,UAERC,cAAcJ,EAAQ,GACrBD,GACCC,EAASK,OACZL,EAASK,OACX,CAxIEC,CAAkB,IAAI/oB,QAAQrN,MAAOqF,GAAWA,EAAQwwB,iBAAmB,IAC5E,CACAznB,OAAOe,GACFA,EAAM/Z,SAAWmgC,KACpBv1B,KAAKq2B,IAAKlnB,EAAM/Z,UAAY,GAAM,GAAoB,QAAjB+Z,EAAM/Z,UAAuB,MAEnE+Z,EAAM/Z,UAAYmgC,EACnB,CACAnmB,KAAKD,EAAOF,GACX,IA2BIqnB,EACAC,EA5BAC,EAAmBrnB,EAAM/Z,SAE7B,GAAI6Z,EAAqB,EAMxB,OAJIE,EAAM/Z,SAAWmgC,KACpBv1B,KAAKq2B,IAAKlnB,EAAM/Z,UAAY,GAAM,GAAoB,QAAjB+Z,EAAM/Z,UAAuB,WAEnE+Z,EAAM/Z,SAAWkgC,IAEX,GAAInmB,EAAM/Z,UAAYkgC,IAA0Cz7B,MAAtBoV,EAA1C,CAEA,GAAIA,GAAsB,EAAG,CACnC,IAAIwnB,EAAO,EAGX,IAFIxnB,EAAsBjP,KAAK01B,SAAW,IACzCzmB,EAAqBjP,KAAK01B,SAAW,GAC/BzmB,EAAqB,GAC3BA,IAA2C,EAC3CwnB,IAEDxnB,EAAqBwnB,CACtB,MAEExnB,EADGunB,GAAoB,EACDA,GAAoB,GAAM,GAE3B,EAKvB,GAAIA,EAAmBjB,GAAY,CAElC,GADAgB,EAAYC,GAAoB,GAAM,EAClCD,GAAY,EACf,OACD,IAAIF,EAAMr2B,KAAKq2B,IAAIE,GAGnB,GADAD,EAAcD,EAAIjhC,UACbohC,EAAmBF,EAAcA,EAAct2B,KAAK01B,QAAUY,GAAeE,EAAoBx2B,KAAK01B,SAAW,EACrH,OACDW,EAAuB,QAAnBG,GAA+B,KACnCD,GACD,MACCA,EAAW,EACZv2B,KAAK02B,YAAYvnB,EAAOonB,EAAUtnB,EAjBlC,CAkBD,CACAynB,YAAYvnB,EAAOonB,EAAUtnB,GAC5B,IAAIqnB,EAAaK,EAAU32B,KAAKq2B,IAAIE,GAChCK,EAAS,SAAa,GAAK3nB,EAC/B,OAAG,CAEFqnB,EAAcK,EAAQvhC,SAAWwhC,EACjC,IAAIC,EAAgBF,EAAsB,QAAdL,GAY5B,GAXAK,EAAsB,QAAdL,GAA0BnnB,EAC9BA,IACHA,EAAM/Z,SAAWkhC,EAAernB,GAAsB,IACvD0nB,EAAQvhC,WAAakhC,GACF,QAAdA,IAA2Bt2B,KAAK01B,UAEpCY,GAAe,WACfK,EAAQvhC,SAAWkhC,EACnBK,EAAQG,YAET3nB,EAAQ0nB,MACMF,EAAU32B,KAAKq2B,MAAME,IAIlC,MAFAK,EAAS,SAAa,IADtB3nB,GAAuBE,EAAM/Z,UAAY,IAAM,GAAM,GAIvD,CACI+Z,IACHA,EAAM/Z,UAAYmgC,GACdpmB,EAAMH,MACTG,EAAMH,MAAM+nB,SAAS5nB,GACbA,EAAMnC,QACdmC,EAAMhY,MAAQq+B,IAEjB,CACAG,QAeC31B,KAAKq2B,IAAM,GACX,IAAK,IAAIrjC,EAAI,EAAGA,EAAI,EAAGA,IACtBgN,KAAKq2B,IAAIrjC,GAAK,IAAI9E,MAAM8R,KAAK01B,SAC7B11B,KAAKq2B,IAAIrjC,GAAGoC,SAAWpC,GAAK,GAC5BgN,KAAKq2B,IAAIrjC,GAAG8jC,OAAS,CAEvB,CACAb,UACC,IAAIe,EAAUh3B,KAAK01B,SAAW,EAC9B,IAAK,IAAI1iC,EAAI,EAAGA,GAAK,EAAGA,IAAK,CAC5B,IAAIqjC,EAAMr2B,KAAKq2B,IAAIrjC,GACnB,IAAK,IAAI8oB,EAAI,EAAGplB,EAAIsgC,EAASlb,EAAIplB,EAAGolB,IAC/Bua,EAAmB,QAAfA,EAAIjhC,WACX4hC,IACAh3B,KAAK02B,YAAY,KAAM1jC,EAAG,KAEJ,UAAfqjC,EAAIjhC,WAAwB4K,KAAK01B,UAEvCW,EAAIjhC,UAAY,WAChBihC,EAAIS,SAIR,CACD,ECvID,IAAIG,GACG,MAAM,WAAqBvpB,IACjC5N,YAAYuF,GACXtF,QACAC,KAAKk3B,KAAO,EACZl3B,KAAKm3B,OAAS,EACV9xB,GAAWA,EAAQ+xB,YACtB/xB,EAAQqwB,QAAUrwB,EAAQ+xB,WAAa,GAEpC/xB,GAAWA,EAAQiK,oBACtBtP,KAAKsP,kBAAoBjK,EAAQiK,kBACjCtP,KAAKq3B,eAAiB,EACtBr3B,KAAKpE,iBAAmByJ,EAAQzJ,kBAEjCoE,KAAKg2B,SAAW3wB,GAA8B,IAApBA,EAAQ2wB,QAAoBsB,GAAsBjyB,EAAQ2wB,QAAU,OAASiB,KAAmBA,GAAiB,IAAIxB,GAAYpwB,IAC3JrF,KAAKu3B,cAAgBllC,QAAQgT,GAAWA,EAAQkyB,eACjCv3B,KAAKw3B,SAAW,IAAIC,sBAAqBliC,IACvD,IAAI4Z,EAAQpP,MAAMjF,IAAIvF,GAClB4Z,GAASA,EAAMnC,YAA2BnT,IAAlBsV,EAAMnC,SACjCjN,MAAMqO,OAAO7Y,EAAG,GAEnB,CACAwhC,SAAS5nB,GACR,IAAI9a,EAAS8a,EAAMnC,OAASmC,EAAMnC,QAC9B3Y,GAEH2L,KAAKw3B,SAASE,SAASrjC,EAAQ8a,EAAM5Z,KACrC4Z,EAAMhY,WAAQ0C,GACJsV,EAAM5Z,KACGwK,MAAMjF,IAAIqU,EAAM5Z,OACd4Z,GACpBpP,MAAMqO,OAAOe,EAAM5Z,IAEtB,CACAuF,IAAIvF,EAAKohB,GACR,IACIxf,EADAgY,EAAQpP,MAAMjF,IAAIvF,GAEtB,GAAI4Z,EAAO,CAGV,GAFAnP,KAAKk3B,OACL//B,EAAQgY,EAAMhY,MACVA,IAAUq+B,GAgBb,OAFa,IAAT7e,GACH3W,KAAKg2B,QAAQ5mB,KAAKD,GACH,IAATwH,EAAaxf,EAAQgY,EAd5B,GADAhY,EAAQgY,EAAMnC,OAASmC,EAAMnC,aACfnT,IAAV1C,EAQH,OALAgY,EAAMhY,MAAQA,EACV6I,KAAKsP,mBACRtP,KAAK23B,0BACO,IAAThhB,GACH3W,KAAKg2B,QAAQ5mB,KAAKD,GACH,IAATwH,EAAaxf,EAAQgY,EAP5BpP,MAAMqO,OAAO7Y,EAehB,MACCyK,KAAKm3B,QACP,CACAznB,SAASna,GACR,OAAOyK,KAAKlF,IAAIvF,EAAK,EACtB,CAEAoa,SAASpa,EAAK4B,EAAO8X,GACpB,IAAIE,EAeJ,OAdIhY,GAAyB,iBAATA,GACnBgY,EAAQ,IAAI9B,QAAQlW,GAChB6I,KAAKsP,mBACRtP,KAAK23B,0BACNxoB,EAAMhY,MAAQA,EACV6I,KAAKu3B,eACRpoB,EAAM5Z,IAAMA,EACZ4Z,EAAMH,MAAQhP,MAEdA,KAAKw3B,SAASE,SAASvgC,EAAO5B,SACXsE,IAAV1C,IACVgY,EAAQ,CAAEhY,QAAO5B,MAAKyZ,MAAOhP,OAE9BA,KAAKpJ,IAAIrB,EAAK4Z,EAAOF,GACdE,CACR,CACAwoB,4BACO33B,KAAKq3B,gBAAkBr3B,KAAKsP,oBACjCtP,KAAKq3B,eAAiB,EAClBr3B,KAAKpE,kBACRoE,KAAKpE,mBACFoE,KAAKw3B,SAASI,aACjB53B,KAAKw3B,SAASI,cAEjB,CACAhhC,IAAIrB,EAAK4Z,EAAOF,GACf,IAAI4oB,EAAW93B,MAAMjF,IAAIvF,GAGzB,OAFIsiC,GACH73B,KAAKg2B,QAAQ5nB,OAAOypB,GACd73B,KAAK83B,OAAOviC,EAAK4Z,EAAOF,EAChC,CACA6oB,OAAOviC,EAAK4Z,EAAOF,GAIlB,OAHIE,GACHnP,KAAKg2B,QAAQ5mB,KAAKD,EAAOF,GAEnBlP,MAAMnJ,IAAIrB,EAAK4Z,EACvB,CACAf,OAAO7Y,GACN,IAAIsiC,EAAW93B,MAAMjF,IAAIvF,GAIzB,OAHIsiC,GACH73B,KAAKg2B,QAAQ5nB,OAAOypB,GAEd93B,MAAMqO,OAAO7Y,EACrB,CACA6Z,KAAKD,EAAOF,GACXjP,KAAKg2B,QAAQ5mB,KAAKD,EAAOF,EAC1B,CACA9O,QACC,IAAK,IAAM5K,EAAK4Z,KAAWnP,KAC1BA,KAAKg2B,QAAQ5nB,OAAOe,GACpBpP,MAAMqO,OAAO7Y,EAEf,EAcD,MAAM+hC,GAAsB,IAX5B,MACCloB,KAAKD,GACAA,EAAMH,MACTG,EAAMH,MAAM+nB,SAAS5nB,GACbA,EAAMnC,QACdmC,EAAMhY,MAAQq+B,GAChB,CACApnB,OAAOe,GAEP,G,IhB5D4B3R,G,4BiBtDDjJ,MCX5B,2BlBiE6BiJ,GkBhEhB,CACZ1M,KAAI,WAAI,UAAQ,0BAAiB,gBAAc,iBAAe,GAC9DqL,aAAY,oBAAM,KAAAzM,YAAYsM,OAAO2B,GAChClO,QAAQsoC,kBAAoBtoC,QAAQuoC,cAAc,QAAU,GAC/DvoC,QAAQwoC,gBAAgBxoC,QAAQuoC,cAAc,QAAU,GACzDvoC,QAAQkf,GAAG,OAAQhR,EACpB,GlB2DA7M,EAAO0M,GAAU1M,KACjBnB,EAAK6N,GAAU7N,GACfwM,EAAeqB,GAAUrB,aACzBC,EAAgBoB,GAAUpB,cAC1BC,EAAkBmB,GAAUnB,gBAC5BC,EAAekB,GAAUlB,aACzBL,EAASuB,GAAUvB,OACjBF,EAAKyB,GAAUzB,GACjBC,EAASwB,GAAUxB,OkBzDb,IAAI,KAAEk8B,IAAS76B,EAUwB,eAAkB,eAAkB,iBChClF,IAAI,IAAU,IAAA23B,eAAc,uEZGrB,SAAoBpgC,GAC1B8b,GAAgB9b,CACjB,CYJAujC,CAAW,IACJ,IAAIC,IAAwB,EAE/BhoC,GAAWX,QAAQW,SACvB,IAAKA,GAASG,OAASd,QAAQe,MAAO,CACrC,IAAM6nC,EAAcC,GAAiBloC,GAASkE,KAAK7F,MAAM,KACzD,GAAI2B,GAASmoC,KAAOF,GAAgBh7B,EAAY9N,QAAQipC,oBAAqB,CAC5E,IAAIC,EAAU,CAAC,EACXC,GAAgC,IAAhBL,GAAsC,IAAhBA,GAAsC,IAAhBA,GAAsBC,EAAe,KAAO7oC,QAAQS,IAAIyoC,oBACpHD,GACH,GAAQ,MAAME,mBAAmB,0BAElCv7B,EAAYw7B,eAAeJ,EAASC,GACpC/9B,OAAOuK,OAAO7H,EAAao7B,GAC3BL,IAAwB,CACzB,MAAO,GAAoB,IAAhBC,EAAoB,CAE9B,IAAII,EAAU,CAAC,EACfp7B,EAAYw7B,eAAeJ,GAAS,GACpCp7B,EAAYzB,iBAAmB68B,EAAQ78B,gBACxC,CACAyB,EAAYy7B,uBACb,CACAv7B,EAAmBF,GCzBnB,MAAM07B,GAA8C,GAC7CpqC,eAAeqqC,GAASC,GAClB,GAAKA,EAAQC,eAAe,MAAO,CAAC,EAGjD,CAGOvqC,eAAewqC,KAClB,IAAK,IAAIC,KAAgBL,SACfK,GAEd,C","sources":[".././node_modules/detect-libc/lib/detect-libc.js",".././node_modules/detect-libc/lib/process.js",".././node_modules/node-gyp-build-optional-packages/index.js","../external node-commonjs \"child_process\"","../external node-commonjs \"fs\"","../external node-commonjs \"module\"","../external node-commonjs \"path\"","../external node-commonjs \"url\"",".././node_modules/ordered-binary/index.js","../webpack/bootstrap","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object",".././node_modules/lmdb/native.js",".././node_modules/lmdb/util/when.js",".././node_modules/lmdb/write.js",".././node_modules/lmdb/util/RangeIterable.js",".././node_modules/lmdb/keys.js",".././node_modules/lmdb/read.js",".././node_modules/lmdb/caching.js",".././node_modules/lmdb/open.js","../external node-commonjs \"events\"","../external node-commonjs \"os\"",".././node_modules/msgpackr/unpack.js",".././node_modules/msgpackr/pack.js",".././node_modules/msgpackr/struct.js",".././node_modules/msgpackr/node-index.js","../external node-commonjs \"stream\"",".././node_modules/weak-lru-cache/LRFUExpirer.js",".././node_modules/weak-lru-cache/index.js",".././node_modules/lmdb/level.js",".././node_modules/lmdb/index.js",".././node_modules/lmdb/node-index.js",".././extension.ts"],"sourcesContent":["'use strict';\n\nconst childProcess = require('child_process');\nconst { isLinux, getReport } = require('./process');\n\nconst command = 'getconf GNU_LIBC_VERSION 2>&1 || true; ldd --version 2>&1 || true';\nlet commandOut = '';\n\nconst safeCommand = () => {\n  if (!commandOut) {\n    return new Promise((resolve) => {\n      childProcess.exec(command, (err, out) => {\n        commandOut = err ? ' ' : out;\n        resolve(commandOut);\n      });\n    });\n  }\n  return commandOut;\n};\n\nconst safeCommandSync = () => {\n  if (!commandOut) {\n    try {\n      commandOut = childProcess.execSync(command, { encoding: 'utf8' });\n    } catch (_err) {\n      commandOut = ' ';\n    }\n  }\n  return commandOut;\n};\n\n/**\n * A String constant containing the value `glibc`.\n * @type {string}\n * @public\n */\nconst GLIBC = 'glibc';\n\n/**\n * A String constant containing the value `musl`.\n * @type {string}\n * @public\n */\nconst MUSL = 'musl';\n\nconst isFileMusl = (f) => f.includes('libc.musl-') || f.includes('ld-musl-');\n\nconst familyFromReport = () => {\n  const report = getReport();\n  if (report.header && report.header.glibcVersionRuntime) {\n    return GLIBC;\n  }\n  if (Array.isArray(report.sharedObjects)) {\n    if (report.sharedObjects.some(isFileMusl)) {\n      return MUSL;\n    }\n  }\n  return null;\n};\n\nconst familyFromCommand = (out) => {\n  const [getconf, ldd1] = out.split(/[\\r\\n]+/);\n  if (getconf && getconf.includes(GLIBC)) {\n    return GLIBC;\n  }\n  if (ldd1 && ldd1.includes(MUSL)) {\n    return MUSL;\n  }\n  return null;\n};\n\n/**\n * Resolves with the libc family when it can be determined, `null` otherwise.\n * @returns {Promise<?string>}\n */\nconst family = async () => {\n  let family = null;\n  if (isLinux()) {\n    family = familyFromReport();\n    if (!family) {\n      const out = await safeCommand();\n      family = familyFromCommand(out);\n    }\n  }\n  return family;\n};\n\n/**\n * Returns the libc family when it can be determined, `null` otherwise.\n * @returns {?string}\n */\nconst familySync = () => {\n  let family = null;\n  if (isLinux()) {\n    family = familyFromReport();\n    if (!family) {\n      const out = safeCommandSync();\n      family = familyFromCommand(out);\n    }\n  }\n  return family;\n};\n\n/**\n * Resolves `true` only when the platform is Linux and the libc family is not `glibc`.\n * @returns {Promise<boolean>}\n */\nconst isNonGlibcLinux = async () => isLinux() && await family() !== GLIBC;\n\n/**\n * Returns `true` only when the platform is Linux and the libc family is not `glibc`.\n * @returns {boolean}\n */\nconst isNonGlibcLinuxSync = () => isLinux() && familySync() !== GLIBC;\n\nconst versionFromReport = () => {\n  const report = getReport();\n  if (report.header && report.header.glibcVersionRuntime) {\n    return report.header.glibcVersionRuntime;\n  }\n  return null;\n};\n\nconst versionSuffix = (s) => s.trim().split(/\\s+/)[1];\n\nconst versionFromCommand = (out) => {\n  const [getconf, ldd1, ldd2] = out.split(/[\\r\\n]+/);\n  if (getconf && getconf.includes(GLIBC)) {\n    return versionSuffix(getconf);\n  }\n  if (ldd1 && ldd2 && ldd1.includes(MUSL)) {\n    return versionSuffix(ldd2);\n  }\n  return null;\n};\n\n/**\n * Resolves with the libc version when it can be determined, `null` otherwise.\n * @returns {Promise<?string>}\n */\nconst version = async () => {\n  let version = null;\n  if (isLinux()) {\n    version = versionFromReport();\n    if (!version) {\n      const out = await safeCommand();\n      version = versionFromCommand(out);\n    }\n  }\n  return version;\n};\n\n/**\n * Returns the libc version when it can be determined, `null` otherwise.\n * @returns {?string}\n */\nconst versionSync = () => {\n  let version = null;\n  if (isLinux()) {\n    version = versionFromReport();\n    if (!version) {\n      const out = safeCommandSync();\n      version = versionFromCommand(out);\n    }\n  }\n  return version;\n};\n\nmodule.exports = {\n  GLIBC,\n  MUSL,\n  family,\n  familySync,\n  isNonGlibcLinux,\n  isNonGlibcLinuxSync,\n  version,\n  versionSync\n};\n","'use strict';\n\nconst isLinux = () => process.platform === 'linux';\n\nlet report = null;\nconst getReport = () => {\n  if (!report) {\n    /* istanbul ignore next */\n    report = isLinux() && process.report\n      ? process.report.getReport()\n      : {};\n  }\n  return report;\n};\n\nmodule.exports = { isLinux, getReport };\n","var fs = require('fs')\nvar path = require('path')\nvar url = require('url')\n\nvar vars = (process.config && process.config.variables) || {}\nvar prebuildsOnly = !!process.env.PREBUILDS_ONLY\nvar versions = process.versions\nvar abi = versions.modules\nif (versions.deno || process.isBun) {\n  // both Deno and Bun made the very poor decision to shoot themselves in the foot and lie about support for ABI\n  // (which they do not have)\n  abi = 'unsupported'\n}\nvar runtime = isElectron() ? 'electron' : 'node'\nvar arch = process.arch\nvar platform = process.platform\nvar libc = process.env.LIBC || (isMusl(platform) ? 'musl' : 'glibc')\nvar armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || ''\nvar uv = (versions.uv || '').split('.')[0]\n\nmodule.exports = load\n\nfunction load (dir) {\n  // Workaround to fix webpack's build warnings: 'the request of a dependency is an expression', but without\n  // reassigning require in a way that breaks Bun.\n  if (typeof __webpack_require__ === 'function')\n    return __non_webpack_require__(load.path(dir))\n  else\n    return require(load.path(dir))\n}\n\nload.path = function (dir) {\n  dir = path.resolve(dir || '.')\n  var packageName\n  try {\n    // explanation above\n    if (typeof __webpack_require__ === 'function')\n      packageName = __non_webpack_require__(path.join(dir, 'package.json')).name\n    else\n      packageName = require(path.join(dir, 'package.json')).name\n    var varName = packageName.toUpperCase().replace(/-/g, '_') + '_PREBUILD'\n    if (process.env[varName]) dir = process.env[varName]\n  } catch (err) {}\n  if (!prebuildsOnly) {\n    var release = getFirst(path.join(dir, 'build/Release'), matchBuild)\n    if (release) return release\n\n    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild)\n    if (debug) return debug\n  }\n\n  var prebuild = resolve(dir)\n  if (prebuild) return prebuild\n\n  var nearby = resolve(path.dirname(process.execPath))\n  if (nearby) return nearby\n\n  var platformPackage = (packageName[0] == '@' ? '' : '@' + packageName + '/') + packageName + '-' + platform + '-' + arch\n  try {\n    var prebuildPackage = path.dirname(require('module').createRequire(url.pathToFileURL(path.join(dir, 'package.json'))).resolve(platformPackage))\n    return resolveFile(prebuildPackage)\n  } catch(error) {}\n\n  var target = [\n    'platform=' + platform,\n    'arch=' + arch,\n    'runtime=' + runtime,\n    'abi=' + abi,\n    'uv=' + uv,\n    armv ? 'armv=' + armv : '',\n    'libc=' + libc,\n    'node=' + process.versions.node,\n    process.versions.electron ? 'electron=' + process.versions.electron : '',\n    typeof __webpack_require__ === 'function' ? 'webpack=true' : '' // eslint-disable-line\n  ].filter(Boolean).join(' ')\n\n  throw new Error('No native build was found for ' + target + '\\n    loaded from: ' + dir + ' and package: ' + platformPackage + '\\n')\n\n  function resolve (dir) {\n    // Find matching \"prebuilds/<platform>-<arch>\" directory\n    var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple)\n    var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0]\n    if (!tuple) return\n    return resolveFile(path.join(dir, 'prebuilds', tuple.name))\n  }\n  function resolveFile (prebuilds) {\n    // Find most specific flavor first\n    var parsed = readdirSync(prebuilds).map(parseTags)\n    var candidates = parsed.filter(matchTags(runtime, abi))\n    var winner = candidates.sort(compareTags(runtime))[0]\n    if (winner) return path.join(prebuilds, winner.file)\n  }\n}\n\nfunction readdirSync (dir) {\n  try {\n    return fs.readdirSync(dir)\n  } catch (err) {\n    return []\n  }\n}\n\nfunction getFirst (dir, filter) {\n  var files = readdirSync(dir).filter(filter)\n  return files[0] && path.join(dir, files[0])\n}\n\nfunction matchBuild (name) {\n  return /\\.node$/.test(name)\n}\n\nfunction parseTuple (name) {\n  // Example: darwin-x64+arm64\n  var arr = name.split('-')\n  if (arr.length !== 2) return\n\n  var platform = arr[0]\n  var architectures = arr[1].split('+')\n\n  if (!platform) return\n  if (!architectures.length) return\n  if (!architectures.every(Boolean)) return\n\n  return { name, platform, architectures }\n}\n\nfunction matchTuple (platform, arch) {\n  return function (tuple) {\n    if (tuple == null) return false\n    if (tuple.platform !== platform) return false\n    return tuple.architectures.includes(arch)\n  }\n}\n\nfunction compareTuples (a, b) {\n  // Prefer single-arch prebuilds over multi-arch\n  return a.architectures.length - b.architectures.length\n}\n\nfunction parseTags (file) {\n  var arr = file.split('.')\n  var extension = arr.pop()\n  var tags = { file: file, specificity: 0 }\n\n  if (extension !== 'node') return\n\n  for (var i = 0; i < arr.length; i++) {\n    var tag = arr[i]\n\n    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {\n      tags.runtime = tag\n    } else if (tag === 'napi') {\n      tags.napi = true\n    } else if (tag.slice(0, 3) === 'abi') {\n      tags.abi = tag.slice(3)\n    } else if (tag.slice(0, 2) === 'uv') {\n      tags.uv = tag.slice(2)\n    } else if (tag.slice(0, 4) === 'armv') {\n      tags.armv = tag.slice(4)\n    } else if (tag === 'glibc' || tag === 'musl') {\n      tags.libc = tag\n    } else {\n      continue\n    }\n\n    tags.specificity++\n  }\n\n  return tags\n}\n\nfunction matchTags (runtime, abi) {\n  return function (tags) {\n    if (tags == null) return false\n    if (tags.runtime !== runtime && !runtimeAgnostic(tags)) return false\n    if (tags.abi !== abi && !tags.napi) return false\n    if (tags.uv && tags.uv !== uv) return false\n    if (tags.armv && tags.armv !== armv) return false\n    if (tags.libc && tags.libc !== libc) return false\n\n    return true\n  }\n}\n\nfunction runtimeAgnostic (tags) {\n  return tags.runtime === 'node' && tags.napi\n}\n\nfunction compareTags (runtime) {\n  // Precedence: non-agnostic runtime, abi over napi, then by specificity.\n  return function (a, b) {\n    if (a.runtime !== b.runtime) {\n      return a.runtime === runtime ? -1 : 1\n    } else if (a.abi !== b.abi) {\n      return a.abi ? -1 : 1\n    } else if (a.specificity !== b.specificity) {\n      return a.specificity > b.specificity ? -1 : 1\n    } else {\n      return 0\n    }\n  }\n}\n\nfunction isElectron () {\n  if (process.versions && process.versions.electron) return true\n  if (process.env.ELECTRON_RUN_AS_NODE) return true\n  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer'\n}\n\nfunction isMusl (platform) {\n  if (platform !== 'linux') return false;\n  const { familySync, MUSL } = require('detect-libc');\n  return familySync() === MUSL;\n}\n\n// Exposed for unit tests\n// TODO: move to lib\nload.parseTags = parseTags\nload.matchTags = matchTags\nload.compareTags = compareTags\nload.parseTuple = parseTuple\nload.matchTuple = matchTuple\nload.compareTuples = compareTuples","module.exports = require(\"child_process\");","module.exports = require(\"fs\");","module.exports = require(\"module\");","module.exports = require(\"path\");","module.exports = require(\"url\");","/*\ncontrol character types:\n1 - metadata\n2 - symbols\n6 - false\n7 - true\n8- 16 - negative doubles\n16-24 positive doubles\n27 - String starts with a character 27 or less or is an empty string\n0 - multipart separator\n> 27 normal string characters\n*/\n/*\n* Convert arbitrary scalar values to buffer bytes with type preservation and type-appropriate ordering\n*/\n\nconst float64Array = new Float64Array(2)\nconst int32Array = new Int32Array(float64Array.buffer, 0, 4)\nlet nullTerminate = false\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\n\n/*\n* Convert arbitrary scalar values to buffer bytes with type preservation and type-appropriate ordering\n*/\nexport function writeKey(key, target, position, inSequence) {\n\tlet targetView = target.dataView\n\tif (!targetView)\n\t\ttargetView  = target.dataView = new DataView(target.buffer, target.byteOffset, ((target.byteLength + 3) >> 2) << 2)\n\tswitch (typeof key) {\n\tcase 'string':\n\t\tlet strLength = key.length\n\t\tlet c1 = key.charCodeAt(0)\n\t\tif (!(c1 >= 28)) // escape character\n\t\t\ttarget[position++] = 27\n\t\tif (strLength < 0x40) {\n\t\t\tlet i, c2\n\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\tc1 = key.charCodeAt(i)\n\t\t\t\tif (c1 <= 4) {\n\t\t\t\t\ttarget[position++] = 4\n\t\t\t\t\ttarget[position++] = c1\n\t\t\t\t} else if (c1 < 0x80) {\n\t\t\t\t\ttarget[position++] = c1\n\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\ttarget[position++] = c1 >> 6 | 0xc0\n\t\t\t\t\ttarget[position++] = c1 & 0x3f | 0x80\n\t\t\t\t} else if (\n\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t((c2 = key.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t) {\n\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\ti++\n\t\t\t\t\ttarget[position++] = c1 >> 18 | 0xf0\n\t\t\t\t\ttarget[position++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\ttarget[position++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\ttarget[position++] = c1 & 0x3f | 0x80\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = c1 >> 12 | 0xe0\n\t\t\t\t\ttarget[position++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\ttarget[position++] = c1 & 0x3f | 0x80\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (target.utf8Write)\n\t\t\t\tposition += target.utf8Write(key, position)\n\t\t\telse\n\t\t\t\tposition += textEncoder.encodeInto(key, target.subarray(position)).written\n\t\t\tif (position > target.length - 4)\n\t\t\t\tthrow new RangeError('String does not fit in target buffer')\n\t\t}\n\t\tbreak\n\tcase 'number':\n\t\tfloat64Array[0] = key\n\t\tlet lowInt = int32Array[0]\n\t\tlet highInt = int32Array[1]\n\t\tlet length\n\t\tif (key < 0) {\n\t\t\ttargetView.setInt32(position + 4, ~((lowInt >>> 4) | (highInt << 28)))\n\t\t\ttargetView.setInt32(position + 0, (highInt ^ 0x7fffffff) >>> 4)\n\t\t\ttargetView.setInt32(position + 8, ((lowInt & 0xf) ^ 0xf) << 4, true) // just always do the null termination here\n\t\t\treturn position + 9\n\t\t} else if ((lowInt & 0xf) || inSequence) {\n\t\t\tlength = 9\n\t\t} else if (lowInt & 0xfffff)\n\t\t\tlength = 8\n\t\telse if (lowInt || (highInt & 0xf))\n\t\t\tlength = 6\n\t\telse\n\t\t\tlength = 4\n\t\t// switching order to go to little endian\n\t\ttargetView.setInt32(position + 0, (highInt >>> 4) | 0x10000000)\n\t\ttargetView.setInt32(position + 4, (lowInt >>> 4) | (highInt << 28))\n\t\t// if (length == 9 || nullTerminate)\n\t\ttargetView.setInt32(position + 8, (lowInt & 0xf) << 4, true)\n\t\treturn position + length;\n\tcase 'object':\n\t\tif (key) {\n\t\t\tif (Array.isArray(key)) {\n\t\t\t\tfor (let i = 0, l = key.length; i < l; i++) {\n\t\t\t\t\tif (i > 0)\n\t\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\tposition = writeKey(key[i], target, position, true)\n\t\t\t\t}\n\t\t\t\tbreak\n\t\t\t} else if (key instanceof Uint8Array) {\n\t\t\t\ttarget.set(key, position)\n\t\t\t\tposition += key.length\n\t\t\t\tbreak\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unable to serialize object as a key')\n\t\t\t}\n\t\t} else // null\n\t\t\ttarget[position++] = 0\n\t\t\tbreak\n\tcase 'boolean':\n\t\ttargetView.setUint32(position++, key ? 7 : 6, true)\n\t\treturn position\n\tcase 'bigint':\n\t\treturn writeKey(Number(key), target, position, inSequence)\n\tcase 'undefined':\n\t\treturn position\n\t// undefined is interpreted as the absence of a key, signified by zero length\n\tcase 'symbol':\n\t\ttarget[position++] = 2\n\t\treturn writeKey(key.description, target, position, inSequence)\n\tdefault:\n\t\tthrow new Error('Can not serialize key of type ' + typeof key)\n\t}\n\tif (nullTerminate && !inSequence)\n\t\ttargetView.setUint32(position, 0)\n\treturn position\n}\n\nlet position\nexport function readKey(buffer, start, end, inSequence) {\n\tbuffer[end] = 0 // make sure it is null terminated\n\tposition = start\n\tlet controlByte = buffer[position]\n\tlet value\n\tif (controlByte < 24) {\n\tif (controlByte < 8) {\n\t\tposition++\n\t\tif (controlByte == 6) {\n\t\t\tvalue = false\n\t\t} else if (controlByte == 7) {\n\t\t\tvalue = true\n\t\t} else if (controlByte == 0) {\n\t\t\tvalue = null\n\t\t} else if (controlByte == 2) {\n\t\t\tvalue = Symbol.for(readString(buffer))\n\t\t} else\n\t\t\treturn Uint8Array.prototype.slice.call(buffer, start, end)\n\t} else {\n\t\tlet dataView = buffer.dataView || (buffer.dataView = new DataView(buffer.buffer, buffer.byteOffset, ((buffer.byteLength + 3) >> 2) << 2))\n\t\tlet highInt = dataView.getInt32(position) << 4\n\t\tlet size = end - position\n\t\tlet lowInt\n\t\tif (size > 4) {\n\t\t\tlowInt = dataView.getInt32(position + 4)\n\t\t\thighInt |= lowInt >>> 28\n\t\t\tif (size <= 6) { // clear the last bits\n\t\t\t\tlowInt &= -0x1000\n\t\t\t}\n\t\t\tlowInt = lowInt << 4\n\t\t\tif (size > 8) {\n\t\t\t\tlowInt = lowInt | buffer[position + 8] >> 4\n\t\t\t}\n\t\t} else\n\t\t\tlowInt = 0\n\t\tif (controlByte < 16) {\n\t\t\t// negative gets negated\n\t\t\thighInt = highInt ^ 0x7fffffff\n\t\t\tlowInt = ~lowInt\n\t\t}\n\t\tint32Array[1] = highInt\n\t\tint32Array[0] = lowInt\n\t\tvalue = float64Array[0]\n\t\tposition += 9\n\t}\n\t} else {\n\t\tif (controlByte == 27) {\n\t\t\tposition++\n\t\t}\n\t\tvalue = readString(buffer)\n\t\t/*let strStart = position\n\t\tlet strEnd = end\n\t\tfor (; position < end; position++) {\n\t\t\tif (buffer[position] == 0) {\n\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tvalue = buffer.toString('utf8', strStart, position++)*/\n\t}\n\twhile (position < end) {\n\t\tif (buffer[position] === 0)\n\t\t\tposition++\n\t\tif (inSequence) {\n\t\t\tencoder.position = position\n\t\t\treturn value\n\t\t}\n\t\tlet nextValue = readKey(buffer, position, end, true)\n\t\tif (value instanceof Array) {\n\t\t\tvalue.push(nextValue)\n\t\t} else\n\t\t\tvalue = [ value, nextValue ]\n\t}\n\treturn value\n}\nexport const enableNullTermination = () => nullTerminate = true\n\nexport const encoder = {\n\twriteKey,\n\treadKey,\n\tenableNullTermination,\n}\nlet targetBuffer = []\nlet targetPosition = 0\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ? Buffer.allocUnsafeSlow : Uint8Array\nexport const toBufferKey = (key) => {\n\tlet newBuffer\n\tif (targetPosition + 100 > targetBuffer.length) {\n\t\ttargetBuffer = new ByteArrayAllocate(8192)\n\t\ttargetPosition = 0\n\t\tnewBuffer = true\n\t}\n\ttry {\n\t\tlet result = targetBuffer.slice(targetPosition, targetPosition = writeKey(key, targetBuffer, targetPosition))\n\t\tif (targetPosition > targetBuffer.length) {\n\t\t\tif (newBuffer)\n\t\t\t\tthrow new Error('Key is too large')\n\t\t\treturn toBufferKey(key)\n\t\t}\n\t\treturn result\n\t} catch(error) {\n\t\tif (newBuffer)\n\t\t\tthrow error\n\t\ttargetPosition = targetBuffer.length\n\t\treturn toBufferKey(key)\n\t}\n}\nexport const fromBufferKey = (sourceBuffer) => {\n\treturn readKey(sourceBuffer, 0, sourceBuffer.length)\n}\nconst fromCharCode = String.fromCharCode\nfunction makeStringBuilder() {\n\tlet stringBuildCode = '(source) => {'\n\tlet previous = []\n\tfor (let i = 0; i < 0x30; i++) {\n\t\tlet v = fromCharCode((i & 0xf) + 97) + fromCharCode((i >> 4) + 97)\n\t\tstringBuildCode += `\n\t\tlet ${v} = source[position++]\n\t\tif (${v} > 4) {\n\t\t\tif (${v} >= 0x80) ${v} = finishUtf8(${v}, source)\n\t\t} else {\n\t\t\tif (${v} === 4)\n\t\t\t\t${v} = source[position++]\n\t\t\telse\n\t\t\t\treturn fromCharCode(${previous})\n\t\t}\n\t\t`\n\t\tprevious.push(v)\n\t\tif (i == 1000000) // this just exists to prevent rollup from doing dead code elimination on finishUtf8\n\t\t\tfinishUtf8()\n\t}\n\tstringBuildCode += `return fromCharCode(${previous}) + readString(source)}`\n\treturn stringBuildCode\n}\n\nlet pendingSurrogate\nfunction finishUtf8(byte1, src) {\n\tif ((byte1 & 0xe0) === 0xc0) {\n\t\t// 2 bytes\n\t\tconst byte2 = src[position++] & 0x3f\n\t\treturn ((byte1 & 0x1f) << 6) | byte2\n\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t// 3 bytes\n\t\tconst byte2 = src[position++] & 0x3f\n\t\tconst byte3 = src[position++] & 0x3f\n\t\treturn ((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3\n\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t// 4 bytes\n\t\tif (pendingSurrogate) {\n\t\tbyte1 = pendingSurrogate\n\t\tpendingSurrogate = null\n\t\tposition += 3\n\t\treturn byte1\n\t\t}\n\t\tconst byte2 = src[position++] & 0x3f\n\t\tconst byte3 = src[position++] & 0x3f\n\t\tconst byte4 = src[position++] & 0x3f\n\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\tif (unit > 0xffff) {\n\t\tunit -= 0x10000\n\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\tpendingSurrogate = ((unit >>> 10) & 0x3ff) | 0xd800\n\t\tposition -= 4 // reset so we can return the next part of the surrogate pair\n\t\t}\n\t\treturn unit\n\t} else {\n\t\treturn byte1\n\t}\n}\n\nconst readString = eval(makeStringBuilder())\n\nexport function compareKeys(a, b) {\n\t// compare with type consistency that matches binary comparison\n\tif (typeof a == 'object') {\n\t\tif (!a) {\n\t\t\treturn b == null ? 0 : -1\n\t\t}\n\t\tif (a.compare) {\n\t\t\tif (b == null) {\n\t\t\t\treturn 1\n\t\t\t} else if (b.compare) {\n\t\t\t\treturn a.compare(b)\n\t\t\t} else {\n\t\t\t\treturn -1\n\t\t\t}\n\t\t}\n\t\tlet arrayComparison\n\t\tif (b instanceof Array) {\n\t\t\tlet i = 0\n\t\t\twhile((arrayComparison = compareKeys(a[i], b[i])) == 0 && i <= a.length)  {\n\t\t\t\ti++\n\t\t\t}\n\t\t\treturn arrayComparison\n\t\t}\n\t\tarrayComparison = compareKeys(a[0], b)\n\t\tif (arrayComparison == 0 && a.length > 1)\n\t\t\treturn 1\n\t\treturn arrayComparison\n\t} else if (typeof a == typeof b) {\n\t\tif (typeof a === 'symbol') {\n\t\t\ta = Symbol.keyFor(a)\n\t\t\tb = Symbol.keyFor(b)\n\t\t}\n\t\treturn a < b ? -1 : a === b ? 0 : 1\n\t}\n\telse if (typeof b == 'object') {\n\t\tif (b instanceof Array)\n\t\t\treturn -compareKeys(b, a)\n\t\treturn 1\n\t} else {\n\t\treturn typeOrder[typeof a] < typeOrder[typeof b] ? -1 : 1\n\t}\n}\nconst typeOrder = {\n\tsymbol: 0,\n\tundefined: 1,\n\tboolean: 2,\n\tnumber: 3,\n\tstring: 4\n}\nexport const MINIMUM_KEY = null\nexport const MAXIMUM_KEY = new Uint8Array([0xff])","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { dirname, join, default as pathModule } from 'path';\nimport { fileURLToPath } from 'url';\nimport loadNAPI from 'node-gyp-build-optional-packages';\nexport let Env, Txn, Dbi, Compression, Cursor, getAddress, getBufferAddress, createBufferForAddress, clearKeptObjects, globalBuffer, setGlobalBuffer, arch, fs, os, onExit, tmpdir, lmdbError, path, EventEmitter, orderedBinary, MsgpackrEncoder, WeakLRUCache, setEnvMap, getEnvMap, getByBinary, detachBuffer, startRead, setReadCallback, write, position, iterate, prefetch, resetTxn, getCurrentValue, getCurrentShared, getStringByBinary, getSharedByBinary, getSharedBuffer, compress;\npath = pathModule;\nlet dirName = dirname(fileURLToPath(import.meta.url)).replace(/dist$/, '');\nexport let nativeAddon = loadNAPI(dirName);\n\nif (process.isBun && false) {\n\tconst { linkSymbols, FFIType } = require('bun:ffi');\n\tlet lmdbLib = linkSymbols({\n\t\tgetByBinary: {\n\t\t\targs: [FFIType.f64, FFIType.u32],\n\t\t\treturns: FFIType.u32,\n\t\t\tptr: nativeAddon.getByBinaryPtr\n\t\t},\n\t\titerate: {\n\t\t\targs: [FFIType.f64],\n\t\t\treturns: FFIType.i32,\n\t\t\tptr: nativeAddon.iteratePtr,\n\t\t},\n\t\tposition: {\n\t\t\targs: [FFIType.f64, FFIType.u32, FFIType.u32, FFIType.u32, FFIType.f64],\n\t\t\treturns: FFIType.i32,\n\t\t\tptr: nativeAddon.positionPtr,\n\t\t},\n\t\twrite: {\n\t\t\targs: [FFIType.f64, FFIType.f64],\n\t\t\treturns: FFIType.i32,\n\t\t\tptr: nativeAddon.writePtr,\n\t\t},\n\t\tresetTxn: {\n\t\t\targs: [FFIType.f64],\n\t\t\treturns: FFIType.void,\n\t\t\tptr: nativeAddon.resetTxnPtr,\n\t\t}\n\t});\n\tfor (let key in lmdbLib.symbols) {\n\t\tnativeAddon[key] = lmdbLib.symbols[key].native;\n\t}\n}\nsetNativeFunctions(nativeAddon);\n\t\nexport function setNativeFunctions(externals) {\n\tEnv = externals.Env;\n\tTxn = externals.Txn;\n\tDbi = externals.Dbi;\n\tCompression = externals.Compression;\n\tgetAddress = externals.getAddress;\n\tgetBufferAddress = externals.getBufferAddress;\n\tcreateBufferForAddress = externals.createBufferForAddress;\n\tclearKeptObjects = externals.clearKeptObjects || function() {};\n\tgetByBinary = externals.getByBinary;\n\tdetachBuffer  = externals.detachBuffer;\n\tstartRead = externals.startRead;\n\tsetReadCallback = externals.setReadCallback;\n\tsetGlobalBuffer = externals.setGlobalBuffer;\n\tglobalBuffer = externals.globalBuffer;\n\tgetSharedBuffer = externals.getSharedBuffer;\n\tprefetch = externals.prefetch;\n\titerate = externals.iterate;\n\tposition = externals.position;\n\tresetTxn = externals.resetTxn;\n\tgetCurrentValue = externals.getCurrentValue;\n\tgetCurrentShared = externals.getCurrentShared;\n\tgetStringByBinary = externals.getStringByBinary;\n\tgetSharedByBinary = externals.getSharedByBinary;\n\twrite = externals.write;\n\tcompress = externals.compress;\n\tCursor = externals.Cursor;\n\tlmdbError = externals.lmdbError;\n\tif (externals.tmpdir)\n        tmpdir = externals.tmpdir\n}\nexport function setExternals(externals) {\n\tarch = externals.arch;\n\tfs = externals.fs;\n\tEventEmitter = externals.EventEmitter;\n\torderedBinary = externals.orderedBinary;\n\tMsgpackrEncoder = externals.MsgpackrEncoder;\n\tWeakLRUCache = externals.WeakLRUCache;\n\ttmpdir = externals.tmpdir;\n   os = externals.os;\n\tonExit = externals.onExit;\n}\n","export function when(promise, callback, errback) {\n  if (promise && promise.then) {\n    return errback ?\n      promise.then(callback, errback) :\n      promise.then(callback);\n  }\n  return callback(promise);\n}\n","import { getAddress, getBufferAddress, write, compress, lmdbError } from './native.js';\nimport { when } from './util/when.js';\nvar backpressureArray;\n\nconst WAITING_OPERATION = 0x2000000;\nconst BACKPRESSURE_THRESHOLD = 300000;\nconst TXN_DELIMITER = 0x8000000;\nconst TXN_COMMITTED = 0x10000000;\nconst TXN_FLUSHED = 0x20000000;\nconst TXN_FAILED = 0x40000000;\nexport const FAILED_CONDITION = 0x4000000;\nconst REUSE_BUFFER_MODE = 512;\nconst RESET_BUFFER_MODE = 1024;\nconst NO_RESOLVE = 16;\nconst HAS_TXN = 8;\nconst CONDITIONAL_VERSION_LESS_THAN = 0x800;\nconst CONDITIONAL_ALLOW_NOTFOUND = 0x800;\n\nconst SYNC_PROMISE_SUCCESS = Promise.resolve(true);\nconst SYNC_PROMISE_FAIL = Promise.resolve(false);\nSYNC_PROMISE_SUCCESS.isSync = true;\nSYNC_PROMISE_FAIL.isSync = true;\nconst PROMISE_SUCCESS = Promise.resolve(true);\nexport const ABORT = 4.452694326329068e-106; // random/unguessable numbers, which work across module/versions and native\nexport const IF_EXISTS = 3.542694326329068e-103;\nconst CALLBACK_THREW = {};\nconst LocalSharedArrayBuffer = typeof Deno != 'undefined' ? ArrayBuffer : SharedArrayBuffer; // Deno can't handle SharedArrayBuffer as an FFI argument due to https://github.com/denoland/deno/issues/12678\nconst ByteArray = typeof Buffer != 'undefined' ? function(buffer) { return Buffer.from(buffer) } : Uint8Array;\nconst queueTask = typeof setImmediate != 'undefined' ? setImmediate : setTimeout; // TODO: Or queueMicrotask?\n//let debugLog = []\nconst WRITE_BUFFER_SIZE = 0x10000;\nvar log = [];\nexport function addWriteMethods(LMDBStore, { env, fixedBuffer, resetReadTxn, useWritemap, maxKeySize,\n\teventTurnBatching, txnStartThreshold, batchStartThreshold, overlappingSync, commitDelay, separateFlushed, maxFlushDelay }) {\n\t//  stands for write instructions\n\tvar dynamicBytes;\n\tfunction allocateInstructionBuffer(lastPosition) {\n\t\t// Must use a shared buffer on older node in order to use Atomics, and it is also more correct since we are \n\t\t// indeed accessing and modifying it from another thread (in C). However, Deno can't handle it for\n\t\t// FFI so aliased above\n\t\tlet buffer = new LocalSharedArrayBuffer(WRITE_BUFFER_SIZE);\n\t\tlet lastBytes = dynamicBytes;\n\t\tdynamicBytes = new ByteArray(buffer);\n\t\tlet uint32 = dynamicBytes.uint32 = new Uint32Array(buffer, 0, WRITE_BUFFER_SIZE >> 2);\n\t\tuint32[2] = 0;\n\t\tdynamicBytes.float64 = new Float64Array(buffer, 0, WRITE_BUFFER_SIZE >> 3);\n\t\tbuffer.address = getBufferAddress(dynamicBytes);\n\t\tuint32.address = buffer.address + uint32.byteOffset;\n\t\tdynamicBytes.position = 1; // we start at position 1 to save space for writing the txn id before the txn delimiter\n\t\tif (lastPosition) {\n\t\t\tlastBytes.float64[lastPosition + 1] = dynamicBytes.uint32.address + (dynamicBytes.position << 3);\n\t\t\tlastBytes.uint32[lastPosition << 1] = 3; // pointer instruction\n\t\t}\n\t\treturn dynamicBytes;\n\t}\n\tvar newBufferThreshold = (WRITE_BUFFER_SIZE - maxKeySize - 64) >> 3; // need to reserve more room if we do inline values\n\tvar outstandingWriteCount = 0;\n\tvar startAddress = 0;\n\tvar writeTxn = null;\n\tvar committed;\n\tvar abortedNonChildTransactionWarn;\n\tvar nextTxnCallbacks = [];\n\tvar commitPromise, flushPromise, flushResolvers = [], batchFlushResolvers = [];\n\tcommitDelay = commitDelay || 0;\n\teventTurnBatching = eventTurnBatching === false ? false : true;\n\tvar enqueuedCommit;\n\tvar afterCommitCallbacks = [];\n\tvar beforeCommitCallbacks = [];\n\tvar enqueuedEventTurnBatch;\n\tvar batchDepth = 0;\n\tvar lastWritePromise;\n\tvar writeBatchStart, outstandingBatchCount, lastSyncTxnFlush, lastFlushTimeout, lastFlushCallback;\n\tvar hasUnresolvedTxns;\n\ttxnStartThreshold = txnStartThreshold || 5;\n\tbatchStartThreshold = batchStartThreshold || 1000;\n\tmaxFlushDelay = maxFlushDelay || 500;\n\n\tallocateInstructionBuffer();\n\tdynamicBytes.uint32[2] = TXN_DELIMITER | TXN_COMMITTED | TXN_FLUSHED;\n\tvar txnResolution, nextResolution = {\n\t\tuint32: dynamicBytes.uint32, flagPosition: 2, flag: 0, valueBuffer: null, next: null, meta: null };\n\tvar uncommittedResolution = {\n\t\tuint32: null, flagPosition: 2, flag: 0, valueBuffer: null, next: nextResolution, meta: null };\n\tvar unwrittenResolution = nextResolution;\n\tvar lastPromisedResolution = uncommittedResolution;\n\tvar lastQueuedResolution = uncommittedResolution;\n\tfunction writeInstructions(flags, store, key, value, version, ifVersion) {\n\t\tlet writeStatus;\n\t\tlet targetBytes, position, encoder;\n\t\tlet valueSize, valueBuffer, valueBufferStart;\n\t\tif (flags & 2) {\n\t\t\t// encode first in case we have to write a shared structure\n\t\t\tencoder = store.encoder;\n\t\t\tif (value && value['\\x10binary-data\\x02'])\n\t\t\t\tvalueBuffer = value['\\x10binary-data\\x02'];\n\t\t\telse if (encoder) {\n\t\t\t\tif (encoder.copyBuffers) // use this as indicator for support buffer reuse for now\n\t\t\t\t\tvalueBuffer = encoder.encode(value, REUSE_BUFFER_MODE | (writeTxn ? RESET_BUFFER_MODE : 0)); // in addition, if we are writing sync, after using, we can immediately reset the encoder's position to reuse that space, which can improve performance\n\t\t\t\telse { // various other encoders, including JSON.stringify, that might serialize to a string\n\t\t\t\t\tvalueBuffer = encoder.encode(value);\n\t\t\t\t\tif (typeof valueBuffer == 'string')\n\t\t\t\t\t\tvalueBuffer = Buffer.from(valueBuffer); // TODO: Would be nice to write strings inline in the instructions\n\t\t\t\t}\n\t\t\t} else if (typeof value == 'string') {\n\t\t\t\tvalueBuffer = Buffer.from(value); // TODO: Would be nice to write strings inline in the instructions\n\t\t\t} else if (value instanceof Uint8Array)\n\t\t\t\tvalueBuffer = value;\n\t\t\telse\n\t\t\t\tthrow new Error('Invalid value to put in database ' + value + ' (' + (typeof value) +'), consider using encoder');\n\t\t\tvalueBufferStart = valueBuffer.start;\n\t\t\tif (valueBufferStart > -1) // if we have buffers with start/end position\n\t\t\t\tvalueSize = valueBuffer.end - valueBufferStart; // size\n\t\t\telse\n\t\t\t\tvalueSize = valueBuffer.length;\n\t\t\tif (store.dupSort && valueSize > maxKeySize)\n\t\t\t\tthrow new Error('The value is larger than the maximum size (' + maxKeySize + ') for a value in a dupSort database');\n\t\t} else\n\t\t\tvalueSize = 0;\n\t\tif (writeTxn) {\n\t\t\ttargetBytes = fixedBuffer;\n\t\t\tposition = 0;\n\t\t} else {\n\t\t\tif (eventTurnBatching && !enqueuedEventTurnBatch && batchDepth == 0) {\n\t\t\t\tenqueuedEventTurnBatch = queueTask(() => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfor (let i = 0, l = beforeCommitCallbacks.length; i < l; i++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tbeforeCommitCallbacks[i]();\n\t\t\t\t\t\t\t} catch(error) {\n\t\t\t\t\t\t\t\tconsole.error('In beforecommit callback', error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(error) {\n\t\t\t\t\t\tconsole.error(error);\n\t\t\t\t\t}\n\t\t\t\t\tenqueuedEventTurnBatch = null;\n\t\t\t\t\tbatchDepth--;\n\t\t\t\t\tfinishBatch();\n\t\t\t\t\tif (writeBatchStart)\n\t\t\t\t\t\twriteBatchStart(); // TODO: When we support delay start of batch, optionally don't delay this\n\t\t\t\t});\n\t\t\t\tcommitPromise = null; // reset the commit promise, can't know if it is really a new transaction prior to finishWrite being called\n\t\t\t\tflushPromise = null;\n\t\t\t\twriteBatchStart = writeInstructions(1, store);\n\t\t\t\toutstandingBatchCount = 0;\n\t\t\t\tbatchDepth++;\n\t\t\t}\n\t\t\ttargetBytes = dynamicBytes;\n\t\t\tposition = targetBytes.position;\n\t\t}\n\t\tlet uint32 = targetBytes.uint32, float64 = targetBytes.float64;\n\t\tlet flagPosition = position << 1; // flagPosition is the 32-bit word starting position\n\n\t\t// don't increment position until we are sure we don't have any key writing errors\n\t\tif (!uint32) {\n\t\t\tthrow new Error('Internal buffers have been corrupted');\n\t\t}\n\t\tuint32[flagPosition + 1] = store.db.dbi;\n\t\tif (flags & 4) {\n\t\t\tlet keyStartPosition = (position << 3) + 12;\n\t\t\tlet endPosition;\n\t\t\ttry {\n\t\t\t\tendPosition = store.writeKey(key, targetBytes, keyStartPosition);\n\t\t\t\tif (!(keyStartPosition < endPosition) && (flags & 0xf) != 12)\n\t\t\t\t\tthrow new Error('Invalid key or zero length key is not allowed in LMDB ' + key)\n\t\t\t} catch(error) {\n\t\t\t\ttargetBytes.fill(0, keyStartPosition);\n\t\t\t\tif (error.name == 'RangeError')\n\t\t\t\t\terror = new Error('Key size is larger than the maximum key size (' + maxKeySize + ')');\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t\tlet keySize = endPosition - keyStartPosition;\n\t\t\tif (keySize > maxKeySize) {\n\t\t\t\ttargetBytes.fill(0, keyStartPosition); // restore zeros\n\t\t\t\tthrow new Error('Key size is larger than the maximum key size (' + maxKeySize + ')');\n\t\t\t}\n\t\t\tuint32[flagPosition + 2] = keySize;\n\t\t\tposition = (endPosition + 16) >> 3;\n\t\t\tif (flags & 2) {\n\t\t\t\tlet mustCompress;\n\t\t\t\tif (valueBufferStart > -1) { // if we have buffers with start/end position\n\t\t\t\t\t// record pointer to value buffer\n\t\t\t\t\tfloat64[position] = (valueBuffer.address ||\n\t\t\t\t\t\t(valueBuffer.address = getAddress(valueBuffer.buffer))) + valueBufferStart;\n\t\t\t\t\tmustCompress = valueBuffer[valueBufferStart] >= 250; // this is the compression indicator, so we must compress\n\t\t\t\t} else {\n\t\t\t\t\tlet valueArrayBuffer = valueBuffer.buffer;\n\t\t\t\t\t// record pointer to value buffer\n\t\t\t\t\tlet address = (valueArrayBuffer.address ||\n\t\t\t\t\t\t(valueBuffer.length === 0 ? 0 : // externally allocated buffers of zero-length with the same non-null-pointer can crash node, #161\n\t\t\t\t\t\tvalueArrayBuffer.address = getAddress(valueArrayBuffer)))\n\t\t\t\t\t\t\t+ valueBuffer.byteOffset;\n\t\t\t\t\tif (address <= 0 && valueBuffer.length > 0)\n\t\t\t\t\t\tconsole.error('Supplied buffer had an invalid address', address);\n\t\t\t\t\tfloat64[position] = address;\n\t\t\t\t\tmustCompress = valueBuffer[0] >= 250; // this is the compression indicator, so we must compress\n\t\t\t\t}\n\t\t\t\tuint32[(position++ << 1) - 1] = valueSize;\n\t\t\t\tif (store.compression && (valueSize >= store.compression.threshold || mustCompress)) {\n\t\t\t\t\tflags |= 0x100000;\n\t\t\t\t\tfloat64[position] = store.compression.address;\n\t\t\t\t\tif (!writeTxn)\n\t\t\t\t\t\tcompress(env.address, uint32.address + (position << 3), () => {\n\t\t\t\t\t\t\t// this is never actually called in NodeJS, just use to pin the buffer in memory until it is finished\n\t\t\t\t\t\t\t// and is a no-op in Deno\n\t\t\t\t\t\t\tif (!float64)\n\t\t\t\t\t\t\t\tthrow new Error('No float64 available');\n\t\t\t\t\t\t});\n\t\t\t\t\tposition++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ifVersion !== undefined) {\n\t\t\t\tif (ifVersion === null)\n\t\t\t\t\tflags |= 0x10; // if it does not exist, MDB_NOOVERWRITE\n\t\t\t\telse {\n\t\t\t\t\tflags |= 0x100;\n\t\t\t\t\tfloat64[position++] = ifVersion;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (version !== undefined) {\n\t\t\t\tflags |= 0x200;\n\t\t\t\tfloat64[position++] = version || 0;\n\t\t\t}\n\t\t} else\n\t\t\tposition++;\n\t\ttargetBytes.position = position;\n\t\tif (writeTxn) {\n\t\t\tuint32[0] = flags;\n\t\t\twrite(env.address, uint32.address);\n\t\t\treturn () => (uint32[0] & FAILED_CONDITION) ? SYNC_PROMISE_FAIL : SYNC_PROMISE_SUCCESS;\n\t\t}\n\t\t// if we ever use buffers that haven't been zero'ed, need to clear out the next slot like this:\n\t\t// uint32[position << 1] = 0 // clear out the next slot\n\t\tlet nextUint32;\n\t\tif (position > newBufferThreshold) {\n\t\t\t// make new buffer and make pointer to it\n\t\t\tlet lastPosition = position;\n\t\t\ttargetBytes = allocateInstructionBuffer(position);\n\t\t\tposition = targetBytes.position;\n\t\t\tnextUint32 = targetBytes.uint32;\n\t\t} else\n\t\t\tnextUint32 = uint32;\n\t\tlet resolution = nextResolution;\n\t\t// create the placeholder next resolution\n\t\tnextResolution = resolution.next = { // we try keep resolutions exactly the same object type\n\t\t\tuint32: nextUint32,\n\t\t\tflagPosition: position << 1,\n\t\t\tflag: 0, // TODO: eventually eliminate this, as we can probably signify HAS_TXN/NO_RESOLVE/FAILED_CONDITION in upper bits\n\t\t\tvalueBuffer: fixedBuffer, // these are all just placeholders so that we have the right hidden class initially allocated\n\t\t\tnext: null,\n\t\t\tmeta: null,\n\t\t};\n\t\tlastQueuedResolution = resolution;\n\n\t\tlet writtenBatchDepth = batchDepth;\n\n\t\treturn (callback) => {\n\t\t\tif (writtenBatchDepth) {\n\t\t\t\t// if we are in a batch, the transaction can't close, so we do the faster,\n\t\t\t\t// but non-deterministic updates, knowing that the write thread can\n\t\t\t\t// just poll for the status change if we miss a status update\n\t\t\t\twriteStatus = uint32[flagPosition];\n\t\t\t\tuint32[flagPosition] = flags;\n\t\t\t\t//writeStatus = Atomics.or(uint32, flagPosition, flags)\n\t\t\t\tif (writeBatchStart && !writeStatus) {\n\t\t\t\t\toutstandingBatchCount += 1 + (valueSize >> 12);\n\t\t\t\t\tif (outstandingBatchCount > batchStartThreshold) {\n\t\t\t\t\t\toutstandingBatchCount = 0;\n\t\t\t\t\t\twriteBatchStart();\n\t\t\t\t\t\twriteBatchStart = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else // otherwise the transaction could end at any time and we need to know the\n\t\t\t\t// deterministically if it is ending, so we can reset the commit promise\n\t\t\t\t// so we use the slower atomic operation\n\t\t\t\twriteStatus = Atomics.or(uint32, flagPosition, flags);\n\t\n\t\t\toutstandingWriteCount++;\n\t\t\tif (writeStatus & TXN_DELIMITER) {\n\t\t\t\tcommitPromise = null; // TODO: Don't reset these if this comes from the batch start operation on an event turn batch\n\t\t\t\tflushPromise = null;\n\t\t\t\tflushResolvers = [];\n\t\t\t\tqueueCommitResolution(resolution);\n\t\t\t\tif (!startAddress) {\n\t\t\t\t\tstartAddress = uint32.address + (flagPosition << 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!writtenBatchDepth && batchFlushResolvers.length > 0) {\n\t\t\t\tflushResolvers.push(...batchFlushResolvers);\n\t\t\t\tbatchFlushResolvers = [];\n\t\t\t}\n\t\t\tif (!flushPromise && overlappingSync) {\n\t\t\t\tflushPromise = new Promise(resolve => {\n\t\t\t\t\tif (writtenBatchDepth) {\n\t\t\t\t\t\tbatchFlushResolvers.push(resolve);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tflushResolvers.push(resolve);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (writeStatus & WAITING_OPERATION) { // write thread is waiting\n\t\t\t\twrite(env.address, 0);\n\t\t\t}\n\t\t\tif (outstandingWriteCount > BACKPRESSURE_THRESHOLD && !writeBatchStart) {\n\t\t\t\tif (!backpressureArray)\n\t\t\t\t\tbackpressureArray = new Int32Array(new SharedArrayBuffer(4), 0, 1);\n\t\t\t\tAtomics.wait(backpressureArray, 0, 0, Math.round(outstandingWriteCount / BACKPRESSURE_THRESHOLD));\n\t\t\t}\n\t\t\tif (startAddress) {\n\t\t\t\tif (eventTurnBatching)\n\t\t\t\t\tstartWriting(); // start writing immediately because this has already been batched/queued\n\t\t\t\telse if (!enqueuedCommit && txnStartThreshold) {\n\t\t\t\t\tenqueuedCommit = (commitDelay == 0 && typeof setImmediate != 'undefined') ? setImmediate(() => startWriting()) : setTimeout(() => startWriting(), commitDelay);\n\t\t\t\t} else if (outstandingWriteCount > txnStartThreshold)\n\t\t\t\t\tstartWriting();\n\t\t\t}\n\n\t\t\tif ((outstandingWriteCount & 7) === 0)\n\t\t\t\tresolveWrites();\n\t\t\t\n\t\t\tif (store.cache) {\n\t\t\t\tresolution.meta = {\n\t\t\t\t\tkey,\n\t\t\t\t\tstore,\n\t\t\t\t\tvalueSize: valueBuffer ? valueBuffer.length : 0,\n\t\t\t\t};\n\t\t\t}\n\t\t\tresolution.valueBuffer = valueBuffer;\n\n\t\t\tif (callback) {\n\t\t\t\tif (callback === IF_EXISTS)\n\t\t\t\t\tifVersion = IF_EXISTS;\n\t\t\t\telse {\n\t\t\t\t\tlet meta = resolution.meta || (resolution.meta = {});\n\t\t\t\t\tmeta.reject = callback;\n\t\t\t\t\tmeta.resolve = (value) => callback(null, value);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ifVersion === undefined) {\n\t\t\t\tif (writtenBatchDepth > 1) {\n\t\t\t\t\tif (!resolution.flag && !store.cache)\n\t\t\t\t\t\tresolution.flag = NO_RESOLVE;\n\t\t\t\t\treturn PROMISE_SUCCESS; // or return undefined?\n\t\t\t\t}\n\t\t\t\tif (commitPromise) {\n\t\t\t\t\tif (!resolution.flag)\n\t\t\t\t\t\tresolution.flag = NO_RESOLVE;\n\t\t\t\t} else {\n\t\t\t\t\tcommitPromise = new Promise((resolve, reject) => {\n\t\t\t\t\t\tlet meta = resolution.meta || (resolution.meta = {});\n\t\t\t\t\t\tmeta.resolve = resolve;\n\t\t\t\t\t\tresolve.unconditional = true;\n\t\t\t\t\t\tmeta.reject = reject;\n\t\t\t\t\t});\n\t\t\t\t\tif (separateFlushed)\n\t\t\t\t\t\tcommitPromise.flushed = overlappingSync ? flushPromise : commitPromise;\n\t\t\t\t}\n\t\t\t\treturn commitPromise;\n\t\t\t}\n\t\t\tlastWritePromise = new Promise((resolve, reject) => {\n\t\t\t\tlet meta = resolution.meta || (resolution.meta = {});\n\t\t\t\tmeta.resolve = resolve;\n\t\t\t\tmeta.reject = reject;\n\t\t\t});\n\t\t\tif (separateFlushed)\n\t\t\t\tlastWritePromise.flushed = overlappingSync ? flushPromise : lastWritePromise;\n\t\t\treturn lastWritePromise;\n\t\t};\n\t}\n\tlet committedFlushResolvers, lastSync = Promise.resolve()\n\tfunction startWriting() {\n\t\tif (enqueuedCommit) {\n\t\t\tclearImmediate(enqueuedCommit);\n\t\t\tenqueuedCommit = null;\n\t\t}\n\t\tlet resolvers = flushResolvers;\n\t\tlet start = Date.now();\n\t\tenv.startWriting(startAddress, (status) => {\n\t\t\tif (dynamicBytes.uint32[dynamicBytes.position << 1] & TXN_DELIMITER)\n\t\t\t\tqueueCommitResolution(nextResolution);\n\n\t\t\tresolveWrites(true);\n\t\t\tswitch (status) {\n\t\t\t\tcase 0:\n\t\t\t\t\tfor (let resolver of resolvers) {\n\t\t\t\t\t\tresolver();\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 1:\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\thasUnresolvedTxns = false;\n\t\t\t\t\texecuteTxnCallbacks();\n\t\t\t\t\treturn hasUnresolvedTxns;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlmdbError(status);\n\t\t\t\t\t} catch(error) {\n\t\t\t\t\t\tconsole.error(error);\n\t\t\t\t\t\tif (commitRejectPromise) {\n\t\t\t\t\t\t\tcommitRejectPromise.reject(error);\n\t\t\t\t\t\t\tcommitRejectPromise = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tstartAddress = 0;\n\t}\n\n\tfunction queueCommitResolution(resolution) {\n\t\tif (!(resolution.flag & HAS_TXN)) {\n\t\t\tresolution.flag = HAS_TXN;\n\t\t\tif (txnResolution) {\n\t\t\t\ttxnResolution.nextTxn = resolution;\n\t\t\t\t//outstandingWriteCount = 0\n\t\t\t}\n\t\t\telse\n\t\t\t\ttxnResolution = resolution;\n\t\t}\n\t}\n\tvar TXN_DONE = TXN_COMMITTED | TXN_FAILED;\n\tfunction resolveWrites(async) {\n\t\t// clean up finished instructions\n\t\tlet instructionStatus;\n\t\twhile ((instructionStatus = unwrittenResolution.uint32[unwrittenResolution.flagPosition])\n\t\t\t\t& 0x1000000) {\n\t\t\tif (unwrittenResolution.callbacks) {\n\t\t\t\tnextTxnCallbacks.push(unwrittenResolution.callbacks);\n\t\t\t\tunwrittenResolution.callbacks = null;\n\t\t\t}\n\t\t\toutstandingWriteCount--;\n\t\t\tif (unwrittenResolution.flag !== HAS_TXN) {\n\t\t\t\tif (unwrittenResolution.flag === NO_RESOLVE && !unwrittenResolution.meta) {\n\t\t\t\t\t// in this case we can completely remove from the linked list, clearing more memory\n\t\t\t\t\tlastPromisedResolution.next = unwrittenResolution = unwrittenResolution.next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tunwrittenResolution.uint32 = null;\n\t\t\t}\n\t\t\tunwrittenResolution.valueBuffer = null;\n\t\t\tunwrittenResolution.flag = instructionStatus;\n\t\t\tlastPromisedResolution = unwrittenResolution;\n\t\t\tunwrittenResolution = unwrittenResolution.next;\n\t\t}\n\t\twhile (txnResolution &&\n\t\t\t(instructionStatus = txnResolution.uint32[txnResolution.flagPosition] & TXN_DONE)) {\n\t\t\tif (instructionStatus & TXN_FAILED)\n\t\t\t\trejectCommit();\n\t\t\telse\n\t\t\t\tresolveCommit(async);\n\t\t}\n\t}\n\n\tfunction resolveCommit(async) {\n\t\tafterCommit(txnResolution.uint32[txnResolution.flagPosition - 1]);\n\t\tif (async)\n\t\t\tresetReadTxn();\n\t\telse\n\t\t\tqueueMicrotask(resetReadTxn); // TODO: only do this if there are actually committed writes?\n\t\tdo {\n\t\t\tif (uncommittedResolution.meta && uncommittedResolution.meta.resolve) {\n\t\t\t\tlet resolve = uncommittedResolution.meta.resolve;\n\t\t\t\tif (uncommittedResolution.flag & FAILED_CONDITION && !resolve.unconditional)\n\t\t\t\t\tresolve(false);\n\t\t\t\telse\n\t\t\t\t\tresolve(true);\n\t\t\t}\n\t\t} while((uncommittedResolution = uncommittedResolution.next) && uncommittedResolution != txnResolution)\n\t\ttxnResolution = txnResolution.nextTxn;\n\t}\n\tvar commitRejectPromise;\n\tfunction rejectCommit() {\n\t\tafterCommit();\n\t\tif (!commitRejectPromise) {\n\t\t\tlet rejectFunction;\n\t\t\tcommitRejectPromise = new Promise((resolve, reject) => rejectFunction = reject);\n\t\t\tcommitRejectPromise.reject = rejectFunction;\n\t\t}\n\t\tdo {\n\t\t\tif (uncommittedResolution.meta && uncommittedResolution.meta.reject) {\n\t\t\t\tlet flag = uncommittedResolution.flag & 0xf;\n\t\t\t\tlet error = new Error(\"Commit failed (see commitError for details)\");\n\t\t\t\terror.commitError = commitRejectPromise;\n\t\t\t\tuncommittedResolution.meta.reject(error);\n\t\t\t}\n\t\t} while((uncommittedResolution = uncommittedResolution.next) && uncommittedResolution != txnResolution)\n\t\ttxnResolution = txnResolution.nextTxn;\n\t}\n\tfunction atomicStatus(uint32, flagPosition, newStatus) {\n\t\tif (batchDepth) {\n\t\t\t// if we are in a batch, the transaction can't close, so we do the faster,\n\t\t\t// but non-deterministic updates, knowing that the write thread can\n\t\t\t// just poll for the status change if we miss a status update\n\t\t\tlet writeStatus = uint32[flagPosition];\n\t\t\tuint32[flagPosition] = newStatus;\n\t\t\treturn writeStatus;\n\t\t\t//return Atomics.or(uint32, flagPosition, newStatus)\n\t\t} else // otherwise the transaction could end at any time and we need to know the\n\t\t\t// deterministically if it is ending, so we can reset the commit promise\n\t\t\t// so we use the slower atomic operation\n\t\t\ttry {\n\t\t\t\treturn Atomics.or(uint32, flagPosition, newStatus);\n\t\t\t} catch(error) {\n\t\t\tconsole.error(error);\n\t\t\treturn;\n\t\t\t}\n\t}\n\tfunction afterCommit(txnId) {\n\t\tfor (let i = 0, l = afterCommitCallbacks.length; i < l; i++) {\n\t\t\ttry {\n\t\t\t\tafterCommitCallbacks[i]({next: uncommittedResolution, last: txnResolution, txnId});\n\t\t\t} catch(error) {\n\t\t\t\tconsole.error('In aftercommit callback', error);\n\t\t\t}\n\t\t}\n\t}\n\tasync function executeTxnCallbacks() {\n\t\tenv.writeTxn = writeTxn = { write: true };\n\t\tnextTxnCallbacks.isExecuting = true;\n\t\tfor (let i = 0; i < nextTxnCallbacks.length; i++) {\n\t\t\tlet txnCallbacks = nextTxnCallbacks[i];\n\t\t\tfor (let j = 0, l = txnCallbacks.length; j < l; j++) {\n\t\t\t\tlet userTxnCallback = txnCallbacks[j];\n\t\t\t\tlet asChild = userTxnCallback.asChild;\n\t\t\t\tif (asChild) {\n\t\t\t\t\tenv.beginTxn(1); // abortable\n\t\t\t\t\tlet parentTxn = writeTxn;\n\t\t\t\t\tenv.writeTxn = writeTxn = { write: true };\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet result = userTxnCallback.callback();\n\t\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\t\thasUnresolvedTxns = true;\n\t\t\t\t\t\t\tawait result;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (result === ABORT)\n\t\t\t\t\t\t\tenv.abortTxn();\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tenv.commitTxn();\n\t\t\t\t\t\tclearWriteTxn(parentTxn);\n\t\t\t\t\t\ttxnCallbacks[j] = result;\n\t\t\t\t\t} catch(error) {\n\t\t\t\t\t\tclearWriteTxn(parentTxn);\n\t\t\t\t\t\tenv.abortTxn();\n\t\t\t\t\t\ttxnError(error, txnCallbacks, j);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlet result = userTxnCallback();\n\t\t\t\t\t\ttxnCallbacks[j] = result;\n\t\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\t\thasUnresolvedTxns = true;\n\t\t\t\t\t\t\tawait result;\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(error) {\n\t\t\t\t\t\ttxnError(error, txnCallbacks, j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tnextTxnCallbacks = [];\n\t\tclearWriteTxn(null);\n\t\tif (hasUnresolvedTxns) {\n\t\t\tenv.resumeWriting();\n\t\t}\n\t\tfunction txnError(error, txnCallbacks, i) {\n\t\t\t(txnCallbacks.errors || (txnCallbacks.errors = []))[i] = error;\n\t\t\ttxnCallbacks[i] = CALLBACK_THREW;\n\t\t}\n\t}\n\tfunction finishBatch() {\n\t\tdynamicBytes.uint32[(dynamicBytes.position + 1) << 1] = 0; // clear out the next slot\n\t\tlet writeStatus = atomicStatus(dynamicBytes.uint32, (dynamicBytes.position++) << 1, 2); // atomically write the end block\n\t\tnextResolution.flagPosition += 2;\n\t\tif (writeStatus & WAITING_OPERATION) {\n\t\t\twrite(env.address, 0);\n\t\t}\n\t\tif (dynamicBytes.position > newBufferThreshold) {\n\t\t\tallocateInstructionBuffer(dynamicBytes.position);\n\t\t\tnextResolution.flagPosition = dynamicBytes.position << 1;\n\t\t\tnextResolution.uint32 = dynamicBytes.uint32;\n\t\t}\n\t}\n\tfunction clearWriteTxn(parentTxn) {\n\t\t// TODO: We might actually want to track cursors in a write txn and manually\n\t\t// close them.\n\t\tif (writeTxn && writeTxn.refCount > 0)\n\t\t\twriteTxn.isDone = true;\n\t\tenv.writeTxn = writeTxn = parentTxn || null;\n\t}\n\tObject.assign(LMDBStore.prototype, {\n\t\tput(key, value, versionOrOptions, ifVersion) {\n\t\t\tlet callback, flags = 15, type = typeof versionOrOptions;\n\t\t\tif (type == 'object' && versionOrOptions) {\n\t\t\t\tif (versionOrOptions.noOverwrite)\n\t\t\t\t\tflags |= 0x10;\n\t\t\t\tif (versionOrOptions.noDupData)\n\t\t\t\t\tflags |= 0x20;\n\t\t\t\tif (versionOrOptions.append)\n\t\t\t\t\tflags |= 0x20000;\n\t\t\t\tif (versionOrOptions.ifVersion != undefined)\n\t\t\t\t\tifVersion = versionOrOptions.ifVersion;\n\t\t\t\tversionOrOptions = versionOrOptions.version;\n\t\t\t\tif (typeof ifVersion == 'function')\n\t\t\t\t\tcallback = ifVersion;\n\t\t\t} else if (type == 'function') {\n\t\t\t\tcallback = versionOrOptions;\n\t\t\t}\n\t\t\treturn writeInstructions(flags, this, key, value, this.useVersions ? versionOrOptions || 0 : undefined, ifVersion)(callback);\n\t\t},\n\t\tremove(key, ifVersionOrValue, callback) {\n\t\t\tlet flags = 13;\n\t\t\tlet ifVersion, value;\n\t\t\tif (ifVersionOrValue !== undefined) {\n\t\t\t\tif (typeof ifVersionOrValue == 'function')\n\t\t\t\t\tcallback = ifVersionOrValue;\n\t\t\t\telse if (ifVersionOrValue === IF_EXISTS && !callback)\n\t\t\t\t\t// we have a handler for IF_EXISTS in the callback handler for remove\n\t\t\t\t\tcallback = ifVersionOrValue;\n\t\t\t\telse if (this.useVersions)\n\t\t\t\t\tifVersion = ifVersionOrValue;\n\t\t\t\telse {\n\t\t\t\t\tflags = 14;\n\t\t\t\t\tvalue = ifVersionOrValue;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn writeInstructions(flags, this, key, value, undefined, ifVersion)(callback);\n\t\t},\n\t\tdel(key, options, callback) {\n\t\t\treturn this.remove(key, options, callback);\n\t\t},\n\t\tifNoExists(key, callback) {\n\t\t\treturn this.ifVersion(key, null, callback);\n\t\t},\n\t\tifVersion(key, version, callback, options) {\n\t\t\tif (!callback) {\n\t\t\t\treturn new Batch((operations, callback) => {\n\t\t\t\t\tlet promise = this.ifVersion(key, version, operations, options);\n\t\t\t\t\tif (callback)\n\t\t\t\t\t\tpromise.then(callback);\n\t\t\t\t\treturn promise;\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (writeTxn) {\n\t\t\t\tif (version === undefined || this.doesExist(key, version)) {\n\t\t\t\t\tcallback();\n\t\t\t\t\treturn SYNC_PROMISE_SUCCESS;\n\t\t\t\t}\n\t\t\t\treturn SYNC_PROMISE_FAIL;\n\t\t\t}\n\t\t\tlet flags = key === undefined || version === undefined ? 1 : 4;\n\t\t\tif (options?.ifLessThan)\n\t\t\t\tflags |= CONDITIONAL_VERSION_LESS_THAN;\n\t\t\tif (options?.allowNotFound)\n\t\t\t\tflags |= CONDITIONAL_ALLOW_NOTFOUND;\n\t\t\tlet finishStartWrite = writeInstructions(flags, this, key, undefined, undefined, version);\n\t\t\tlet promise;\n\t\t\tbatchDepth += 2;\n\t\t\tif (batchDepth > 2)\n\t\t\t\tpromise = finishStartWrite();\n\t\t\telse {\n\t\t\t\twriteBatchStart = () => {\n\t\t\t\t\tpromise = finishStartWrite();\n\t\t\t\t};\n\t\t\t\toutstandingBatchCount = 0;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tif (typeof callback === 'function') {\n\t\t\t\t\tcallback();\n\t\t\t\t} else {\n\t\t\t\t\tfor (let i = 0, l = callback.length; i < l; i++) {\n\t\t\t\t\t\tlet operation = callback[i];\n\t\t\t\t\t\tthis[operation.type](operation.key, operation.value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (!promise) {\n\t\t\t\t\tfinishBatch();\n\t\t\t\t\tbatchDepth -= 2;\n\t\t\t\t\tpromise = finishStartWrite(); // finish write once all the operations have been written (and it hasn't been written prematurely)\n\t\t\t\t\twriteBatchStart = null;\n\t\t\t\t} else {\n\t\t\t\t\tbatchDepth -= 2;\n\t\t\t\t\tfinishBatch();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn promise;\n\t\t},\n\t\tbatch(callbackOrOperations) {\n\t\t\treturn this.ifVersion(undefined, undefined, callbackOrOperations);\n\t\t},\n\t\tdrop(callback) {\n\t\t\treturn writeInstructions(1024 + 12, this, Buffer.from([]), undefined, undefined, undefined)(callback);\n\t\t},\n\t\tclearAsync(callback) {\n\t\t\tif (this.encoder) {\n\t\t\t\tif (this.encoder.clearSharedData)\n\t\t\t\t\tthis.encoder.clearSharedData()\n\t\t\t\telse if (this.encoder.structures)\n\t\t\t\t\tthis.encoder.structures = []\n\t\t\t}\n\t\t\treturn writeInstructions(12, this, Buffer.from([]), undefined, undefined, undefined)(callback);\n\t\t},\n\t\t_triggerError() {\n\t\t\tfinishBatch();\n\t\t},\n\n\t\tputSync(key, value, versionOrOptions, ifVersion) {\n\t\t\tif (writeTxn)\n\t\t\t\treturn this.put(key, value, versionOrOptions, ifVersion) === SYNC_PROMISE_SUCCESS;\n\t\t\telse\n\t\t\t\treturn this.transactionSync(() =>\n\t\t\t\t\tthis.put(key, value, versionOrOptions, ifVersion) === SYNC_PROMISE_SUCCESS, overlappingSync? 0x10002 : 2); // non-abortable, async flush\n\t\t},\n\t\tremoveSync(key, ifVersionOrValue) {\n\t\t\tif (writeTxn)\n\t\t\t\treturn this.remove(key, ifVersionOrValue) === SYNC_PROMISE_SUCCESS;\n\t\t\telse\n\t\t\t\treturn this.transactionSync(() =>\n\t\t\t\t\tthis.remove(key, ifVersionOrValue) === SYNC_PROMISE_SUCCESS, overlappingSync? 0x10002 : 2); // non-abortable, async flush\n\t\t},\n\t\ttransaction(callback) {\n\t\t\tif (writeTxn && !nextTxnCallbacks.isExecuting) {\n\t\t\t\t// already nested in a transaction, just execute and return\n\t\t\t\treturn callback();\n\t\t\t}\n\t\t\treturn this.transactionAsync(callback);\n\t\t},\n\t\tchildTransaction(callback) {\n\t\t\tif (useWritemap)\n\t\t\t\tthrow new Error('Child transactions are not supported in writemap mode');\n\t\t\tif (writeTxn) {\n\t\t\t\tlet parentTxn = writeTxn;\n\t\t\t\tlet thisTxn = env.writeTxn = writeTxn = { write: true };\n\t\t\t\tenv.beginTxn(1); // abortable\n\t\t\t\tlet callbackDone, finishTxn;\n\t\t\t\ttry {\n\t\t\t\t\treturn writeTxn.childResults = when(callback(), finishTxn = (result) => {\n\t\t\t\t\t\tif (writeTxn !== thisTxn) // need to wait for child txn to finish asynchronously\n\t\t\t\t\t\t\treturn writeTxn.childResults.then(() => finishTxn(result));\n\t\t\t\t\t\tcallbackDone = true;\n\t\t\t\t\t\tif (result === ABORT)\n\t\t\t\t\t\t\tenv.abortTxn();\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tenv.commitTxn();\n\t\t\t\t\t\tclearWriteTxn(parentTxn);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}, (error) => {\n\t\t\t\t\t\tenv.abortTxn();\n\t\t\t\t\t\tclearWriteTxn(parentTxn);\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t});\n\t\t\t\t} catch(error) {\n\t\t\t\t\tif (!callbackDone)\n\t\t\t\t\t\tenv.abortTxn();\n\t\t\t\t\tclearWriteTxn(parentTxn);\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this.transactionAsync(callback, true);\n\t\t},\n\t\ttransactionAsync(callback, asChild) {\n\t\t\tlet txnIndex;\n\t\t\tlet txnCallbacks;\n\t\t\tif (lastQueuedResolution.callbacks) {\n\t\t\t\ttxnCallbacks = lastQueuedResolution.callbacks;\n\t\t\t\ttxnIndex = txnCallbacks.push(asChild ? { callback, asChild } : callback) - 1;\n\t\t\t} else if (nextTxnCallbacks.isExecuting) {\n\t\t\t\ttxnCallbacks = [asChild ? { callback, asChild } : callback];\n\t\t\t\ttxnCallbacks.results = commitPromise;\n\t\t\t\tnextTxnCallbacks.push(txnCallbacks);\n\t\t\t\ttxnIndex = 0;\n\t\t\t} else {\n\t\t\t\tif (writeTxn)\n\t\t\t\t\tthrow new Error('Can not enqueue transaction during write txn');\n\t\t\t\tlet finishWrite = writeInstructions(8 | (this.strictAsyncOrder ? 0x100000 : 0), this);\n\t\t\t\ttxnCallbacks = [asChild ? { callback, asChild } : callback];\n\t\t\t\tlastQueuedResolution.callbacks = txnCallbacks;\n\t\t\t\tlastQueuedResolution.id = Math.random();\n\t\t\t\ttxnCallbacks.results = finishWrite();\n\t\t\t\ttxnIndex = 0;\n\t\t\t}\n\t\t\treturn txnCallbacks.results.then((results) => {\n\t\t\t\tlet result = txnCallbacks[txnIndex];\n\t\t\t\tif (result === CALLBACK_THREW)\n\t\t\t\t\tthrow txnCallbacks.errors[txnIndex];\n\t\t\t\treturn result;\n\t\t\t});\n\t\t},\n\t\ttransactionSync(callback, flags) {\n\t\t\tif (writeTxn) {\n\t\t\t\tif (!useWritemap && (flags == undefined || (flags & 1))) // can't use child transactions in write maps\n\t\t\t\t\t// already nested in a transaction, execute as child transaction (if possible) and return\n\t\t\t\t\treturn this.childTransaction(callback);\n\t\t\t\tlet result = callback(); // else just run in current transaction\n\t\t\t\tif (result == ABORT && !abortedNonChildTransactionWarn) {\n\t\t\t\t\tconsole.warn('Can not abort a transaction inside another transaction with ' + (this.cache ? 'caching enabled' : 'useWritemap enabled'));\n\t\t\t\t\tabortedNonChildTransactionWarn = true;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tlet callbackDone, finishTxn;\n\t\t\tthis.transactions++;\n\t\t\tif (!env.address)\n\t\t\t\tthrow new Error('The database has been closed and you can not transact on it');\n\t\t\tenv.beginTxn(flags == undefined ? 3 : flags);\n\t\t\tlet thisTxn = writeTxn = env.writeTxn = { write: true };\n\t\t\ttry {\n\t\t\t\tthis.emit('begin-transaction');\n\t\t\t\treturn writeTxn.childResults = when(callback(), finishTxn = (result) => {\n\t\t\t\t\tif (writeTxn !== thisTxn) // need to wait for child txn to finish asynchronously\n\t\t\t\t\t\treturn writeTxn.childResults.then(() => finishTxn(result));\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcallbackDone = true;\n\t\t\t\t\t\tif (result === ABORT)\n\t\t\t\t\t\t\tenv.abortTxn();\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tenv.commitTxn();\n\t\t\t\t\t\t\tresetReadTxn();\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t} finally {\n\t\t\t\t\t\tclearWriteTxn(null);\n\t\t\t\t\t}\n\t\t\t\t}, (error) => {\n\t\t\t\t\ttry { env.abortTxn(); } catch(e) {}\n\t\t\t\t\tclearWriteTxn(null);\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t\t} catch(error) {\n\t\t\t\tif (!callbackDone)\n\t\t\t\t\ttry { env.abortTxn(); } catch(e) {}\n\t\t\t\tclearWriteTxn(null);\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t},\n\t\ttransactionSyncStart(callback) {\n\t\t\treturn this.transactionSync(callback, 0);\n\t\t},\n\t\t// make the db a thenable/promise-like for when the last commit is committed\n\t\tcommitted: committed = {\n\t\t\tthen(onfulfilled, onrejected) {\n\t\t\t\tif (commitPromise)\n\t\t\t\t\treturn commitPromise.then(onfulfilled, onrejected);\n\t\t\t\tif (lastWritePromise) // always resolve to true\n\t\t\t\t\treturn lastWritePromise.then(() => onfulfilled(true), onrejected);\n\t\t\t\treturn SYNC_PROMISE_SUCCESS.then(onfulfilled, onrejected);\n\t\t\t}\n\t\t},\n\t\tflushed: {\n\t\t\t// make this a thenable for when the commit is flushed to disk\n\t\t\tthen(onfulfilled, onrejected) {\n\t\t\t\tif (flushPromise)\n\t\t\t\t\tflushPromise.hasCallbacks = true\n\t\t\t\treturn Promise.all([flushPromise || committed, lastSyncTxnFlush]).then(onfulfilled, onrejected);\n\t\t\t}\n\t\t},\n\t\t_endWrites(resolvedPromise, resolvedSyncPromise) {\n\t\t\tthis.put = this.remove = this.del = this.batch = this.removeSync = this.putSync = this.transactionAsync = this.drop = this.clearAsync = () => { throw new Error('Database is closed') };\n\t\t\t// wait for all txns to finish, checking again after the current txn is done\n\t\t\tlet finalPromise = flushPromise || commitPromise || lastWritePromise;\n\t\t\tif (flushPromise)\n\t\t\t\tflushPromise.hasCallbacks = true\n\t\t\tlet finalSyncPromise = lastSyncTxnFlush;\n\t\t\tif (finalPromise && resolvedPromise != finalPromise ||\n\t\t\t\t\tfinalSyncPromise && resolvedSyncPromise != finalSyncPromise) {\n\t\t\t\treturn Promise.all([finalPromise, finalSyncPromise]).then(() => this._endWrites(finalPromise, finalSyncPromise), () => this._endWrites(finalPromise, finalSyncPromise));\n\t\t\t}\n\t\t\tObject.defineProperty(env, 'sync', { value: null });\n\t\t},\n\t\ton(event, callback) {\n\t\t\tif (event == 'beforecommit') {\n\t\t\t\teventTurnBatching = true;\n\t\t\t\tbeforeCommitCallbacks.push(callback);\n\t\t\t} else if (event == 'aftercommit')\n\t\t\t\tafterCommitCallbacks.push(callback);\n\t\t\telse\n\t\t\t\tsuper.on(event, callback);\n\t\t}\n\t});\n}\n\nclass Batch extends Array {\n\tconstructor(callback) {\n\t\tsuper();\n\t\tthis.callback = callback;\n\t}\n\tput(key, value) {\n\t\tthis.push({ type: 'put', key, value });\n\t}\n\tdel(key) {\n\t\tthis.push({ type: 'del', key });\n\t}\n\tclear() {\n\t\tthis.splice(0, this.length);\n\t}\n\twrite(callback) {\n\t\treturn this.callback(this, callback);\n\t}\n}\nexport function asBinary(buffer) {\n\treturn {\n\t\t['\\x10binary-data\\x02']: buffer\n\t};\n}\n","export const SKIP = {};\nconst DONE = {\n\tvalue: null,\n\tdone: true,\n}\nif (!Symbol.asyncIterator) {\n\tSymbol.asyncIterator = Symbol.for('Symbol.asyncIterator');\n}\n\nexport class RangeIterable {\n\tconstructor(sourceArray) {\n\t\tif (sourceArray) {\n\t\t\tthis.iterate = sourceArray[Symbol.iterator].bind(sourceArray);\n\t\t}\n\t}\n\tmap(func) {\n\t\tlet source = this;\n\t\tlet iterable = new RangeIterable();\n\t\titerable.iterate = (async) => {\n\t\t\tlet iterator = source[Symbol.iterator](async);\n\t\t\tlet i = 0;\n\t\t\treturn {\n\t\t\t\tnext(resolvedResult) {\n\t\t\t\t\tlet result;\n\t\t\t\t\tdo {\n\t\t\t\t\t\tlet iteratorResult;\n\t\t\t\t\t\tif (resolvedResult) {\n\t\t\t\t\t\t\titeratorResult = resolvedResult;\n\t\t\t\t\t\t\tresolvedResult = null; // don't go in this branch on next iteration\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\titeratorResult = iterator.next();\n\t\t\t\t\t\t\tif (iteratorResult.then) {\n\t\t\t\t\t\t\t\treturn iteratorResult.then(iteratorResult => this.next(iteratorResult));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (iteratorResult.done === true) {\n\t\t\t\t\t\t\tthis.done = true;\n\t\t\t\t\t\t\tif (iterable.onDone) iterable.onDone();\n\t\t\t\t\t\t\treturn iteratorResult;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tresult = func(iteratorResult.value, i++);\n\t\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\t\treturn result.then(result =>\n\t\t\t\t\t\t\t\tresult === SKIP ?\n\t\t\t\t\t\t\t\t\tthis.next() :\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvalue: result\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} while(result === SKIP);\n\t\t\t\t\tif (result === DONE) {\n\t\t\t\t\t\tif (iterable.onDone) iterable.onDone();\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue: result\n\t\t\t\t\t};\n\t\t\t\t},\n\t\t\t\treturn() {\n\t\t\t\t\tif (iterable.onDone) iterable.onDone();\n\t\t\t\t\treturn iterator.return();\n\t\t\t\t},\n\t\t\t\tthrow() {\n\t\t\t\t\tif (iterable.onDone) iterable.onDone();\n\t\t\t\t\treturn iterator.throw();\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\treturn iterable;\n\t}\n\t[Symbol.asyncIterator]() {\n\t\treturn this.iterator = this.iterate();\n\t}\n\t[Symbol.iterator]() {\n\t\treturn this.iterator = this.iterate();\n\t}\n\tfilter(func) {\n\t\treturn this.map(element => {\n\t\t\tlet result = func(element);\n\t\t\t// handle promise\n\t\t\tif (result?.then) return result.then((result) => result ? element : SKIP);\n\t\t\telse return result ? element : SKIP;\n\t\t});\n\t}\n\n\tforEach(callback) {\n\t\tlet iterator = this.iterator = this.iterate();\n\t\tlet result;\n\t\twhile ((result = iterator.next()).done !== true) {\n\t\t\tcallback(result.value);\n\t\t}\n\t}\n\tconcat(secondIterable) {\n\t\tlet concatIterable = new RangeIterable();\n\t\tconcatIterable.iterate = (async) => {\n\t\t\tlet iterator = this.iterator = this.iterate();\n\t\t\tlet isFirst = true;\n\t\t\treturn {\n\t\t\t\tnext() {\n\t\t\t\t\tlet result = iterator.next();\n\t\t\t\t\tif (result.done) {\n\t\t\t\t\t\tif (isFirst) {\n\t\t\t\t\t\t\tisFirst = false;\n\t\t\t\t\t\t\titerator = secondIterable[Symbol.iterator](async);\n\t\t\t\t\t\t\tresult = iterator.next();\n\t\t\t\t\t\t\tif (result.done && concatIterable.onDone) iterable.onDone();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (concatIterable.onDone) concatIterable.onDone();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn result;\n\t\t\t\t},\n\t\t\t\treturn() {\n\t\t\t\t\tif (concatIterable.onDone) concatIterable.onDone();\n\t\t\t\t\treturn iterator.return();\n\t\t\t\t},\n\t\t\t\tthrow() {\n\t\t\t\t\tif (concatIterable.onDone) concatIterable.onDone();\n\t\t\t\t\treturn iterator.throw();\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\treturn concatIterable;\n\t}\n\n\tflatMap(callback) {\n\t\tlet mappedIterable = new RangeIterable();\n\t\tmappedIterable.iterate = (async) => {\n\t\t\tlet iterator = this.iterator = this.iterate(async);\n\t\t\tlet isFirst = true;\n\t\t\tlet currentSubIterator;\n\t\t\treturn {\n\t\t\t\tnext() {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (currentSubIterator) {\n\t\t\t\t\t\t\tlet result = currentSubIterator.next();\n\t\t\t\t\t\t\tif (!result.done) {\n\t\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet result = iterator.next();\n\t\t\t\t\t\tif (result.done) {\n\t\t\t\t\t\t\tif (mappedIterable.onDone) mappedIterable.onDone();\n\t\t\t\t\t\t\treturn result;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlet value = callback(result.value);\n\t\t\t\t\t\tif (Array.isArray(value) || value instanceof RangeIterable)\n\t\t\t\t\t\t\tcurrentSubIterator = value[Symbol.iterator]();\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tcurrentSubIterator = null;\n\t\t\t\t\t\t\treturn { value };\n\t\t\t\t\t\t}\n\t\t\t\t\t} while(true);\n\t\t\t\t},\n\t\t\t\treturn() {\n\t\t\t\t\tif (mappedIterable.onDone) mappedIterable.onDone();\n\t\t\t\t\tif (currentSubIterator)\n\t\t\t\t\t\tcurrentSubIterator.return();\n\t\t\t\t\treturn iterator.return();\n\t\t\t\t},\n\t\t\t\tthrow() {\n\t\t\t\t\tif (mappedIterable.onDone) mappedIterable.onDone();\n\t\t\t\t\tif (currentSubIterator)\n\t\t\t\t\t\tcurrentSubIterator.throw();\n\t\t\t\t\treturn iterator.throw();\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t\treturn mappedIterable;\n\t}\n\n\tslice(start, end) {\n\t\treturn this.map((element, i) => {\n\t\t\tif (i < start)\n\t\t\t\treturn SKIP;\n\t\t\tif (i >= end) {\n\t\t\t\tDONE.value = element;\n\t\t\t\treturn DONE;\n\t\t\t}\n\t\t\treturn element;\n\t\t});\n\t}\n\tnext() {\n\t\tif (!this.iterator)\n\t\t\tthis.iterator = this.iterate();\n\t\treturn this.iterator.next();\n\t}\n\ttoJSON() {\n\t\tif (this.asArray && this.asArray.forEach) {\n\t\t\treturn this.asArray;\n\t\t}\n\t\tthrow new Error('Can not serialize async iterables without first calling resolveJSON');\n\t\t//return Array.from(this)\n\t}\n\tget asArray() {\n\t\tif (this._asArray)\n\t\t\treturn this._asArray;\n\t\tlet promise = new Promise((resolve, reject) => {\n\t\t\tlet iterator = this.iterate();\n\t\t\tlet array = [];\n\t\t\tlet iterable = this;\n\t\t\tObject.defineProperty(array, 'iterable', { value: iterable });\n\t\t\tfunction next(result) {\n\t\t\t\twhile (result.done !== true) {\n\t\t\t\t\tif (result.then) {\n\t\t\t\t\t\treturn result.then(next);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tarray.push(result.value);\n\t\t\t\t\t}\n\t\t\t\t\tresult = iterator.next();\n\t\t\t\t}\n\t\t\t\tresolve(iterable._asArray = array);\n\t\t\t}\n\t\t\tnext(iterator.next());\n\t\t});\n\t\tpromise.iterable = this;\n\t\treturn this._asArray || (this._asArray = promise);\n\t}\n\tresolveData() {\n\t\treturn this.asArray;\n\t}\n}\nRangeIterable.prototype.DONE = DONE;","import { getAddress, orderedBinary } from './native.js';\n\nconst REUSE_BUFFER_MODE = 512;\nconst writeUint32Key = (key, target, start) => {\n\t(target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))).setUint32(start, key, true);\n\treturn start + 4;\n};\nconst readUint32Key = (target, start) => {\n\treturn (target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))).getUint32(start, true);\n};\nconst writeBufferKey = (key, target, start) => {\n\ttarget.set(key, start);\n\treturn key.length + start;\n};\nconst Uint8ArraySlice = Uint8Array.prototype.slice;\nconst readBufferKey = (target, start, end) => {\n\treturn Uint8ArraySlice.call(target, start, end);\n};\n\nlet lastEncodedValue, bytes;\nexport function applyKeyHandling(store) {\n \tif (store.encoding == 'ordered-binary') {\n\t\tstore.encoder = store.decoder = {\n\t\t\twriteKey: orderedBinary.writeKey,\n\t\t\treadKey: orderedBinary.readKey,\n\t\t};\n\t}\n\tif (store.encoder && store.encoder.writeKey && !store.encoder.encode) {\n\t\tstore.encoder.encode = function(value, mode) {\n\t\t\tif (typeof value !== 'object' && value && value === lastEncodedValue) {\n\t\t\t\t// reuse the last serialized bytes\n\t\t\t\t// NOTE that it is very important that nothing else calls saveKey with saveTo: false\n\t\t\t} else {\n\t\t\t\tlastEncodedValue = value;\n\t\t\t\tbytes = saveKey(value, this.writeKey, false, store.maxKeySize);\n\t\t\t}\n\t\t\tif (bytes.end > 0 && !(REUSE_BUFFER_MODE & mode)) {\n\t\t\t\treturn bytes.subarray(bytes.start, bytes.end);\n\t\t\t}\n\t\t\treturn bytes;\n\t\t};\n\t\tstore.encoder.copyBuffers = true; // just an indicator for the buffer reuse in write.js\n\t}\n\tif (store.decoder && store.decoder.readKey && !store.decoder.decode) {\n\t\tstore.decoder.decode = function(buffer) { return this.readKey(buffer, 0, buffer.length); };\n\t\tstore.decoderCopies = true;\n\t}\n\tif (store.keyIsUint32 || store.keyEncoding == 'uint32') {\n\t\tstore.writeKey = writeUint32Key;\n\t\tstore.readKey = readUint32Key;\n\t} else if (store.keyIsBuffer || store.keyEncoding == 'binary') {\n\t\tstore.writeKey = writeBufferKey;\n\t\tstore.readKey = readBufferKey;\n\t} else if (store.keyEncoder) {\n\t\tstore.writeKey = store.keyEncoder.writeKey;\n\t\tstore.readKey = store.keyEncoder.readKey;\n\t} else {\n\t\tstore.writeKey = orderedBinary.writeKey;\n\t\tstore.readKey = orderedBinary.readKey;\n\t}\n}\n\nlet saveBuffer, uint32, saveDataView = { setFloat64() {}, setUint32() {} }, saveDataAddress;\nlet savePosition = 8000;\nlet DYNAMIC_KEY_BUFFER_SIZE = 8192;\nfunction allocateSaveBuffer() {\n\tsaveBuffer = typeof Buffer != 'undefined' ? Buffer.alloc(DYNAMIC_KEY_BUFFER_SIZE) : new Uint8Array(DYNAMIC_KEY_BUFFER_SIZE);\n\tuint32 = null;\n\tsaveBuffer.buffer.address = getAddress(saveBuffer.buffer);\n\tsaveDataAddress = saveBuffer.buffer.address;\n\t// TODO: Conditionally only do this for key sequences?\n\tsaveDataView.setUint32(savePosition, 0xffffffff);\n\tsaveDataView.setFloat64(savePosition + 4, saveDataAddress, true); // save a pointer from the old buffer to the new address for the sake of the prefetch sequences\n\tsaveDataView = saveBuffer.dataView || (saveBuffer.dataView = new DataView(saveBuffer.buffer, saveBuffer.byteOffset, saveBuffer.byteLength));\n\tsavePosition = 0;\n}\nexport function saveKey(key, writeKey, saveTo, maxKeySize, flags) {\n\tif (savePosition > 7800) {\n\t\tallocateSaveBuffer();\n\t}\n\tlet start = savePosition;\n\ttry {\n\t\tsavePosition = key === undefined ? start + 4 :\n\t\t\twriteKey(key, saveBuffer, start + 4);\n\t} catch (error) {\n\t\tsaveBuffer.fill(0, start + 4); // restore zeros\n\t\tif (error.name == 'RangeError') {\n\t\t\tif (8180 - start < maxKeySize) {\n\t\t\t\tallocateSaveBuffer(); // try again:\n\t\t\t\treturn saveKey(key, writeKey, saveTo, maxKeySize);\n\t\t\t}\n\t\t\tthrow new Error('Key was too large, max key size is ' + maxKeySize);\n\t\t} else\n\t\t\tthrow error;\n\t}\n\tlet length = savePosition - start - 4;\n\tif (length > maxKeySize) {\n\t\tthrow new Error('Key of size ' + length + ' was too large, max key size is ' + maxKeySize);\n\t}\n\tif (savePosition >= 8160) { // need to reserve enough room at the end for pointers\n\t\tsavePosition = start // reset position\n\t\tallocateSaveBuffer(); // try again:\n\t\treturn saveKey(key, writeKey, saveTo, maxKeySize);\n\t}\n\tif (saveTo) {\n\t\tsaveDataView.setUint32(start, flags ? length | flags : length, true); // save the length\n\t\tsaveTo.saveBuffer = saveBuffer;\n\t\tsavePosition = (savePosition + 12) & 0xfffffc;\n\t\treturn start + saveDataAddress;\n\t} else {\n\t\tsaveBuffer.start = start + 4;\n\t\tsaveBuffer.end = savePosition;\n\t\tsavePosition = (savePosition + 7) & 0xfffff8; // full 64-bit word alignment since these are usually copied\n\t\treturn saveBuffer;\n\t}\n}","import { RangeIterable }  from './util/RangeIterable.js';\nimport { getAddress, Cursor, Txn, orderedBinary, lmdbError, getByBinary, setGlobalBuffer, prefetch, iterate, position as doPosition, resetTxn, getCurrentValue, getCurrentShared, getStringByBinary, globalBuffer, getSharedBuffer, startRead, setReadCallback } from './native.js';\nimport { saveKey }  from './keys.js';\nconst IF_EXISTS = 3.542694326329068e-103;\nconst ITERATOR_DONE = { done: true, value: undefined };\nconst Uint8ArraySlice = Uint8Array.prototype.slice;\nlet getValueBytes = globalBuffer;\nif (!getValueBytes.maxLength) {\n\tgetValueBytes.maxLength = getValueBytes.length;\n\tgetValueBytes.isGlobal = true;\n\tObject.defineProperty(getValueBytes, 'length', { value: getValueBytes.length, writable: true, configurable: true });\n}\nconst START_ADDRESS_POSITION = 4064;\nconst NEW_BUFFER_THRESHOLD = 0x8000;\nconst SOURCE_SYMBOL = Symbol.for('source');\nexport const UNMODIFIED = {};\nlet mmaps = [];\n\nexport function addReadMethods(LMDBStore, {\n\tmaxKeySize, env, keyBytes, keyBytesView, getLastVersion, getLastTxnId\n}) {\n\tlet readTxn, readTxnRenewed, asSafeBuffer = false;\n\tlet renewId = 1;\n\tlet outstandingReads = 0;\n\tObject.assign(LMDBStore.prototype, {\n\t\tgetString(id, options) {\n\t\t\tlet txn = env.writeTxn || (options && options.transaction) || (readTxnRenewed ? readTxn : renewReadTxn(this));\n\t\t\tlet string = getStringByBinary(this.dbAddress, this.writeKey(id, keyBytes, 0), txn.address || 0);\n\t\t\tif (typeof string === 'number') { // indicates the buffer wasn't large enough\n\t\t\t\tthis._allocateGetBuffer(string);\n\t\t\t\t// and then try again\n\t\t\t\tstring = getStringByBinary(this.dbAddress, this.writeKey(id, keyBytes, 0), txn.address || 0);\n\t\t\t}\n\t\t\tif (string)\n\t\t\t\tthis.lastSize = string.length;\n\t\t\treturn string;\n\t\t},\n\t\tgetBinaryFast(id, options) {\n\t\t\tlet rc;\n\t\t\tlet txn = env.writeTxn || (options && options.transaction) || (readTxnRenewed ? readTxn : renewReadTxn(this));\n\t\t\trc = this.lastSize = getByBinary(this.dbAddress, this.writeKey(id, keyBytes, 0), (options && options.ifNotTxnId) || 0, txn.address || 0);\n\t\t\tif (rc < 0) {\n\t\t\t\tif (rc == -30798) // MDB_NOTFOUND\n\t\t\t\t\treturn; // undefined\n\t\t\t\tif (rc == -30004) // txn id matched\n\t\t\t\t\treturn UNMODIFIED;\n\t\t\t\tif (rc == -30781 /*MDB_BAD_VALSIZE*/ && this.writeKey(id, keyBytes, 0) == 0)\n\t\t\t\t\tthrow new Error(id === undefined ?\n\t\t\t\t\t'A key is required for get, but is undefined' :\n\t\t\t\t\t'Zero length key is not allowed in LMDB');\n\t\t\t\tif (rc == -30000) // int32 overflow, read uint32\n\t\t\t\t\trc = this.lastSize = keyBytesView.getUint32(0, true);\n\t\t\t\telse if (rc == -30001) {// shared buffer\n\t\t\t\t\tthis.lastSize = keyBytesView.getUint32(0, true);\n\t\t\t\t\tlet bufferId = keyBytesView.getUint32(4, true);\n\t\t\t\t\treturn getMMapBuffer(bufferId, this.lastSize);\n\t\t\t\t} else\n\t\t\t\t\tthrow lmdbError(rc);\n\t\t\t}\n\t\t\tlet compression = this.compression;\n\t\t\tlet bytes = compression ? compression.getValueBytes : getValueBytes;\n\t\t\tif (rc > bytes.maxLength) {\n\t\t\t\t// this means the target buffer wasn't big enough, so the get failed to copy all the data from the database, need to either grow or use special buffer\n\t\t\t\treturn this._returnLargeBuffer(\n\t\t\t\t\t() => getByBinary(this.dbAddress, this.writeKey(id, keyBytes, 0), 0, txn.address || 0));\n\t\t\t}\n\t\t\tbytes.length = this.lastSize;\n\t\t\treturn bytes;\n\t\t},\n\t\tgetBFAsync(id, options, callback) {\n\t\t\tlet txn = env.writeTxn || (options && options.transaction) || (readTxnRenewed ? readTxn : renewReadTxn(this));\n\t\t\ttxn.refCount = (txn.refCount || 0) + 1;\n\t\t\toutstandingReads++;\n\t\t\tlet address = recordReadInstruction(txn.address, this.db.dbi, id, this.writeKey, maxKeySize, ( rc, bufferId, offset, size ) => {\n\t\t\t\tif (rc && rc !== 1)\n\t\t\t\t\tcallback(lmdbError(rc));\n\t\t\t\toutstandingReads--;\n\t\t\t\tlet buffer = mmaps[bufferId];\n\t\t\t\tif (!buffer) {\n\t\t\t\t\tbuffer = mmaps[bufferId] = getSharedBuffer(bufferId, env.address);\n\t\t\t\t}\n\t\t\t\t//console.log({bufferId, offset, size})\n\t\t\t\tif (buffer.isSharedMap) {\n\t\t\t\t\t// using LMDB shared memory\n\t\t\t\t\t// TODO: We may want explicit support for clearing aborting the transaction on the next event turn,\n\t\t\t\t\t// but for now we are relying on the GC to cleanup transaction for larger blocks of memory\n\t\t\t\t\tlet bytes = new Uint8Array(buffer, offset, size);\n\t\t\t\t\tbytes.txn = txn;\n\t\t\t\t\tcallback(bytes, 0, size);\n\t\t\t\t} else {\n\t\t\t\t\t// using copied memory\n\t\t\t\t\ttxn.done(); // decrement and possibly abort\n\t\t\t\t\tcallback(buffer, offset, size);\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (address) {\n\t\t\t\tstartRead(address, () => {\n\t\t\t\t\tresolveReads();\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\tgetAsync(id, options, callback) {\n\t\t\tlet promise;\n\t\t\tif (!callback)\n\t\t\t\tpromise = new Promise(resolve => callback = resolve);\n\t\t\tthis.getBFAsync(id, options, (buffer, offset, size) => {\n\t\t\t\tif (this.useVersions) {\n\t\t\t\t\t// TODO: And get the version\n\t\t\t\t\toffset += 8;\n\t\t\t\t\tsize -= 8;\n\t\t\t\t}\n\t\t\t\tlet bytes = new Uint8Array(buffer, offset, size);\n\t\t\t\tlet value;\n\t\t\t\tif (this.decoder) {\n\t\t\t\t\t// the decoder potentially uses the data from the buffer in the future and needs a stable buffer\n\t\t\t\t\tvalue = bytes && this.decoder.decode(bytes);\n\t\t\t\t} else if (this.encoding == 'binary') {\n\t\t\t\t\tvalue = bytes;\n\t\t\t\t} else {\n\t\t\t\t\tvalue = Buffer.prototype.utf8Slice.call(bytes, 0, size);\n\t\t\t\t\tif (this.encoding == 'json' && value)\n\t\t\t\t\t\tvalue = JSON.parse(value);\n\t\t\t\t}\n\t\t\t\tcallback(value);\n\t\t\t});\n\t\t\treturn promise;\n\t\t},\n\t\tretain(data, options) {\n\t\t\tif (!data)\n\t\t\t\treturn\n\t\t\tlet source = data[SOURCE_SYMBOL];\n\t\t\tlet buffer = source ? source.bytes : data;\n\t\t\tif (!buffer.isGlobal && !env.writeTxn) {\n\t\t\t\tlet txn = options?.transaction || (readTxnRenewed ? readTxn : renewReadTxn(this));\n\t\t\t\tbuffer.txn = txn;\n\t\t\t\ttxn.refCount = (txn.refCount || 0) + 1;\n\t\t\t\treturn data;\n\t\t\t} else {\n\t\t\t\tbuffer = Uint8ArraySlice.call(buffer, 0, this.lastSize);\n\t\t\t\tif (source) {\n\t\t\t\t\tsource.bytes = buffer;\n\t\t\t\t\treturn data;\n\t\t\t\t} else\n\t\t\t\t\treturn buffer;\n\t\t\t}\n\t\t},\n\t\t_returnLargeBuffer(getFast) {\n\t\t\tlet bytes;\n\t\t\tlet compression = this.compression;\n\t\t\tif (asSafeBuffer && this.lastSize > NEW_BUFFER_THRESHOLD) {\n\t\t\t\t// used by getBinary to indicate it should create a dedicated buffer to receive this\n\t\t\t\tlet bytesToRestore\n\t\t\t\ttry {\n\t\t\t\t\tif (compression) {\n\t\t\t\t\t\tbytesToRestore = compression.getValueBytes;\n\t\t\t\t\t\tlet dictionary = compression.dictionary || [];\n\t\t\t\t\t\tlet dictLength = (dictionary.length >> 3) << 3;// make sure it is word-aligned\n\t\t\t\t\t\tbytes = makeReusableBuffer(this.lastSize);\n\t\t\t\t\t\tcompression.setBuffer(bytes.buffer, bytes.byteOffset, this.lastSize, dictionary, dictLength);\n\t\t\t\t\t\tcompression.getValueBytes = bytes;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbytesToRestore = getValueBytes;\n\t\t\t\t\t\tsetGlobalBuffer(bytes = getValueBytes = makeReusableBuffer(this.lastSize));\n\t\t\t\t\t}\n\t\t\t\t\tgetFast();\n\t\t\t\t} finally {\n\t\t\t\t\tif (compression) {\n\t\t\t\t\t\tlet dictLength = (compression.dictionary.length >> 3) << 3;\n\t\t\t\t\t\tcompression.setBuffer(bytesToRestore.buffer, bytesToRestore.byteOffset, bytesToRestore.maxLength, compression.dictionary, dictLength);\n\t\t\t\t\t\tcompression.getValueBytes = bytesToRestore;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsetGlobalBuffer(bytesToRestore);\n\t\t\t\t\t\tgetValueBytes = bytesToRestore;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn bytes;\n\t\t\t}\n\t\t\t// grow our shared/static buffer to accomodate the size of the data\n\t\t\tbytes = this._allocateGetBuffer(this.lastSize);\n\t\t\t// and try again\n\t\t\tgetFast();\n\t\t\tbytes.length = this.lastSize;\n\t\t\treturn bytes;\n\t\t},\n\t\t_allocateGetBuffer(lastSize) {\n\t\t\tlet newLength = Math.min(Math.max(lastSize * 2, 0x1000), 0xfffffff8);\n\t\t\tlet bytes;\n\t\t\tif (this.compression) {\n\t\t\t\tlet dictionary = this.compression.dictionary || Buffer.allocUnsafeSlow(0);\n\t\t\t\tlet dictLength = (dictionary.length >> 3) << 3;// make sure it is word-aligned\n\t\t\t\tbytes = Buffer.allocUnsafeSlow(newLength + dictLength);\n\t\t\t\tbytes.set(dictionary) // copy dictionary into start\n\t\t\t\t// the section after the dictionary is the target area for get values\n\t\t\t\tbytes = bytes.subarray(dictLength);\n\t\t\t\tthis.compression.setBuffer(bytes.buffer, bytes.byteOffset, newLength, dictionary, dictLength);\n\t\t\t\tbytes.maxLength = newLength;\n\t\t\t\tObject.defineProperty(bytes, 'length', { value: newLength, writable: true, configurable: true });\n\t\t\t\tthis.compression.getValueBytes = bytes;\n\t\t\t} else {\n\t\t\t\tbytes = makeReusableBuffer(newLength);\n\t\t\t\tsetGlobalBuffer(getValueBytes = bytes);\n\t\t\t}\n\t\t\tbytes.isGlobal = true;\n\t\t\treturn bytes;\n\t\t},\n\t\tgetBinary(id, options) {\n\t\t\ttry {\n\t\t\t\tasSafeBuffer = true;\n\t\t\t\tlet fastBuffer = this.getBinaryFast(id, options);\n\t\t\t\treturn fastBuffer && (fastBuffer.isGlobal ? Uint8ArraySlice.call(fastBuffer, 0, this.lastSize) : fastBuffer);\n\t\t\t} finally {\n\t\t\t\tasSafeBuffer = false;\n\t\t\t}\n\t\t},\n\t\tgetSharedBinary(id, options) {\n\t\t\tlet fastBuffer = this.getBinaryFast(id, options);\n\t\t\tif (fastBuffer) {\n\t\t\t\tif (fastBuffer.isGlobal || writeTxn)\n\t\t\t\t\treturn Uint8ArraySlice.call(fastBuffer, 0, this.lastSize)\n\t\t\t\tfastBuffer.txn = (options && options.transaction);\n\t\t\t\toptions.transaction.refCount = (options.transaction.refCount || 0) + 1;\n\t\t\t\treturn fastBuffer;\n\t\t\t}\n\t\t},\n\t\tget(id, options) {\n\t\t\tif (this.decoderCopies) {\n\t\t\t\t// the decoder copies any data, so we can use the fast binary retrieval that overwrites the same buffer space\n\t\t\t\tlet bytes = this.getBinaryFast(id, options);\n\t\t\t\treturn bytes && (bytes == UNMODIFIED ? UNMODIFIED : this.decoder.decode(bytes, options));\n\t\t\t}\n\t\t\tif (this.encoding == 'binary')\n\t\t\t\treturn this.getBinary(id, options);\n\t\t\tif (this.decoder) {\n\t\t\t\t// the decoder potentially uses the data from the buffer in the future and needs a stable buffer\n\t\t\t\tlet bytes = this.getBinary(id, options);\n\t\t\t\treturn bytes && (bytes == UNMODIFIED ? UNMODIFIED : this.decoder.decode(bytes));\n\t\t\t}\n\n\t\t\tlet result = this.getString(id, options);\n\t\t\tif (result) {\n\t\t\t\tif (this.encoding == 'json')\n\t\t\t\t\treturn JSON.parse(result);\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\t\tgetEntry(id, options) {\n\t\t\tlet value = this.get(id, options);\n\t\t\tif (value !== undefined) {\n\t\t\t\tif (this.useVersions)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\tversion: getLastVersion(),\n\t\t\t\t\t\t//size: this.lastSize\n\t\t\t\t\t};\n\t\t\t\telse\n\t\t\t\t\treturn {\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t//size: this.lastSize\n\t\t\t\t\t};\n\t\t\t}\n\t\t},\n\t\tresetReadTxn() {\n\t\t\tresetReadTxn();\n\t\t},\n\t\t_commitReadTxn() {\n\t\t\tif (readTxn) {\n\t\t\t\treadTxn.isCommitted = true\n\t\t\t\treadTxn.commit();\n\t\t\t}\n\t\t\tlastReadTxnRef = null;\n\t\t\treadTxnRenewed = null;\n\t\t\treadTxn = null;\n\t\t},\n\t\tensureReadTxn() {\n\t\t\tif (!env.writeTxn && !readTxnRenewed)\n\t\t\t\trenewReadTxn(this);\n\t\t},\n\t\tdoesExist(key, versionOrValue) {\n\t\t\tif (versionOrValue == null) {\n\t\t\t\t// undefined means the entry exists, null is used specifically to check for the entry *not* existing\n\t\t\t\treturn (this.getBinaryFast(key) === undefined) == (versionOrValue === null);\n\t\t\t}\n\t\t\telse if (this.useVersions) {\n\t\t\t\treturn this.getBinaryFast(key) !== undefined && (versionOrValue === IF_EXISTS || getLastVersion() === versionOrValue);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (versionOrValue && versionOrValue['\\x10binary-data\\x02'])\n\t\t\t\t\tversionOrValue = versionOrValue['\\x10binary-data\\x02'];\n\t\t\t\telse if (this.encoder)\n\t\t\t\t\tversionOrValue = this.encoder.encode(versionOrValue);\n\t\t\t\tif (typeof versionOrValue == 'string')\n\t\t\t\t\tversionOrValue = Buffer.from(versionOrValue);\n\t\t\t\treturn this.getValuesCount(key, { start: versionOrValue, exactMatch: true}) > 0;\n\t\t\t}\n\t\t},\n\t\tgetValues(key, options) {\n\t\t\tlet defaultOptions = {\n\t\t\t\tkey,\n\t\t\t\tvaluesForKey: true\n\t\t\t};\n\t\t\tif (options && options.snapshot === false)\n\t\t\t\tthrow new Error('Can not disable snapshots for getValues');\n\t\t\treturn this.getRange(options ? Object.assign(defaultOptions, options) : defaultOptions);\n\t\t},\n\t\tgetKeys(options) {\n\t\t\tif (!options)\n\t\t\t\toptions = {};\n\t\t\toptions.values = false;\n\t\t\treturn this.getRange(options);\n\t\t},\n\t\tgetCount(options) {\n\t\t\tif (!options)\n\t\t\t\toptions = {};\n\t\t\toptions.onlyCount = true;\n\t\t\treturn this.getRange(options).iterate();\n\t\t},\n\t\tgetKeysCount(options) {\n\t\t\tif (!options)\n\t\t\t\toptions = {};\n\t\t\toptions.onlyCount = true;\n\t\t\toptions.values = false;\n\t\t\treturn this.getRange(options).iterate();\n\t\t},\n\t\tgetValuesCount(key, options) {\n\t\t\tif (!options)\n\t\t\t\toptions = {};\n\t\t\toptions.key = key;\n\t\t\toptions.valuesForKey = true;\n\t\t\toptions.onlyCount = true;\n\t\t\treturn this.getRange(options).iterate();\n\t\t},\n\t\tgetRange(options) {\n\t\t\tlet iterable = new RangeIterable();\n\t\t\tif (!options)\n\t\t\t\toptions = {};\n\t\t\tlet includeValues = options.values !== false;\n\t\t\tlet includeVersions = options.versions;\n\t\t\tlet valuesForKey = options.valuesForKey;\n\t\t\tlet limit = options.limit;\n\t\t\tlet db = this.db;\n\t\t\tlet snapshot = options.snapshot;\n\t\t\tlet compression = this.compression;\n\t\t\titerable.iterate = () => {\n\t\t\t\tlet currentKey = valuesForKey ? options.key : options.start;\n\t\t\t\tconst reverse = options.reverse;\n\t\t\t\tlet count = 0;\n\t\t\t\tlet cursor, cursorRenewId, cursorAddress;\n\t\t\t\tlet txn;\n\t\t\t\tlet flags = (includeValues ? 0x100 : 0) | (reverse ? 0x400 : 0) |\n\t\t\t\t\t(valuesForKey ? 0x800 : 0) | (options.exactMatch ? 0x4000 : 0) |\n\t\t\t\t\t(options.inclusiveEnd ? 0x8000 : 0) |\n\t\t\t\t\t(options.exclusiveStart ? 0x10000 : 0);\n\t\t\t\tlet store = this;\n\t\t\t\tfunction resetCursor() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (cursor)\n\t\t\t\t\t\t\tfinishCursor();\n\t\t\t\t\t\tlet txnAddress;\n\t\t\t\t\t\ttxn = options.transaction\n\t\t\t\t\t\tif (txn) {\n\t\t\t\t\t\t\tif (txn.isDone) throw new Error('Can not iterate on range with transaction that is already' +\n\t\t\t\t\t\t\t\t' done');\n\t\t\t\t\t\t\ttxnAddress = txn.address;\n\t\t\t\t\t\t\tcursor = null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet writeTxn = env.writeTxn;\n\t\t\t\t\t\t\tif (writeTxn)\n\t\t\t\t\t\t\t\tsnapshot = false;\n\t\t\t\t\t\t\ttxn = env.writeTxn || options.transaction || (readTxnRenewed ? readTxn : renewReadTxn(store));\n\t\t\t\t\t\t\tcursor = !writeTxn && db.availableCursor;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (cursor) {\n\t\t\t\t\t\t\tdb.availableCursor = null;\n\t\t\t\t\t\t\tflags |= 0x2000;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcursor = new Cursor(db, txnAddress || 0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcursorAddress = cursor.address;\n\t\t\t\t\t\ttxn.refCount = (txn.refCount || 0) + 1; // track transaction so we always use the same one\n\t\t\t\t\t\tif (snapshot === false) {\n\t\t\t\t\t\t\tcursorRenewId = renewId; // use shared read transaction\n\t\t\t\t\t\t\ttxn.renewingRefCount = (txn.renewingRefCount || 0) + 1; // need to know how many are renewing cursors\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(error) {\n\t\t\t\t\t\tif (cursor) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tcursor.close();\n\t\t\t\t\t\t\t} catch(error) { }\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthrow error;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresetCursor();\n\t\t\t\tif (options.onlyCount) {\n\t\t\t\t\tflags |= 0x1000;\n\t\t\t\t\tlet count = position(options.offset);\n\t\t\t\t\tif (count < 0)\n\t\t\t\t\t\tlmdbError(count);\n\t\t\t\t\tfinishCursor();\n\t\t\t\t\treturn count;\n\t\t\t\t}\n\t\t\t\tfunction position(offset) {\n\t\t\t\t\tlet keySize = currentKey === undefined ? 0 : store.writeKey(currentKey, keyBytes, 0);\n\t\t\t\t\tlet endAddress;\n\t\t\t\t\tif (valuesForKey) {\n\t\t\t\t\t\tif (options.start === undefined && options.end === undefined)\n\t\t\t\t\t\t\tendAddress = 0;\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlet startAddress;\n\t\t\t\t\t\t\tif (store.encoder.writeKey) {\n\t\t\t\t\t\t\t\tstartAddress = saveKey(options.start, store.encoder.writeKey, iterable, maxKeySize);\n\t\t\t\t\t\t\t\tkeyBytesView.setFloat64(START_ADDRESS_POSITION, startAddress, true);\n\t\t\t\t\t\t\t\tendAddress = saveKey(options.end, store.encoder.writeKey, iterable, maxKeySize);\n\t\t\t\t\t\t\t} else if ((!options.start || options.start instanceof Uint8Array) && (!options.end || options.end instanceof Uint8Array)) {\n\t\t\t\t\t\t\t\tstartAddress = saveKey(options.start, orderedBinary.writeKey, iterable, maxKeySize);\n\t\t\t\t\t\t\t\tkeyBytesView.setFloat64(START_ADDRESS_POSITION, startAddress, true);\n\t\t\t\t\t\t\t\tendAddress = saveKey(options.end, orderedBinary.writeKey, iterable, maxKeySize);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthrow new Error('Only key-based encoding is supported for start/end values');\n\t\t\t\t\t\t\t\tlet encoded = store.encoder.encode(options.start);\n\t\t\t\t\t\t\t\tlet bufferAddress = encoded.buffer.address || (encoded.buffer.address = getAddress(encoded.buffer) - encoded.byteOffset);\n\t\t\t\t\t\t\t\tstartAddress = bufferAddress + encoded.byteOffset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else\n\t\t\t\t\t\tendAddress = saveKey(options.end, store.writeKey, iterable, maxKeySize);\n\t\t\t\t\treturn doPosition(cursorAddress, flags, offset || 0, keySize, endAddress);\n\t\t\t\t}\n\n\t\t\t\tfunction finishCursor() {\n\t\t\t\t\tif (txn.isDone)\n\t\t\t\t\t\treturn;\n\t\t\t\t\tif (iterable.onDone)\n\t\t\t\t\t\titerable.onDone()\n\t\t\t\t\tif (cursorRenewId)\n\t\t\t\t\t\ttxn.renewingRefCount--;\n\t\t\t\t\tif (--txn.refCount <= 0 && txn.notCurrent) {\n\t\t\t\t\t\tcursor.close();\n\t\t\t\t\t\ttxn.abort(); // this is no longer main read txn, abort it now that we are done\n\t\t\t\t\t\ttxn.isDone = true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (db.availableCursor || txn != readTxn) {\n\t\t\t\t\t\t\tcursor.close();\n\t\t\t\t\t\t} else { // try to reuse it\n\t\t\t\t\t\t\tdb.availableCursor = cursor;\n\t\t\t\t\t\t\tdb.cursorTxn = txn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn {\n\t\t\t\t\tnext() {\n\t\t\t\t\t\tlet keySize, lastSize;\n\t\t\t\t\t\tif (cursorRenewId && (cursorRenewId != renewId || txn.isDone)) {\n\t\t\t\t\t\t\tresetCursor();\n\t\t\t\t\t\t\tkeySize = position(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (count === 0) { // && includeValues) // on first entry, get current value if we need to\n\t\t\t\t\t\t\tkeySize = position(options.offset);\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tkeySize = iterate(cursorAddress);\n\t\t\t\t\t\tif (keySize <= 0 ||\n\t\t\t\t\t\t\t\t(count++ >= limit)) {\n\t\t\t\t\t\t\tif (count < 0)\n\t\t\t\t\t\t\t\tlmdbError(count);\n\t\t\t\t\t\t\tfinishCursor();\n\t\t\t\t\t\t\treturn ITERATOR_DONE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!valuesForKey || snapshot === false) {\n\t\t\t\t\t\t\tif (keySize > 20000) {\n\t\t\t\t\t\t\t\tif (keySize > 0x1000000)\n\t\t\t\t\t\t\t\t\tlmdbError(keySize - 0x100000000)\n\t\t\t\t\t\t\t\tthrow new Error('Invalid key size ' + keySize.toString(16))\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcurrentKey = store.readKey(keyBytes, 32, keySize + 32);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (includeValues) {\n\t\t\t\t\t\t\tlet value;\n\t\t\t\t\t\t\tlastSize = keyBytesView.getUint32(0, true);\n\t\t\t\t\t\t\tlet bufferId = keyBytesView.getUint32(4, true);\n\t\t\t\t\t\t\tlet bytes;\n\t\t\t\t\t\t\tif (bufferId) {\n\t\t\t\t\t\t\t\tbytes = getMMapBuffer(bufferId, lastSize);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tbytes = compression ? compression.getValueBytes : getValueBytes;\n\t\t\t\t\t\t\t\tif (lastSize > bytes.maxLength) {\n\t\t\t\t\t\t\t\t\tstore.lastSize = lastSize;\n\t\t\t\t\t\t\t\t\tasSafeBuffer = store.encoding == 'binary';\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\tbytes = store._returnLargeBuffer(() => getCurrentValue(cursorAddress));\n\t\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t\tasSafeBuffer = false;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else\n\t\t\t\t\t\t\t\t\tbytes.length = lastSize;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (store.decoder) {\n\t\t\t\t\t\t\t\tvalue = store.decoder.decode(bytes, lastSize);\n\t\t\t\t\t\t\t} else if (store.encoding == 'binary')\n\t\t\t\t\t\t\t\tvalue = bytes.isGlobal ? Uint8ArraySlice.call(bytes, 0, lastSize) : bytes;\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tvalue = bytes.toString('utf8', 0, lastSize);\n\t\t\t\t\t\t\t\tif (store.encoding == 'json' && value)\n\t\t\t\t\t\t\t\t\tvalue = JSON.parse(value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (includeVersions)\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\tkey: currentKey,\n\t\t\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t\t\t\tversion: getLastVersion()\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n \t\t\t\t\t\t\telse if (valuesForKey)\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tvalue\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\t\tkey: currentKey,\n\t\t\t\t\t\t\t\t\t\tvalue,\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else if (includeVersions) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tvalue: {\n\t\t\t\t\t\t\t\t\tkey: currentKey,\n\t\t\t\t\t\t\t\t\tversion: getLastVersion()\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tvalue: currentKey\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\treturn() {\n\t\t\t\t\t\tfinishCursor();\n\t\t\t\t\t\treturn ITERATOR_DONE;\n\t\t\t\t\t},\n\t\t\t\t\tthrow() {\n\t\t\t\t\t\tfinishCursor();\n\t\t\t\t\t\treturn ITERATOR_DONE;\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\t\t\treturn iterable;\n\t\t},\n\n\t\tgetMany(keys, callback) {\n\t\t\t// this is an asynchronous get for multiple keys. It actually works by prefetching asynchronously,\n\t\t\t// allowing a separate to absorb the potentially largest cost: hard page faults (and disk I/O).\n\t\t\t// And then we just do standard sync gets (to deserialized data) to fulfil the callback/promise\n\t\t\t// once the prefetch occurs\n\t\t\tlet promise = callback ? undefined : new Promise(resolve => callback = (error, results) => resolve(results));\n\t\t\tthis.prefetch(keys, () => {\n\t\t\t\tlet results = new Array(keys.length);\n\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\tresults[i] = get.call(this, keys[i]);\n\t\t\t\t}\n\t\t\t\tcallback(null, results);\n\t\t\t});\n\t\t\treturn promise;\n\t\t},\n\t\tgetSharedBufferForGet(id, options) {\n\t\t\tlet txn = env.writeTxn || (options && options.transaction) || (readTxnRenewed ? readTxn : renewReadTxn(this));\n\t\t\tthis.lastSize = this.keyIsCompatibility ? txn.getBinaryShared(id) : this.db.get(this.writeKey(id, keyBytes, 0));\n\t\t\tif (this.lastSize === -30798) { // not found code\n\t\t\t\treturn; //undefined\n\t\t\t}\n\t\t\treturn this.lastSize;\n\t\t\tthis.lastSize = keyBytesView.getUint32(0, true);\n\t\t\tlet bufferIndex = keyBytesView.getUint32(12, true);\n\t\t\tlastOffset = keyBytesView.getUint32(8, true);\n\t\t\tlet buffer = buffers[bufferIndex];\n\t\t\tlet startOffset;\n\t\t\tif (!buffer || lastOffset < (startOffset = buffer.startOffset) || (lastOffset + this.lastSize > startOffset + 0x100000000)) {\n\t\t\t\tif (buffer)\n\t\t\t\t\tenv.detachBuffer(buffer.buffer);\n\t\t\t\tstartOffset = (lastOffset >>> 16) * 0x10000;\n\t\t\t\tconsole.log('make buffer for address', bufferIndex * 0x100000000 + startOffset);\n\t\t\t\tbuffer = buffers[bufferIndex] = Buffer.from(getBufferForAddress(bufferIndex * 0x100000000 + startOffset));\n\t\t\t\tbuffer.startOffset = startOffset;\n\t\t\t}\n\t\t\tlastOffset -= startOffset;\n\t\t\treturn buffer;\n\t\t\treturn buffer.slice(lastOffset, lastOffset + this.lastSize);/*Uint8ArraySlice.call(buffer, lastOffset, lastOffset + this.lastSize)*/\n\t\t},\n\t\tprefetch(keys, callback) {\n\t\t\tif (!keys)\n\t\t\t\tthrow new Error('An array of keys must be provided');\n\t\t\tif (!keys.length) {\n\t\t\t\tif (callback) {\n\t\t\t\t\tcallback(null);\n\t\t\t\t\treturn;\n\t\t\t\t} else\n\t\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\t\t\tlet buffers = [];\n\t\t\tlet startPosition;\n\t\t\tlet bufferHolder = {};\n\t\t\tlet lastBuffer;\n\t\t\tfor (let key of keys) {\n\t\t\t\tlet position\n\t\t\t\tif (key && key.key !== undefined && key.value !== undefined) {\n\t\t\t\t\tposition = saveKey(key.value, this.writeKey, bufferHolder, maxKeySize, 0x80000000);\n\t\t\t\t\tsaveKey(key.key, this.writeKey, bufferHolder, maxKeySize);\n\t\t\t\t} else {\n\t\t\t\t\tposition = saveKey(key, this.writeKey, bufferHolder, maxKeySize);\n\t\t\t\t}\n\t\t\t\tif (!startPosition)\n\t\t\t\t\tstartPosition = position;\n\t\t\t\tif (bufferHolder.saveBuffer != lastBuffer) {\n\t\t\t\t\tbuffers.push(bufferHolder);\n\t\t\t\t\tlastBuffer = bufferHolder.saveBuffer;\n\t\t\t\t\tbufferHolder = { saveBuffer: lastBuffer };\n\t\t\t\t}\n\t\t\t}\n\t\t\tsaveKey(undefined, this.writeKey, bufferHolder, maxKeySize);\n\t\t\toutstandingReads++;\n\t\t\tprefetch(this.dbAddress, startPosition, (error) => {\n\t\t\t\toutstandingReads--;\n\t\t\t\tif (error)\n\t\t\t\t\tconsole.error('Error with prefetch', buffers, bufferHolder); // partly exists to keep the buffers pinned in memory\n\t\t\t\telse\n\t\t\t\t\tcallback(null);\n\t\t\t});\n\t\t\tif (!callback)\n\t\t\t\treturn new Promise(resolve => callback = resolve);\n\t\t},\n\t\tuseReadTransaction() {\n\t\t\tlet txn = readTxnRenewed ? readTxn : renewReadTxn(this);\n\t\t\ttxn.use();\n\t\t\treturn txn;\n\t\t},\n\t\tclose(callback) {\n\t\t\tthis.status = 'closing';\n\t\t\tlet txnPromise;\n\t\t\tif (this.isRoot) {\n\t\t\t\t// if it is root, we need to abort and/or wait for transactions to finish\n\t\t\t\tif (readTxn) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\treadTxn.abort();\n\t\t\t\t\t} catch(error) {}\n\t\t\t\t}\n\t\t\t\treadTxn = {\n\t\t\t\t\trenew() {\n\t\t\t\t\t\tthrow new Error('Can not read from a closed database');\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\treadTxnRenewed = null;\n\t\t\t\ttxnPromise = this._endWrites && this._endWrites();\n\t\t\t}\n\t\t\tconst doClose = () => {\n\t\t\t\tif (this.isRoot) {\n\t\t\t\t\tif (outstandingReads > 0) {\n\t\t\t\t\t\treturn new Promise(resolve => setTimeout(() => resolve(doClose()), 1));\n\t\t\t\t\t}\n\t\t\t\t\tenv.address = 0;\n\t\t\t\t\tenv.close();\n\t\t\t\t} else\n\t\t\t\t\tthis.db.close();\n\t\t\t\tthis.status = 'closed';\n\t\t\t\tif (callback)\n\t\t\t\t\tcallback();\n\t\t\t}\n\t\t\tif (txnPromise)\n\t\t\t\treturn txnPromise.then(doClose);\n\t\t\telse {\n\t\t\t\tdoClose();\n\t\t\t\treturn Promise.resolve();\n\t\t\t}\n\t\t},\n\t\tgetStats() {\n\t\t\tlet txn = env.writeTxn || (readTxnRenewed ? readTxn : renewReadTxn(this));\n\t\t\tlet dbStats = this.db.stat();\n\t\t\tdbStats.root = env.stat();\n\t\t\tObject.assign(dbStats, env.info());\n\t\t\tdbStats.free = env.freeStat();\n\t\t\treturn dbStats;\n\t\t},\n\t});\n\tlet get = LMDBStore.prototype.get;\n\tlet lastReadTxnRef;\n\tfunction getMMapBuffer(bufferId, size) {\n\t\tlet buffer = mmaps[bufferId];\n\t\tif (!buffer) {\n\t\t\tbuffer = mmaps[bufferId] = getSharedBuffer(bufferId, env.address);\n\t\t}\n\t\tlet offset = keyBytesView.getUint32(8, true);\n\t\treturn new Uint8Array(buffer, offset, size);\n\t}\n\tfunction renewReadTxn(store) {\n\t\tif (!readTxn) {\n\t\t\tlet retries = 0;\n\t\t\tlet waitArray;\n\t\t\tdo {\n\t\t\t\ttry {\n\t\t\t\t\tlet lastReadTxn = lastReadTxnRef && lastReadTxnRef.deref();\n\t\t\t\t\treadTxn = new Txn(env, 0x20000, lastReadTxn && !lastReadTxn.isDone && lastReadTxn);\n\t\t\t\t\tif (readTxn.address == 0) {\n\t\t\t\t\t\treadTxn = lastReadTxn;\n\t\t\t\t\t\tif (readTxn.notCurrent)\n\t\t\t\t\t\t\treadTxn.notCurrent = false;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (error.message.includes('temporarily')) {\n\t\t\t\t\t\tif (!waitArray)\n\t\t\t\t\t\t\twaitArray = new Int32Array(new SharedArrayBuffer(4), 0, 1);\n\t\t\t\t\t\tAtomics.wait(waitArray, 0, 0, retries * 2);\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t} while (retries++ < 100);\n\t\t}\n\t\t// we actually don't renew here, we let the renew take place in the next \n\t\t// lmdb native read/call so as to avoid an extra native call\n\t\treadTxnRenewed = setTimeout(resetReadTxn, 0);\n\t\tstore.emit('begin-transaction');\n\t\treturn readTxn;\n\t}\n\tfunction resetReadTxn() {\n\t\trenewId++;\n\t\tif (readTxnRenewed) {\n\t\t\treadTxnRenewed = null;\n\t\t\tif (readTxn.refCount - (readTxn.renewingRefCount || 0) > 0) {\n\t\t\t\treadTxn.notCurrent = true;\n\t\t\t\tlastReadTxnRef = new WeakRef(readTxn);\n\t\t\t\treadTxn = null;\n\t\t\t} else {\n\t\t\t\tresetTxn(readTxn.address);\n\t\t\t}\n\t\t}\n\t}\n}\nexport function makeReusableBuffer(size) {\n\tlet bytes = typeof Buffer != 'undefined' ? Buffer.alloc(size) : new Uint8Array(size);\n\tbytes.maxLength = size;\n\tObject.defineProperty(bytes, 'length', { value: size, writable: true, configurable: true });\n\treturn bytes;\n}\n\nTxn.prototype.done = function() {\n\tthis.refCount--;\n\tif (this.refCount === 0 && this.notCurrent) {\n\t\tthis.abort();\n\t\tthis.isDone = true;\n\t}\n}\nTxn.prototype.use = function() {\n\tthis.refCount = (this.refCount || 0) + 1;\n}\n\n\nlet readInstructions, readCallbacks = new Map(), uint32Instructions, instructionsDataView = { setFloat64() {}, setUint32() {} }, instructionsAddress;\nlet savePosition = 8000;\nlet DYNAMIC_KEY_BUFFER_SIZE = 8192;\nfunction allocateInstructionsBuffer() {\n\treadInstructions = typeof Buffer != 'undefined' ? Buffer.alloc(DYNAMIC_KEY_BUFFER_SIZE) : new Uint8Array(DYNAMIC_KEY_BUFFER_SIZE);\n\tuint32Instructions = new Int32Array(readInstructions.buffer, 0, readInstructions.buffer.byteLength >> 2);\n\tuint32Instructions[2] = 0xf0000000; // indicates a new read task must be started\n\tinstructionsAddress = readInstructions.buffer.address = getAddress(readInstructions.buffer);\n\treadInstructions.dataView = instructionsDataView = new DataView(readInstructions.buffer, readInstructions.byteOffset, readInstructions.byteLength);\n\tsavePosition = 0;\n}\nexport function recordReadInstruction(txnAddress, dbi, key, writeKey, maxKeySize, callback) {\n\tif (savePosition > 7800) {\n\t\tallocateInstructionsBuffer();\n\t}\n\tlet start = savePosition;\n\tlet keyPosition = savePosition + 16;\n\ttry {\n\t\tsavePosition = key === undefined ? keyPosition :\n\t\t\twriteKey(key, readInstructions, keyPosition);\n\t} catch (error) {\n\t\tif (error.name == 'RangeError') {\n\t\t\tif (8180 - start < maxKeySize) {\n\t\t\t\tallocateInstructionsBuffer(); // try again:\n\t\t\t\treturn recordReadInstruction(txnAddress, dbi, key, writeKey, maxKeySize, callback);\n\t\t\t}\n\t\t\tthrow new Error('Key was too large, max key size is ' + maxKeySize);\n\t\t} else\n\t\t\tthrow error;\n\t}\n\tlet length = savePosition - keyPosition;\n\tif (length > maxKeySize) {\n\t\tsavePosition = start;\n\t\tthrow new Error('Key of size ' + length + ' was too large, max key size is ' + maxKeySize);\n\t}\n\tuint32Instructions[(start >> 2) + 3] = length; // save the length\n\tuint32Instructions[(start >> 2) + 2] = dbi;\n\tsavePosition = (savePosition + 12) & 0xfffffc;\n\tinstructionsDataView.setFloat64(start, txnAddress, true);\n\tlet callbackId = addReadCallback(() => {\n\t\tlet position = start >> 2;\n\t\tlet rc = thisInstructions[position];\n\t\tcallback(rc, thisInstructions[position + 1], thisInstructions[position + 2], thisInstructions[position + 3]);\n\t});\n\tlet thisInstructions = uint32Instructions;\n\t//if (start === 0)\n\t\treturn startRead(instructionsAddress + start, callbackId, {}, 'read');\n\t//else\n\t\t//nextRead(start);\n}\nlet nextCallbackId = 0;\nlet addReadCallback = globalThis.__lmdb_read_callback;\nif (!addReadCallback) {\n\taddReadCallback = globalThis.__lmdb_read_callback = function(callback) {\n\t\tlet callbackId = nextCallbackId++;\n\t\treadCallbacks.set(callbackId, callback);\n\t\treturn callbackId;\n\t};\n\tsetReadCallback(function(callbackId) {\n\t\treadCallbacks.get(callbackId)();\n\t\treadCallbacks.delete(callbackId);\n\t})\n}\n","import { WeakLRUCache, clearKeptObjects } from './native.js';\nimport { FAILED_CONDITION, ABORT, IF_EXISTS } from './write.js';\nimport { UNMODIFIED } from './read.js';\nimport { when } from './util/when.js';\n\nlet getLastVersion, getLastTxnId;\nconst mapGet = Map.prototype.get;\nexport const CachingStore = (Store, env) => {\n\tlet childTxnChanges\n\treturn class LMDBStore extends Store {\n\tconstructor(dbName, options) {\n\t\tsuper(dbName, options);\n\t\tif (!env.cacheCommitter) {\n\t\t\tenv.cacheCommitter = true;\n\t\t\tthis.on('aftercommit', ({ next, last, txnId }) => {\n\t\t\t\tdo {\n\t\t\t\t\tlet meta = next.meta;\n\t\t\t\t\tlet store = meta && meta.store;\n\t\t\t\t\tif (store) {\n\t\t\t\t\t\tif (next.flag & FAILED_CONDITION)\n\t\t\t\t\t\t\tstore.cache.delete(meta.key); // just delete it from the map\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlet expirationPriority = meta.valueSize >> 10;\n\t\t\t\t\t\t\tlet cache = store.cache;\n\t\t\t\t\t\t\tlet entry = mapGet.call(cache, meta.key);\n\t\t\t\t\t\t\tif (entry) {\n\t\t\t\t\t\t\t\tentry.txnId = txnId;\n\t\t\t\t\t\t\t\tcache.used(entry, expirationPriority + 4); // this will enter it into the LRFU (with a little lower priority than a read)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} while (next != last && (next = next.next))\n\t\t\t});\n\t\t}\n\t\tthis.db.cachingDb = this;\n\t\tif (options.cache.clearKeptInterval)\n\t\t\toptions.cache.clearKeptObjects = clearKeptObjects;\n\t\tthis.cache = new WeakLRUCache(options.cache);\n\t\tif (options.cache.validated)\n\t\t\tthis.cache.validated = true;\n\t}\n\tget isCaching() {\n\t\treturn true\n\t}\n\tget(id, options) {\n\t\tlet value;\n\t\tif (this.cache.validated) {\n\t\t\tlet entry = this.cache.get(id);\n\t\t\tif (entry) {\n\t\t\t\tlet cachedValue = entry.value;\n\t\t\t\tif (entry.txnId != null) {\n\t\t\t\t\tvalue = super.get(id, { ifNotTxnId: entry.txnId, transaction: options && options.transaction });\n\t\t\t\t\tif (value === UNMODIFIED)\n\t\t\t\t\t\treturn cachedValue;\n\t\t\t\t} else // with no txn id we do not validate; this is the state of a cached value after a write before it transacts\n\t\t\t\t\treturn cachedValue;\n\t\t\t} else\n\t\t\t\tvalue = super.get(id, options);\n\t\t} else if (options && options.transaction) {\n\t\t\treturn super.get(id, options);\n\t\t} else {\n\t\t\tvalue = this.cache.getValue(id);\n\t\t\tif (value !== undefined) {\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tvalue = super.get(id);\n\t\t}\n\t\tif (value && typeof value === 'object' && !options && typeof id !== 'object') {\n\t\t\tlet entry = this.cache.setValue(id, value, this.lastSize >> 10);\n\t\t\tif (this.useVersions) {\n\t\t\t\tentry.version = getLastVersion();\n\t\t\t}\n\t\t\tif (this.cache.validated)\n\t\t\t\tentry.txnId = getLastTxnId();\n\t\t}\n\t\treturn value;\n\t}\n\tgetEntry(id, options) {\n\t\tlet entry, value;\n\t\tif (this.cache.validated) {\n\t\t\tentry = this.cache.get(id);\n\t\t\tif (entry) {\n\t\t\t\tif (entry.txnId != null) {\n\t\t\t\t\tvalue = super.get(id, { ifNotTxnId: entry.txnId, transaction: options && options.transaction });\n\t\t\t\t\tif (value === UNMODIFIED)\n\t\t\t\t\t\treturn entry;\n\t\t\t\t} else // with no txn id we do not validate; this is the state of a cached value after a write before it transacts\n\t\t\t\t\treturn entry;\n\t\t\t} else\n\t\t\t\tvalue = super.get(id, options);\n\t\t} else if (options && options.transaction) {\n\t\t\treturn super.getEntry(id, options);\n\t\t} else {\n\t\t\tentry = this.cache.get(id);\n\t\t\tif (entry !== undefined) {\n\t\t\t\treturn entry;\n\t\t\t}\n\t\t\tvalue = super.get(id);\n\t\t}\n\t\tif (value === undefined)\n\t\t\treturn;\n\t\tif (value && typeof value === 'object' && !options && typeof id !== 'object') {\n\t\t\tentry = this.cache.setValue(id, value, this.lastSize >> 10);\n\t\t} else\n\t\t\tentry = { value };\n\t\tif (this.useVersions)\n\t\t\tentry.version = getLastVersion();\n\t\tif (this.cache.validated)\n\t\t\tentry.txnId = getLastTxnId();\n\t\treturn entry;\n\t}\n\tputEntry(id, entry, ifVersion) {\n\t\tlet result = super.put(id, entry.value, entry.version, ifVersion);\n\t\tif (typeof id === 'object')\n\t\t\treturn result;\n\t\tif (result && result.then)\n\t\t\tthis.cache.setManually(id, entry); // set manually so we can keep it pinned in memory until it is committed\n\t\telse // sync operation, immediately add to cache\n\t\t\tthis.cache.set(id, entry);\n\t}\n\tput(id, value, version, ifVersion) {\n\t\tlet result = super.put(id, value, version, ifVersion);\n\t\tif (typeof id !== 'object') {\n\t\t\tif (value && value['\\x10binary-data\\x02']) {\n\t\t\t\t// don't cache binary data, since it will be decoded on get\n\t\t\t\tthis.cache.delete(id);\n\t\t\t\treturn result;\n\t\t\t}\t\n\t\t\t// sync operation, immediately add to cache, otherwise keep it pinned in memory until it is committed\n\t\t\tlet entry = this.cache.setValue(id, value, !result || result.isSync ? 0 : -1);\n\t\t\tif (childTxnChanges)\n\t\t\t\tchildTxnChanges.add(id);\n\t\t\tif (version !== undefined)\n\t\t\t\tentry.version = typeof version === 'object' ? version.version : version;\n\t\t}\n\t\treturn result;\n\t}\n\tputSync(id, value, version, ifVersion) {\n\t\tif (id !== 'object') {\n\t\t\t// sync operation, immediately add to cache, otherwise keep it pinned in memory until it is committed\n\t\t\tif (value && typeof value === 'object') {\n\t\t\t\tlet entry = this.cache.setValue(id, value);\n\t\t\t\tif (childTxnChanges)\n\t\t\t\t\tchildTxnChanges.add(id);\n\t\t\t\tif (version !== undefined) {\n\t\t\t\t\tentry.version = typeof version === 'object' ? version.version : version;\n\t\t\t\t}\n\t\t\t} else // it is possible that  a value used to exist here\n\t\t\t\tthis.cache.delete(id);\n\t\t}\n\t\treturn super.putSync(id, value, version, ifVersion);\n\t}\n\tremove(id, ifVersion) {\n\t\tthis.cache.delete(id);\n\t\treturn super.remove(id, ifVersion);\n\t}\n\tremoveSync(id, ifVersion) {\n\t\tthis.cache.delete(id);\n\t\treturn super.removeSync(id, ifVersion);\n\t}\n\tclearAsync(callback) {\n\t\tthis.cache.clear();\n\t\treturn super.clearAsync(callback);\n\t}\n\tclearSync() {\n\t\tthis.cache.clear();\n\t\tsuper.clearSync();\n\t}\n\tchildTransaction(callback) {\n\t\treturn super.childTransaction(() => {\n\t\t\tlet cache = this.cache;\n\t\t\tlet previousChanges = childTxnChanges;\n\t\t\ttry {\n\t\t\t\tchildTxnChanges = new Set();\n\t\t\t\treturn when(callback(), (result) => {\n\t\t\t\t\tif (result === ABORT)\n\t\t\t\t\t\treturn abort();\n\t\t\t\t\tchildTxnChanges = previousChanges;\n\t\t\t\t\treturn result;\n\t\t\t\t}, abort);\n\t\t\t} catch(error) {\n\t\t\t\tabort(error);\n\t\t\t}\n\t\t\tfunction abort(error) {\n\t\t\t\t// if the transaction was aborted, remove all affected entries from cache\n\t\t\t\tfor (let id of childTxnChanges)\n\t\t\t\t\tcache.delete(id);\n\t\t\t\tchildTxnChanges = previousChanges;\n\t\t\t\tif (error)\n\t\t\t\t\tthrow error;\n\t\t\t\telse\n\t\t\t\t\treturn ABORT;\n\t\t\t}\n\t\t});\n\t}\n\tdoesExist(key, versionOrValue) {\n\t\tlet entry = this.cache.get(key);\n\t\tif (entry) {\n\t\t\tif (versionOrValue == null) {\n\t\t\t\treturn versionOrValue !== null;\n\t\t\t} else if (this.useVersions) {\n\t\t\t\treturn versionOrValue === IF_EXISTS || entry.version === versionOrValue;\n\t\t\t}\n\t\t}\n\t\treturn super.doesExist(key, versionOrValue);\n\t}\n\t};\n};\nexport function setGetLastVersion(get, getTxnId) {\n\tgetLastVersion = get;\n\tgetLastTxnId = getTxnId;\n}\n","import { Compression, getAddress, arch, fs, path as pathModule, lmdbError, EventEmitter, MsgpackrEncoder, Env,\n\tDbi, tmpdir, os, nativeAddon } from './native.js';\nimport { CachingStore, setGetLastVersion } from './caching.js';\nimport { addReadMethods, makeReusableBuffer } from './read.js';\nimport { addWriteMethods } from './write.js';\nimport { applyKeyHandling } from './keys.js';\nlet moduleRequire = typeof require == 'function' && require;\nexport function setRequire(require) {\n\tmoduleRequire = require;\n}\n\nsetGetLastVersion(getLastVersion, getLastTxnId);\nlet keyBytes, keyBytesView;\nconst buffers = [];\nconst { onExit, getEnvsPointer, setEnvsPointer, getEnvFlags, setJSFlags } = nativeAddon;\nif (globalThis.__lmdb_envs__)\n\tsetEnvsPointer(globalThis.__lmdb_envs__);\nelse\n\tglobalThis.__lmdb_envs__ = getEnvsPointer();\n\n// this is hard coded as an upper limit because it is important assumption of the fixed buffers in writing instructions\n// this corresponds to the max key size for 8KB pages\nconst MAX_KEY_SIZE = 4026;\n// this is used as the key size by default because default page size is OS page size, which is usually\n// 4KB (but is 16KB on M-series MacOS), and this keeps a consistent max key size when no page size specified.\nconst DEFAULT_MAX_KEY_SIZE = 1978;\nconst DEFAULT_COMMIT_DELAY = 0;\n\nexport const allDbs = new Map();\nlet defaultCompression;\nlet lastSize;\nlet hasRegisteredOnExit;\nexport function open(path, options) {\n\tif (nativeAddon.open) {\n\t\tif (nativeAddon.open !== open) {\n\t\t\t// this is the case when lmdb-js has been opened in both ESM and CJS mode, which means that there are two\n\t\t\t// separate JS modules, but they are both using the same native module.\n\t\t\tgetLastVersion = nativeAddon.getLastVersion;\n\t\t\tgetLastTxnId = nativeAddon.getLastTxnId;\n\t\t\tsetGetLastVersion(getLastVersion, getLastTxnId);\n\t\t\treturn nativeAddon.open(path, options);\n\t\t}\n\t} else {\n\t\tnativeAddon.open = open;\n\t\tnativeAddon.getLastVersion = getLastVersion;\n\t\tnativeAddon.getLastTxnId = getLastTxnId;\n\t}\n\tif (!keyBytes) // TODO: Consolidate get buffer and key buffer (don't think we need both)\n\t\tallocateFixedBuffer();\n\tif (typeof path == 'object' && !options) {\n\t\toptions = path;\n\t\tpath = options.path;\n\t}\n\toptions = options || {};\n\tlet noFSAccess = options.noFSAccess; // this can only be configured on open, can't let users change it\n\tlet userOptions = options;\n\tif (!path) {\n\t\toptions = Object.assign({\n\t\t\tdeleteOnClose: true,\n\t\t\tnoSync: true,\n\t\t}, options);\n\t\tpath = tmpdir() + '/' + Math.floor(Math.random() * 2821109907455).toString(36) + '.mdb'\n\t} else if (!options)\n\t\toptions = {};\n\tlet extension = pathModule.extname(path);\n\tlet name = pathModule.basename(path, extension);\n\tlet is32Bit = arch().endsWith('32');\n\tlet remapChunks = options.remapChunks || options.encryptionKey || (options.mapSize ?\n\t\t(is32Bit && options.mapSize > 0x100000000) : // larger than fits in address space, must use dynamic maps\n\t\tis32Bit); // without a known map size, we default to being able to handle large data correctly/well*/\n\tlet userMapSize = options.mapSize;\n\toptions = Object.assign({\n\t\tpath,\n\t\tnoSubdir: Boolean(extension),\n\t\tisRoot: true,\n\t\tmaxDbs: 12,\n\t\tremapChunks,\n\t\tkeyBytes,\n\t\toverlappingSync: (options.noSync || options.readOnly) ? false : (os != 'win32'),\n\t\t// default map size limit of 4 exabytes when using remapChunks, since it is not preallocated and we can\n\t\t// make it super huge.\n\t\tmapSize: remapChunks ? 0x10000000000000 :\n\t\t\t0x20000, // Otherwise we start small with 128KB\n\t\tsafeRestore: process.env.LMDB_RESTORE == 'safe',\n\t}, options);\n\tif (options.asyncTransactionOrder == 'strict') {\n\t\toptions.strictAsyncOrder = true;\n\t}\n\tif (nativeAddon.version.major + nativeAddon.version.minor / 100 + nativeAddon.version.patch / 10000 < 0.0980) {\n\t\toptions.overlappingSync = false; // not support on older versions\n\t\toptions.trackMetrics = false;\n\t\toptions.usePreviousSnapshot = false;\n\t\toptions.safeRestore = false;\n\t\toptions.remapChunks = false;\n\t\tif (!userMapSize) options.mapSize = 0x40000000; // 1 GB\n\t}\n\n\tif (!exists(options.noSubdir ? pathModule.dirname(path) : path))\n\t\tfs.mkdirSync(options.noSubdir ? pathModule.dirname(path) : path, { recursive: true }\n\t\t);\n\tfunction makeCompression(compressionOptions) {\n\t\tif (compressionOptions instanceof Compression)\n\t\t\treturn compressionOptions;\n\t\tlet useDefault = typeof compressionOptions != 'object';\n\t\tif (useDefault && defaultCompression)\n\t\t\treturn defaultCompression;\n\t\tcompressionOptions = Object.assign({\n\t\t\tthreshold: 1000,\n\t\t\tdictionary: fs.readFileSync(new URL('./dict/dict.txt', import.meta.url.replace(/dist[\\\\\\/]index.cjs$/, ''))),\n\t\t\tgetValueBytes: makeReusableBuffer(0),\n\t\t}, compressionOptions);\n\t\tlet compression = Object.assign(new Compression(compressionOptions), compressionOptions);\n\t\tif (useDefault)\n\t\t\tdefaultCompression = compression;\n\t\treturn compression;\n\t}\n\n\tif (options.compression)\n\t\toptions.compression = makeCompression(options.compression);\n\tlet flags =\n\t\t(options.overlappingSync ? 0x1000 : 0) |\n\t\t(options.noSubdir ? 0x4000 : 0) |\n\t\t(options.noSync ? 0x10000 : 0) |\n\t\t(options.readOnly ? 0x20000 : 0) |\n\t\t(options.noMetaSync ? 0x40000 : 0) |\n\t\t(options.useWritemap ? 0x80000 : 0) |\n\t\t(options.mapAsync ? 0x100000 : 0) |\n\t\t(options.noReadAhead ? 0x800000 : 0) |\n\t\t(options.noMemInit ? 0x1000000 : 0) |\n\t\t(options.usePreviousSnapshot ? 0x2000000 : 0) |\n\t\t(options.remapChunks ? 0x4000000 : 0) |\n\t\t(options.safeRestore ? 0x800 : 0) |\n\t\t(options.trackMetrics ? 0x400 : 0);\n\n\tlet env = new Env();\n\tlet jsFlags = (options.overlappingSync ? 0x1000 : 0) |\n\t\t(options.separateFlushed ? 1 : 0) |\n\t\t(options.deleteOnClose ? 2 : 0);\n\tlet rc = env.open(options, flags, jsFlags);\n\tenv.path = path;\n   if (rc)\n\t\tlmdbError(rc);\n\tdelete options.keyBytes // no longer needed, don't copy to stores\n\tlet maxKeySize = env.getMaxKeySize();\n\tmaxKeySize = Math.min(maxKeySize, options.pageSize ? MAX_KEY_SIZE : DEFAULT_MAX_KEY_SIZE);\n\tflags = getEnvFlags(env.address); // re-retrieve them, they are not necessarily the same if we are connecting to an existing env\n\tif (flags & 0x1000) {\n\t\tif (userOptions.noSync) {\n\t\t\tenv.close();\n\t\t\tthrow new Error('Can not set noSync on a database that was opened with overlappingSync');\n\t\t}\n\t} else if (options.overlappingSync) {\n\t\tif (userOptions.overlappingSync) {\n\t\t\tenv.close();\n\t\t\tthrow new Error('Can not enable overlappingSync on a database that was opened without this flag');\n\t\t}\n\t\toptions.overlappingSync = false;\n\t\tjsFlags = jsFlags & 0xff; // clear overlapping sync\n\t\tsetJSFlags(env.address, jsFlags);\n\t}\n\n\tenv.readerCheck(); // clear out any stale entries\n\tif ((options.overlappingSync || options.deleteOnClose) && !hasRegisteredOnExit && process.on) {\n\t\thasRegisteredOnExit = true;\n\t\tprocess.on('exit', onExit);\n\t}\n\n\tclass LMDBStore extends EventEmitter {\n\t\tconstructor(dbName, dbOptions) {\n\t\t\tsuper();\n\t\t\tif (dbName === undefined)\n\t\t\t\tthrow new Error('Database name must be supplied in name property (may be null for root database)');\n\n\t\t\tif (options.compression && dbOptions.compression !== false && typeof dbOptions.compression != 'object')\n\t\t\t\tdbOptions.compression = options.compression; // use the parent compression if available\n\t\t\telse if (dbOptions.compression)\n\t\t\t\tdbOptions.compression = makeCompression(dbOptions.compression);\n\n\t\t\tif (dbOptions.dupSort && (dbOptions.useVersions || dbOptions.cache)) {\n\t\t\t\tthrow new Error('The dupSort flag can not be combined with versions or caching');\n\t\t\t}\n\t\t\tlet keyIsBuffer = dbOptions.keyIsBuffer\n\t\t\tif (dbOptions.keyEncoding == 'uint32') {\n\t\t\t\tdbOptions.keyIsUint32 = true;\n\t\t\t} else if (dbOptions.keyEncoder) {\n\t\t\t\tif (dbOptions.keyEncoder.enableNullTermination) {\n\t\t\t\t\tdbOptions.keyEncoder.enableNullTermination()\n\t\t\t\t} else\n\t\t\t\t\tkeyIsBuffer = true;\n\t\t\t} else if (dbOptions.keyEncoding == 'binary') {\n\t\t\t\tkeyIsBuffer = true;\n\t\t\t}\n\t\t\tlet flags = (dbOptions.reverseKey ? 0x02 : 0) |\n\t\t\t\t(dbOptions.dupSort ? 0x04 : 0) |\n\t\t\t\t(dbOptions.dupFixed ? 0x10 : 0) |\n\t\t\t\t(dbOptions.integerDup ? 0x20 : 0) |\n\t\t\t\t(dbOptions.reverseDup ? 0x40 : 0) |\n\t\t\t\t(!options.readOnly && dbOptions.create !== false ? 0x40000 : 0) |\n\t\t\t\t(dbOptions.useVersions ? 0x100 : 0);\n\t\t\tlet keyType = (dbOptions.keyIsUint32 || dbOptions.keyEncoding == 'uint32') ? 2 : keyIsBuffer ? 3 : 0;\n\t\t\tif (keyType == 2)\n\t\t\t\tflags |= 0x08; // integer key\n\n\t\t\tif (options.readOnly) {\n\t\t\t\t// in read-only mode we use a read-only txn to open the database\n\t\t\t\t// TODO: LMDB is actually not entirely thread-safe when it comes to opening databases with\n\t\t\t\t// read-only transactions since there is a race condition on setting the update dbis that\n\t\t\t\t// occurs outside the lock\n\t\t\t\t// make sure we are using a fresh read txn, so we don't want to share with a cursor txn\n\t\t\t\tthis.resetReadTxn();\n\t\t\t\tthis.ensureReadTxn();\n\t\t\t\tthis.db = new Dbi(env, flags, dbName, keyType, dbOptions.compression);\n\t\t\t} else {\n\t\t\t\tthis.transactionSync(() => {\n\t\t\t\t\tthis.db = new Dbi(env, flags, dbName, keyType, dbOptions.compression);\n\t\t\t\t}, options.overlappingSync ? 0x10002 : 2); // no flush-sync, but synchronously commit\n\t\t\t}\n\t\t\tthis._commitReadTxn(); // current read transaction becomes invalid after opening another db\n\t\t\tif (!this.db || this.db.dbi == 0xffffffff) {// not found\n\t\t\t\tthrow new Error('Database not found')\n\t\t\t}\n\t\t\tthis.dbAddress = this.db.address\n\t\t\tthis.db.name = dbName || null;\n\t\t\tthis.name = dbName;\n\t\t\tthis.status = 'open';\n\t\t\tthis.env = env;\n\t\t\tthis.reads = 0;\n\t\t\tthis.writes = 0;\n\t\t\tthis.transactions = 0;\n\t\t\tthis.averageTransactionTime = 5;\n\t\t\tif (dbOptions.syncBatchThreshold)\n\t\t\t\tconsole.warn('syncBatchThreshold is no longer supported');\n\t\t\tif (dbOptions.immediateBatchThreshold)\n\t\t\t\tconsole.warn('immediateBatchThreshold is no longer supported');\n\t\t\tthis.commitDelay = DEFAULT_COMMIT_DELAY;\n\t\t\tObject.assign(this, { // these are the options that are inherited\n\t\t\t\tpath: options.path,\n\t\t\t\tencoding: options.encoding,\n\t\t\t\tstrictAsyncOrder: options.strictAsyncOrder,\n\t\t\t}, dbOptions);\n\t\t\tlet Encoder;\n\t\t\tif (this.encoder && this.encoder.Encoder) {\n\t\t\t\tEncoder = this.encoder.Encoder;\n\t\t\t\tthis.encoder = null; // don't copy everything from the module\n\t\t\t}\n\t\t\tif (!Encoder && !(this.encoder && this.encoder.encode) && (!this.encoding || this.encoding == 'msgpack' || this.encoding == 'cbor')) {\n\t\t\t\tEncoder = (this.encoding == 'cbor' ? moduleRequire('cbor-x').Encoder : MsgpackrEncoder);\n\t\t\t}\n\t\t\tif (Encoder) {\n\t\t\t\tthis.encoder = new Encoder(Object.assign(\n\t\t\t\t\tassignConstrainedProperties(['copyBuffers', 'getStructures', 'saveStructures', 'useFloat32', 'useRecords', 'structuredClone', 'variableMapSize', 'useTimestamp32', 'largeBigIntToFloat', 'encodeUndefinedAsNil', 'int64AsNumber', 'onInvalidDate', 'mapsAsObjects', 'useTag259ForMaps', 'pack', 'maxSharedStructures', 'shouldShareStructure', 'randomAccessStructure', 'freezeData'],\n\t\t\t\t\tthis.sharedStructuresKey ? this.setupSharedStructures() : {\n\t\t\t\t\t\tcopyBuffers: true, // need to copy any embedded buffers that are found since we use unsafe buffers\n\t\t\t\t\t}, options, dbOptions), this.encoder));\n\t\t\t}\n\t\t\tif (this.encoding == 'json') {\n\t\t\t\tthis.encoder = {\n\t\t\t\t\tencode: JSON.stringify,\n\t\t\t\t};\n\t\t\t} else if (this.encoder) {\n\t\t\t\tthis.decoder = this.encoder;\n\t\t\t\tthis.decoderCopies = !this.encoder.needsStableBuffer\n\t\t\t}\n\t\t\tthis.maxKeySize = maxKeySize;\n\t\t\tapplyKeyHandling(this);\n\t\t\tallDbs.set(dbName ? name + '-' + dbName : name, this);\n\t\t}\n\t\topenDB(dbName, dbOptions) {\n\t\t\tif (this.dupSort && this.name == null)\n\t\t\t\tthrow new Error('Can not open named databases if the main database is dupSort')\n\t\t\tif (typeof dbName == 'object' && !dbOptions) {\n\t\t\t\tdbOptions = dbName;\n\t\t\t\tdbName = dbOptions.name;\n\t\t\t} else\n\t\t\t\tdbOptions = dbOptions || {};\n\t\t\ttry {\n\t\t\t\treturn dbOptions.cache ?\n\t\t\t\t\tnew (CachingStore(LMDBStore, env))(dbName, dbOptions) :\n\t\t\t\t\tnew LMDBStore(dbName, dbOptions);\n\t\t\t} catch(error) {\n\t\t\t\tif (error.message == 'Database not found')\n\t\t\t\t\treturn; // return undefined to indicate db not found\n\t\t\t\tif (error.message.indexOf('MDB_DBS_FULL') > -1) {\n\t\t\t\t\terror.message += ' (increase your maxDbs option)';\n\t\t\t\t}\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t}\n\t\topen(dbOptions, callback) {\n\t\t\tlet db = this.openDB(dbOptions);\n\t\t\tif (callback)\n\t\t\t\tcallback(null, db);\n\t\t\treturn db;\n\t\t}\n\t\tbackup(path, compact) {\n\t\t\tif (noFSAccess)\n\t\t\t\treturn;\n\t\t\tfs.mkdirSync(pathModule.dirname(path), { recursive: true });\n\t\t\treturn new Promise((resolve, reject) => env.copy(path, false, (error) => {\n\t\t\t\tif (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t} else {\n\t\t\t\t\tresolve();\n\t\t\t\t}\n\t\t\t}));\n\t\t}\n\t\tisOperational() {\n\t\t\treturn this.status == 'open';\n\t\t}\n\t\tsync(callback) {\n\t\t\treturn env.sync(callback || function(error) {\n\t\t\t\tif (error) {\n\t\t\t\t\tconsole.error(error);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tdeleteDB() {\n\t\t\tconsole.warn('deleteDB() is deprecated, use drop or dropSync instead');\n\t\t\treturn this.dropSync();\n\t\t}\n\t\tdropSync() {\n\t\t\tthis.transactionSync(() =>\n\t\t\t\tthis.db.drop({\n\t\t\t\t\tjustFreePages: false\n\t\t\t\t}), options.overlappingSync ? 0x10002 : 2);\n\t\t}\n\t\tclear(callback) {\n\t\t\tif (typeof callback == 'function')\n\t\t\t\treturn this.clearAsync(callback);\n\t\t\tconsole.warn('clear() is deprecated, use clearAsync or clearSync instead');\n\t\t\tthis.clearSync();\n\t\t}\n\t\tclearSync() {\n\t\t\tif (this.encoder) {\n\t\t\t\tif (this.encoder.clearSharedData)\n\t\t\t\t\tthis.encoder.clearSharedData()\n\t\t\t\telse if (this.encoder.structures)\n\t\t\t\t\tthis.encoder.structures = []\n\t\t\t}\n\t\t\tthis.transactionSync(() =>\n\t\t\t\tthis.db.drop({\n\t\t\t\t\tjustFreePages: true\n\t\t\t\t}), options.overlappingSync ? 0x10002 : 2);\n\t\t}\n\t\treaderCheck() {\n\t\t\treturn env.readerCheck();\n\t\t}\n\t\treaderList() {\n\t\t\treturn env.readerList().join('');\n\t\t}\n\t\tsetupSharedStructures() {\n\t\t\tconst getStructures = () => {\n\t\t\t\tlet lastVersion; // because we are doing a read here, we may need to save and restore the lastVersion from the last read\n\t\t\t\tif (this.useVersions)\n\t\t\t\t\tlastVersion = getLastVersion();\n\t\t\t\tlet buffer = this.getBinary(this.sharedStructuresKey);\n\t\t\t\tif (this.useVersions)\n\t\t\t\t\tsetLastVersion(lastVersion);\n\t\t\t\treturn buffer && this.decoder.decode(buffer);\n\t\t\t};\n\t\t\treturn {\n\t\t\t\tsaveStructures: (structures, isCompatible) => {\n\t\t\t\t\treturn this.transactionSync(() => {\n\t\t\t\t\t\tlet existingStructuresBuffer = this.getBinary(this.sharedStructuresKey);\n\t\t\t\t\t\tlet existingStructures = existingStructuresBuffer && this.decoder.decode(existingStructuresBuffer);\n\t\t\t\t\t\tif (typeof isCompatible == 'function' ?\n\t\t\t\t\t\t\t\t!isCompatible(existingStructures) :\n\t\t\t\t\t\t\t\t(existingStructures && existingStructures.length != isCompatible))\n\t\t\t\t\t\t\treturn false; // it changed, we need to indicate that we couldn't update\n\t\t\t\t\t\tthis.put(this.sharedStructuresKey, structures);\n\t\t\t\t\t},  options.overlappingSync ? 0x10000 : 0);\n\t\t\t\t},\n\t\t\t\tgetStructures,\n\t\t\t\tcopyBuffers: true, // need to copy any embedded buffers that are found since we use unsafe buffers\n\t\t\t};\n\t\t}\n\t}\n\t// if caching class overrides putSync, don't want to double call the caching code\n\tconst putSync = LMDBStore.prototype.putSync;\n\tconst removeSync = LMDBStore.prototype.removeSync;\n\taddReadMethods(LMDBStore, { env, maxKeySize, keyBytes, keyBytesView, getLastVersion });\n\tif (!options.readOnly)\n\t\taddWriteMethods(LMDBStore, { env, maxKeySize, fixedBuffer: keyBytes,\n\t\t\tresetReadTxn: LMDBStore.prototype.resetReadTxn, ...options });\n\tLMDBStore.prototype.supports = {\n\t\tpermanence: true,\n\t\tbufferKeys: true,\n\t\tpromises: true,\n\t\tsnapshots: true,\n\t\tclear: true,\n\t\tstatus: true,\n\t\tdeferredOpen: true,\n\t\topenCallback: true,\t\n\t};\n\tlet Class = options.cache ? CachingStore(LMDBStore, env) : LMDBStore;\n\treturn options.asClass ? Class : new Class(options.name || null, options);\n}\nexport function openAsClass(path, options) {\n\tif (typeof path == 'object' && !options) {\n\t\toptions = path;\n\t\tpath = options.path;\n\t}\n\toptions = options || {};\n\toptions.asClass = true;\n\treturn open(path, options);\n}\n\nexport function getLastVersion() {\n\treturn keyBytesView.getFloat64(16, true);\n}\nexport function setLastVersion(version) {\n\treturn keyBytesView.setFloat64(16, version, true);\n}\n\nexport function getLastTxnId() {\n\treturn keyBytesView.getUint32(32, true);\n}\n\nconst KEY_BUFFER_SIZE = 4096;\nfunction allocateFixedBuffer() {\n\tkeyBytes = typeof Buffer != 'undefined' ? Buffer.allocUnsafeSlow(KEY_BUFFER_SIZE) : new Uint8Array(KEY_BUFFER_SIZE);\n\tconst keyBuffer = keyBytes.buffer;\n\tkeyBytesView = keyBytes.dataView || (keyBytes.dataView = new DataView(keyBytes.buffer, 0, KEY_BUFFER_SIZE)); // max key size is actually 4026\n\tkeyBytes.uint32 = new Uint32Array(keyBuffer, 0, KEY_BUFFER_SIZE >> 2);\n\tkeyBytes.float64 = new Float64Array(keyBuffer, 0, KEY_BUFFER_SIZE >> 3);\n\tkeyBytes.uint32.address = keyBytes.address = keyBuffer.address = getAddress(keyBuffer);\n}\n\nfunction exists(path) {\n\tif (fs.existsSync)\n\t\treturn fs.existsSync(path);\n\ttry {\n\t\treturn fs.statSync(path);\n\t} catch (error) {\n\t\treturn false\n\t}\n}\n\nfunction assignConstrainedProperties(allowedProperties, target) {\n\tfor (let i = 2; i < arguments.length; i++) {\n\t\tlet source = arguments[i];\n\t\tfor (let key in source) {\n\t\t\tif (allowedProperties.includes(key))\n\t\t\t\ttarget[key] = source[key];\n\t\t}\n\t}\n\treturn target;\n}\n","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"events\");","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"os\");","var decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nvar src\nvar srcEnd\nvar position = 0\nvar alreadySet\nconst EMPTY_ARRAY = []\nvar strings = EMPTY_ARRAY\nvar stringPosition = 0\nvar currentUnpackr = {}\nvar currentStructures\nvar srcString\nvar srcStringStart = 0\nvar srcStringEnd = 0\nvar bundledStrings\nvar referenceMap\nvar currentExtensions = []\nvar dataView\nvar defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nexport class C1Type {}\nexport const C1 = new C1Type()\nC1.name = 'MessagePack 0xC1'\nvar sequentialMode = false\nvar inlineObjectReadThreshold = 2\nvar readStruct, onLoadedStructures, onSaveState\nvar BlockedFunction // we use search and replace to change the next call to BlockedFunction to avoid CSP issues for\n// no-eval build\ntry {\n\tnew Function('')\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n\tinlineObjectReadThreshold = Infinity\n}\n\nexport class Unpackr {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.sequential && options.trusted !== false) {\n\t\t\t\toptions.trusted = true;\n\t\t\t\tif (!options.structures && options.useRecords != false) {\n\t\t\t\t\toptions.structures = []\n\t\t\t\t\tif (!options.maxSharedStructures)\n\t\t\t\t\t\toptions.maxSharedStructures = 0\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (options.structures)\n\t\t\t\toptions.structures.sharedLength = options.structures.length\n\t\t\telse if (options.getStructures) {\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\t\toptions.structures.sharedLength = 0\n\t\t\t}\n\t\t\tif (options.int64AsNumber) {\n\t\t\t\toptions.int64AsType = 'number'\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\tunpack(source, options) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this unpack\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.unpack(source, options) : Unpackr.prototype.unpack.call(defaultOptions, source, options)\n\t\t\t})\n\t\t}\n\t\tif (!source.buffer && source.constructor === ArrayBuffer)\n\t\t\tsource = typeof Buffer !== 'undefined' ? Buffer.from(source) : new Uint8Array(source);\n\t\tif (typeof options === 'object') {\n\t\t\tsrcEnd = options.end || source.length\n\t\t\tposition = options.start || 0\n\t\t} else {\n\t\t\tposition = 0\n\t\t\tsrcEnd = options > -1 ? options : source.length\n\t\t}\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Unpackr) {\n\t\t\tcurrentUnpackr = this\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead(options)\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentUnpackr = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t}\n\t\treturn checkedRead(options)\n\t}\n\tunpackMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tsequentialMode = true\n\t\t\tlet size = source.length\n\t\t\tlet value = this ? this.unpack(source, size) : defaultUnpackr.unpack(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value, lastPosition, position) === false) return;\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead(), lastPosition, position) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n\t_mergeStructures(loadedStructures, existingStructures) {\n\t\tif (onLoadedStructures)\n\t\t\tloadedStructures = onLoadedStructures.call(this, loadedStructures);\n\t\tloadedStructures = loadedStructures || []\n\t\tif (Object.isFrozen(loadedStructures))\n\t\t\tloadedStructures = loadedStructures.map(structure => structure.slice(0))\n\t\tfor (let i = 0, l = loadedStructures.length; i < l; i++) {\n\t\t\tlet structure = loadedStructures[i]\n\t\t\tif (structure) {\n\t\t\t\tstructure.isShared = true\n\t\t\t\tif (i >= 32)\n\t\t\t\t\tstructure.highByte = (i - 32) >> 5\n\t\t\t}\n\t\t}\n\t\tloadedStructures.sharedLength = loadedStructures.length\n\t\tfor (let id in existingStructures || []) {\n\t\t\tif (id >= 0) {\n\t\t\t\tlet structure = loadedStructures[id]\n\t\t\t\tlet existing = existingStructures[id]\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (structure)\n\t\t\t\t\t\t(loadedStructures.restoreStructures || (loadedStructures.restoreStructures = []))[id] = structure\n\t\t\t\t\tloadedStructures[id] = existing\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.structures = loadedStructures\n\t}\n\tdecode(source, end) {\n\t\treturn this.unpack(source, end)\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead(options) {\n\ttry {\n\t\tif (!currentUnpackr.trusted && !sequentialMode) {\n\t\t\tlet sharedLength = currentStructures.sharedLength || 0\n\t\t\tif (sharedLength < currentStructures.length)\n\t\t\t\tcurrentStructures.length = sharedLength\n\t\t}\n\t\tlet result\n\t\tif (currentUnpackr.randomAccessStructure && src[position] < 0x40 && src[position] >= 0x20 && readStruct) {\n\t\t\tresult = readStruct(src, position, srcEnd, currentUnpackr)\n\t\t\tsrc = null // dispose of this so that recursive unpack calls don't save state\n\t\t\tif (!(options && options.lazy) && result)\n\t\t\t\tresult = result.toJSON()\n\t\t\tposition = srcEnd\n\t\t} else\n\t\t\tresult = read()\n\t\tif (bundledStrings) { // bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition\n\t\t\tbundledStrings = null\n\t\t}\n\t\tif (sequentialMode)\n\t\t\t// we only need to restore the structures if there was an error, but if we completed a read,\n\t\t\t// we can clear this out and keep the structures we read\n\t\t\tcurrentStructures.restoreStructures = null\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\t\trestoreStructures()\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tthrow new Error('Unexpected end of MessagePack data')\n\t\t} else if (!sequentialMode) {\n\t\t\tlet jsonView;\n\t\t\ttry {\n\t\t\t\tjsonView = JSON.stringify(result, (_, value) => typeof value === \"bigint\" ? `${value}n` : value).slice(0, 100)\n\t\t\t} catch(error) {\n\t\t\t\tjsonView = '(JSON view not available ' + error + ')'\n\t\t\t}\n\t\t\tthrow new Error('Data read, but end of buffer not reached ' + jsonView)\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tif (currentStructures && currentStructures.restoreStructures)\n\t\t\trestoreStructures()\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer') || position > srcEnd) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nfunction restoreStructures() {\n\tfor (let id in currentStructures.restoreStructures) {\n\t\tcurrentStructures[id] = currentStructures.restoreStructures[id]\n\t}\n\tcurrentStructures.restoreStructures = null\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tif (token < 0xa0) {\n\t\tif (token < 0x80) {\n\t\t\tif (token < 0x40)\n\t\t\t\treturn token\n\t\t\telse {\n\t\t\t\tlet structure = currentStructures[token & 0x3f] ||\n\t\t\t\t\tcurrentUnpackr.getStructures && loadStructures()[token & 0x3f]\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) {\n\t\t\t\t\t\tstructure.read = createStructureReader(structure, token & 0x3f)\n\t\t\t\t\t}\n\t\t\t\t\treturn structure.read()\n\t\t\t\t} else\n\t\t\t\t\treturn token\n\t\t\t}\n\t\t} else if (token < 0x90) {\n\t\t\t// map\n\t\t\ttoken -= 0x80\n\t\t\tif (currentUnpackr.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tlet key = readKey()\n\t\t\t\t\tif (key === '__proto__')\n\t\t\t\t\t\tkey = '__proto_'\n\t\t\t\t\tobject[key] = read()\n\t\t\t\t}\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tlet map = new Map()\n\t\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\t\tmap.set(read(), read())\n\t\t\t\t}\n\t\t\t\treturn map\n\t\t\t}\n\t\t} else {\n\t\t\ttoken -= 0x90\n\t\t\tlet array = new Array(token)\n\t\t\tfor (let i = 0; i < token; i++) {\n\t\t\t\tarray[i] = read()\n\t\t\t}\n\t\t\tif (currentUnpackr.freezeData)\n\t\t\t\treturn Object.freeze(array)\n\t\t\treturn array\n\t\t}\n\t} else if (token < 0xc0) {\n\t\t// fixstr\n\t\tlet length = token - 0xa0\n\t\tif (srcStringEnd >= position) {\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\t}\n\t\tif (srcStringEnd == 0 && srcEnd < 140) {\n\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\t\t\tif (string != null)\n\t\t\t\treturn string\n\t\t}\n\t\treturn readFixedString(length)\n\t} else {\n\t\tlet value\n\t\tswitch (token) {\n\t\t\tcase 0xc0: return null\n\t\t\tcase 0xc1:\n\t\t\t\tif (bundledStrings) {\n\t\t\t\t\tvalue = read() // followed by the length of the string in characters (not bytes!)\n\t\t\t\t\tif (value > 0)\n\t\t\t\t\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\t\t\t\t\telse\n\t\t\t\t\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 -= value)\n\t\t\t\t}\n\t\t\t\treturn C1; // \"never-used\", return special object to denote that\n\t\t\tcase 0xc2: return false\n\t\t\tcase 0xc3: return true\n\t\t\tcase 0xc4:\n\t\t\t\t// bin 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value === undefined)\n\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc5:\n\t\t\t\t// bin 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc6:\n\t\t\t\t// bin 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readBin(value)\n\t\t\tcase 0xc7:\n\t\t\t\t// ext 8\n\t\t\t\treturn readExt(src[position++])\n\t\t\tcase 0xc8:\n\t\t\t\t// ext 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xc9:\n\t\t\t\t// ext 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readExt(value)\n\t\t\tcase 0xca:\n\t\t\t\tvalue = dataView.getFloat32(position)\n\t\t\t\tif (currentUnpackr.useFloat32 > 2) {\n\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t}\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcb:\n\t\t\t\tvalue = dataView.getFloat64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\t\t\t// uint handlers\n\t\t\tcase 0xcc:\n\t\t\t\treturn src[position++]\n\t\t\tcase 0xcd:\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xce:\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xcf:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\t\tif (value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\t// int handlers\n\t\t\tcase 0xd0:\n\t\t\t\treturn dataView.getInt8(position++)\n\t\t\tcase 0xd1:\n\t\t\t\tvalue = dataView.getInt16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn value\n\t\t\tcase 0xd2:\n\t\t\t\tvalue = dataView.getInt32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn value\n\t\t\tcase 0xd3:\n\t\t\t\tif (currentUnpackr.int64AsType === 'number') {\n\t\t\t\t\tvalue = dataView.getInt32(position) * 0x100000000\n\t\t\t\t\tvalue += dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'string') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position).toString()\n\t\t\t\t} else if (currentUnpackr.int64AsType === 'auto') {\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\t\tif (value>=BigInt(-2)<<BigInt(52)&&value<=BigInt(2)<<BigInt(52)) value=Number(value)\n\t\t\t\t} else\n\t\t\t\t\tvalue = dataView.getBigInt64(position)\n\t\t\t\tposition += 8\n\t\t\t\treturn value\n\n\t\t\tcase 0xd4:\n\t\t\t\t// fixext 1\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f)\n\t\t\t\t} else {\n\t\t\t\t\tlet extension = currentExtensions[value]\n\t\t\t\t\tif (extension) {\n\t\t\t\t\t\tif (extension.read) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension.read(read())\n\t\t\t\t\t\t} else if (extension.noBuffer) {\n\t\t\t\t\t\t\tposition++ // skip filler byte\n\t\t\t\t\t\t\treturn extension()\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\treturn extension(src.subarray(position, ++position))\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new Error('Unknown extension ' + value)\n\t\t\t\t}\n\t\t\tcase 0xd5:\n\t\t\t\t// fixext 2\n\t\t\t\tvalue = src[position]\n\t\t\t\tif (value == 0x72) {\n\t\t\t\t\tposition++\n\t\t\t\t\treturn recordDefinition(src[position++] & 0x3f, src[position++])\n\t\t\t\t} else\n\t\t\t\t\treturn readExt(2)\n\t\t\tcase 0xd6:\n\t\t\t\t// fixext 4\n\t\t\t\treturn readExt(4)\n\t\t\tcase 0xd7:\n\t\t\t\t// fixext 8\n\t\t\t\treturn readExt(8)\n\t\t\tcase 0xd8:\n\t\t\t\t// fixext 16\n\t\t\t\treturn readExt(16)\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tvalue = src[position++]\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString8(value)\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString16(value)\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tif (srcStringEnd >= position) {\n\t\t\t\t\treturn srcString.slice(position - srcStringStart, (position += value) - srcStringStart)\n\t\t\t\t}\n\t\t\t\treturn readString32(value)\n\t\t\tcase 0xdc:\n\t\t\t// array 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xdd:\n\t\t\t// array 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readArray(value)\n\t\t\tcase 0xde:\n\t\t\t// map 16\n\t\t\t\tvalue = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\treturn readMap(value)\n\t\t\tcase 0xdf:\n\t\t\t// map 32\n\t\t\t\tvalue = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\treturn readMap(value)\n\t\t\tdefault: // negative int\n\t\t\t\tif (token >= 0xe0)\n\t\t\t\t\treturn token - 0x100\n\t\t\t\tif (token === undefined) {\n\t\t\t\t\tlet error = new Error('Unexpected end of MessagePack data')\n\t\t\t\t\terror.incomplete = true\n\t\t\t\t\tthrow error\n\t\t\t\t}\n\t\t\t\tthrow new Error('Unknown MessagePack token ' + token)\n\n\t\t}\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure, firstId) {\n\tfunction readObject() {\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tif (readObject.count++ > inlineObjectReadThreshold) {\n\t\t\tlet readObject = structure.read = (new Function('r', 'return function(){return ' + (currentUnpackr.freezeData ? 'Object.freeze' : '') +\n\t\t\t\t'({' + structure.map(key => key === '__proto__' ? '__proto_:r()' : validName.test(key) ? key + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '})}'))(read)\n\t\t\tif (structure.highByte === 0)\n\t\t\t\tstructure.read = createSecondByteReader(firstId, structure.read)\n\t\t\treturn readObject() // second byte is already read, if there is one so immediately read object\n\t\t}\n\t\tlet object = {}\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet key = structure[i]\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_'\n\t\t\tobject[key] = read()\n\t\t}\n\t\tif (currentUnpackr.freezeData)\n\t\t\treturn Object.freeze(object);\n\t\treturn object\n\t}\n\treadObject.count = 0\n\tif (structure.highByte === 0) {\n\t\treturn createSecondByteReader(firstId, readObject)\n\t}\n\treturn readObject\n}\n\nconst createSecondByteReader = (firstId, read0) => {\n\treturn function() {\n\t\tlet highByte = src[position++]\n\t\tif (highByte === 0)\n\t\t\treturn read0()\n\t\tlet id = firstId < 32 ? -(firstId + (highByte << 5)) : firstId + (highByte << 5)\n\t\tlet structure = currentStructures[id] || loadStructures()[id]\n\t\tif (!structure) {\n\t\t\tthrow new Error('Record id is not defined for ' + id)\n\t\t}\n\t\tif (!structure.read)\n\t\t\tstructure.read = createStructureReader(structure, firstId)\n\t\treturn structure.read()\n\t}\n}\n\nexport function loadStructures() {\n\tlet loadedStructures = saveState(() => {\n\t\t// save the state in case getStructures modifies our buffer\n\t\tsrc = null\n\t\treturn currentUnpackr.getStructures()\n\t})\n\treturn currentStructures = currentUnpackr._mergeStructures(loadedStructures, currentStructures)\n}\n\nvar readFixedString = readStringJS\nvar readString8 = readStringJS\nvar readString16 = readStringJS\nvar readString32 = readStringJS\nexport let isNativeAccelerationEnabled = false\n\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet byteOffset = src.byteOffset\n\t\t\t\tlet extraction = extractStrings(position - headerLength + byteOffset, srcEnd + byteOffset, src.buffer)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nexport function readString(source, start, length) {\n\tlet existingSrc = src;\n\tsrc = source;\n\tposition = start;\n\ttry {\n\t\treturn readStringJS(length);\n\t} finally {\n\t\tsrc = existingSrc;\n\t}\n}\n\nfunction readArray(length) {\n\tlet array = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tarray[i] = read()\n\t}\n\tif (currentUnpackr.freezeData)\n\t\treturn Object.freeze(array)\n\treturn array\n}\n\nfunction readMap(length) {\n\tif (currentUnpackr.mapsAsObjects) {\n\t\tlet object = {}\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tlet key = readKey()\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tobject[key] = read()\n\t\t}\n\t\treturn object\n\t} else {\n\t\tlet map = new Map()\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tmap.set(read(), read())\n\t\t}\n\t\treturn map\n\t}\n}\n\nvar fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\t\tposition = start\n\t\t\t\treturn\n\t\t\t}\n\t\t\tbytes[i] = byte\n\t\t}\n\t\treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readOnlyJSString() {\n\tlet token = src[position++]\n\tlet length\n\tif (token < 0xc0) {\n\t\t// fixstr\n\t\tlength = token - 0xa0\n\t} else {\n\t\tswitch(token) {\n\t\t\tcase 0xd9:\n\t\t\t// str 8\n\t\t\t\tlength = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0xda:\n\t\t\t// str 16\n\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0xdb:\n\t\t\t// str 32\n\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Expected string')\n\t\t}\n\t}\n\treturn readStringJS(length)\n}\n\n\nfunction readBin(length) {\n\treturn currentUnpackr.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\tlet end\n\t\treturn currentExtensions[type](src.subarray(position, end = (position += length)), (readPosition) => {\n\t\t\tposition = readPosition;\n\t\t\ttry {\n\t\t\t\treturn read();\n\t\t\t} finally {\n\t\t\t\tposition = end;\n\t\t\t}\n\t\t})\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\n\nvar keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0xa0 && length < 0xc0) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0xa0\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn read().toString()\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\n// the registration of the record definition extension (as \"r\")\nconst recordDefinition = (id, highByte) => {\n\tlet structure = read().map(property => property.toString()) // ensure that all keys are strings and that the array is mutable\n\tlet firstByte = id\n\tif (highByte !== undefined) {\n\t\tid = id < 32 ? -((highByte << 5) + id) : ((highByte << 5) + id)\n\t\tstructure.highByte = highByte\n\t}\n\tlet existingStructure = currentStructures[id]\n\t// If it is a shared structure, we need to restore any changes after reading.\n\t// Also in sequential mode, we may get incomplete reads and thus errors, and we need to restore\n\t// to the state prior to an incomplete read in order to properly resume.\n\tif (existingStructure && (existingStructure.isShared || sequentialMode)) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\tstructure.read = createStructureReader(structure, firstByte)\n\treturn structure.read()\n}\ncurrentExtensions[0] = () => {} // notepack defines extension 0 to mean undefined, so use that as the default here\ncurrentExtensions[0].noBuffer = true\n\nlet errors = { Error, TypeError, ReferenceError };\ncurrentExtensions[0x65] = () => {\n\tlet data = read()\n\treturn (errors[data[0]] || Error)(data[1])\n}\n\ncurrentExtensions[0x69] = (data) => {\n\t// id extension (for structured clones)\n\tlet id = dataView.getUint32(position - 4)\n\tif (!referenceMap)\n\t\treferenceMap = new Map()\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif (token >= 0x90 && token < 0xa0 || token == 0xdc || token == 0xdd)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\n\t\treturn Object.assign(target, targetProperties)\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\n\ncurrentExtensions[0x70] = (data) => {\n\t// pointer extension (for structured clones)\n\tlet id = dataView.getUint32(position - 4)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[0x73] = () => new Set(read())\n\nexport const typedArrays = ['Int8','Uint8','Uint8Clamped','Int16','Uint16','Int32','Uint32','Float32','Float64','BigInt64','BigUint64'].map(type => type + 'Array')\n\nlet glbl = typeof globalThis === 'object' ? globalThis : window;\ncurrentExtensions[0x74] = (data) => {\n\tlet typeCode = data[0]\n\tlet typedArrayName = typedArrays[typeCode]\n\tif (!typedArrayName)\n\t\tthrow new Error('Could not find typed array for code ' + typeCode)\n\t// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n\treturn new glbl[typedArrayName](Uint8Array.prototype.slice.call(data, 1).buffer)\n}\ncurrentExtensions[0x78] = () => {\n\tlet data = read()\n\treturn new RegExp(data[0], data[1])\n}\nconst TEMP_BUNDLE = []\ncurrentExtensions[0x62] = (data) => {\n\tlet dataSize = (data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]\n\tlet dataPosition = position\n\tposition += dataSize - data.length\n\tbundledStrings = TEMP_BUNDLE\n\tbundledStrings = [readOnlyJSString(), readOnlyJSString()]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\ncurrentExtensions[0xff] = (data) => {\n\t// 32-bit date extension\n\tif (data.length == 4)\n\t\treturn new Date((data[0] * 0x1000000 + (data[1] << 16) + (data[2] << 8) + data[3]) * 1000)\n\telse if (data.length == 8)\n\t\treturn new Date(\n\t\t\t((data[0] << 22) + (data[1] << 14) + (data[2] << 6) + (data[3] >> 2)) / 1000000 +\n\t\t\t((data[3] & 0x3) * 0x100000000 + data[4] * 0x1000000 + (data[5] << 16) + (data[6] << 8) + data[7]) * 1000)\n\telse if (data.length == 12)// TODO: Implement support for negative\n\t\treturn new Date(\n\t\t\t((data[0] << 24) + (data[1] << 16) + (data[2] << 8) + data[3]) / 1000000 +\n\t\t\t(((data[4] & 0x80) ? -0x1000000000000 : 0) + data[6] * 0x10000000000 + data[7] * 0x100000000 + data[8] * 0x1000000 + (data[9] << 16) + (data[10] << 8) + data[11]) * 1000)\n\telse\n\t\treturn new Date('invalid')\n} // notepack defines extension 0 to mean undefined, so use that as the default here\n// registration of bulk record definition?\n// currentExtensions[0x52] = () =>\n\nfunction saveState(callback) {\n\tif (onSaveState)\n\t\tonSaveState();\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedStructuresContents = currentStructures.slice(0, currentStructures.length)\n\tlet savedPackr = currentUnpackr\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentStructures.splice(0, currentStructures.length, ...savedStructuresContents)\n\tcurrentUnpackr = savedPackr\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tif (extension.unpack)\n\t\tcurrentExtensions[extension.type] = extension.unpack\n\telse\n\t\tcurrentExtensions[extension.type] = extension\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nexport const Decoder = Unpackr\nvar defaultUnpackr = new Unpackr({ useRecords: false })\nexport const unpack = defaultUnpackr.unpack\nexport const unpackMultiple = defaultUnpackr.unpackMultiple\nexport const decode = defaultUnpackr.unpack\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\nexport function setReadStruct(updatedReadStruct, loadedStructs, saveState) {\n\treadStruct = updatedReadStruct;\n\tonLoadedStructures = loadedStructs;\n\tonSaveState = saveState;\n}\n","import { Unpackr, mult10, C1Type, typedArrays, addExtension as unpackAddExtension } from './unpack.js'\nlet textEncoder\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nlet extensions, extensionClasses\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nconst ByteArrayAllocate = hasNodeBuffer ?\n\tfunction(length) { return Buffer.allocUnsafeSlow(length) } : Uint8Array\nconst ByteArray = hasNodeBuffer ? Buffer : Uint8Array\nconst MAX_BUFFER_SIZE = hasNodeBuffer ? 0x100000000 : 0x7fd00000\nlet target, keysTarget\nlet targetView\nlet position = 0\nlet safeEnd\nlet bundledStrings = null\nlet writeStructSlots\nconst MAX_BUNDLE_SIZE = 0x5500 // maximum characters such that the encoded bytes fits in 16 bits.\nconst hasNonLatin = /[\\u0080-\\uFFFF]/\nexport const RECORD_SYMBOL = Symbol('record-id')\nexport class Packr extends Unpackr {\n\tconstructor(options) {\n\t\tsuper(options)\n\t\tthis.offset = 0\n\t\tlet typeBuffer\n\t\tlet start\n\t\tlet hasSharedUpdate\n\t\tlet structures\n\t\tlet referenceMap\n\t\tlet encodeUtf8 = ByteArray.prototype.utf8Write ? function(string, position) {\n\t\t\treturn target.utf8Write(string, position, 0xffffffff)\n\t\t} : (textEncoder && textEncoder.encodeInto) ?\n\t\t\tfunction(string, position) {\n\t\t\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t\t\t} : false\n\n\t\tlet packr = this\n\t\tif (!options)\n\t\t\toptions = {}\n\t\tlet isSequential = options && options.sequential\n\t\tlet hasSharedStructures = options.structures || options.saveStructures\n\t\tlet maxSharedStructures = options.maxSharedStructures\n\t\tif (maxSharedStructures == null)\n\t\t\tmaxSharedStructures = hasSharedStructures ? 32 : 0\n\t\tif (maxSharedStructures > 8160)\n\t\t\tthrow new Error('Maximum maxSharedStructure is 8160')\n\t\tif (options.structuredClone && options.moreTypes == undefined) {\n\t\t\tthis.moreTypes = true\n\t\t}\n\t\tlet maxOwnStructures = options.maxOwnStructures\n\t\tif (maxOwnStructures == null)\n\t\t\tmaxOwnStructures = hasSharedStructures ? 32 : 64\n\t\tif (!this.structures && options.useRecords != false)\n\t\t\tthis.structures = []\n\t\t// two byte record ids for shared structures\n\t\tlet useTwoByteRecords = maxSharedStructures > 32 || (maxOwnStructures + maxSharedStructures > 64)\t\t\n\t\tlet sharedLimitId = maxSharedStructures + 0x40\n\t\tlet maxStructureId = maxSharedStructures + maxOwnStructures + 0x40\n\t\tif (maxStructureId > 8256) {\n\t\t\tthrow new Error('Maximum maxSharedStructure + maxOwnStructure is 8192')\n\t\t}\n\t\tlet recordIdsToRemove = []\n\t\tlet transitionsCount = 0\n\t\tlet serializationsSinceTransitionRebuild = 0\n\n\t\tthis.pack = this.encode = function(value, encodeOptions) {\n\t\t\tif (!target) {\n\t\t\t\ttarget = new ByteArrayAllocate(8192)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, 8192))\n\t\t\t\tposition = 0\n\t\t\t}\n\t\t\tsafeEnd = target.length - 10\n\t\t\tif (safeEnd - position < 0x800) {\n\t\t\t\t// don't start too close to the end, \n\t\t\t\ttarget = new ByteArrayAllocate(target.length)\n\t\t\t\ttargetView = target.dataView || (target.dataView = new DataView(target.buffer, 0, target.length))\n\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\tposition = 0\n\t\t\t} else\n\t\t\t\tposition = (position + 7) & 0x7ffffff8 // Word align to make any future copying of this buffer faster\n\t\t\tstart = position\n\t\t\treferenceMap = packr.structuredClone ? new Map() : null\n\t\t\tif (packr.bundleStrings && typeof value !== 'string') {\n\t\t\t\tbundledStrings = []\n\t\t\t\tbundledStrings.size = Infinity // force a new bundle start on first string\n\t\t\t} else\n\t\t\t\tbundledStrings = null\n\t\t\tstructures = packr.structures\n\t\t\tif (structures) {\n\t\t\t\tif (structures.uninitialized)\n\t\t\t\t\tstructures = packr._mergeStructures(packr.getStructures())\n\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\tif (sharedLength > maxSharedStructures) {\n\t\t\t\t\t//if (maxSharedStructures <= 32 && structures.sharedLength > 32) // TODO: could support this, but would need to update the limit ids\n\t\t\t\t\tthrow new Error('Shared structures is larger than maximum shared structures, try increasing maxSharedStructures to ' + structures.sharedLength)\n\t\t\t\t}\n\t\t\t\tif (!structures.transitions) {\n\t\t\t\t\t// rebuild our structure transitions\n\t\t\t\t\tstructures.transitions = Object.create(null)\n\t\t\t\t\tfor (let i = 0; i < sharedLength; i++) {\n\t\t\t\t\t\tlet keys = structures[i]\n\t\t\t\t\t\tif (!keys)\n\t\t\t\t\t\t\tcontinue\n\t\t\t\t\t\tlet nextTransition, transition = structures.transitions\n\t\t\t\t\t\tfor (let j = 0, l = keys.length; j < l; j++) {\n\t\t\t\t\t\t\tlet key = keys[j]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\ttransition[RECORD_SYMBOL] = i + 0x40\n\t\t\t\t\t}\n\t\t\t\t\tthis.lastNamedStructuresLength = sharedLength\n\t\t\t\t}\n\t\t\t\tif (!isSequential) {\n\t\t\t\t\tstructures.nextId = sharedLength + 0x40\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hasSharedUpdate)\n\t\t\t\thasSharedUpdate = false\n\t\t\ttry {\n\t\t\t\tif (packr.randomAccessStructure && value && value.constructor && value.constructor === Object)\n\t\t\t\t\twriteStruct(value);\n\t\t\t\telse\n\t\t\t\t\tpack(value)\n\t\t\t\tlet lastBundle = bundledStrings;\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\twriteBundles(start, pack, 0)\n\t\t\t\tif (referenceMap && referenceMap.idsToInsert) {\n\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert.sort((a, b) => a.offset > b.offset ? 1 : -1);\n\t\t\t\t\tlet i = idsToInsert.length;\n\t\t\t\t\tlet incrementPosition = -1;\n\t\t\t\t\twhile (lastBundle && i > 0) {\n\t\t\t\t\t\tlet insertionPoint = idsToInsert[--i].offset + start;\n\t\t\t\t\t\tif (insertionPoint < (lastBundle.stringsPosition + start) && incrementPosition === -1)\n\t\t\t\t\t\t\tincrementPosition = 0;\n\t\t\t\t\t\tif (insertionPoint > (lastBundle.position + start)) {\n\t\t\t\t\t\t\tif (incrementPosition >= 0)\n\t\t\t\t\t\t\t\tincrementPosition += 6;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (incrementPosition >= 0) {\n\t\t\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t\t\t\tincrementPosition = -1; // reset\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlastBundle = lastBundle.previous;\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (incrementPosition >= 0 && lastBundle) {\n\t\t\t\t\t\t// update the bundle reference now\n\t\t\t\t\t\ttargetView.setUint32(lastBundle.position + start,\n\t\t\t\t\t\t\ttargetView.getUint32(lastBundle.position + start) + incrementPosition)\n\t\t\t\t\t}\n\t\t\t\t\tposition += idsToInsert.length * 6;\n\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\tpackr.offset = position\n\t\t\t\t\tlet serialized = insertIds(target.subarray(start, position), idsToInsert)\n\t\t\t\t\treferenceMap = null\n\t\t\t\t\treturn serialized\n\t\t\t\t}\n\t\t\t\tpackr.offset = position // update the offset so next serialization doesn't write over our buffer, but can continue writing to same buffer sequentially\n\t\t\t\tif (encodeOptions & REUSE_BUFFER_MODE) {\n\t\t\t\t\ttarget.start = start\n\t\t\t\t\ttarget.end = position\n\t\t\t\t\treturn target\n\t\t\t\t}\n\t\t\t\treturn target.subarray(start, position) // position can change if we call pack again in saveStructures, so we get the buffer now\n\t\t\t} finally {\n\t\t\t\tif (structures) {\n\t\t\t\t\tif (serializationsSinceTransitionRebuild < 10)\n\t\t\t\t\t\tserializationsSinceTransitionRebuild++\n\t\t\t\t\tlet sharedLength = structures.sharedLength || 0\n\t\t\t\t\tif (structures.length > sharedLength && !isSequential)\n\t\t\t\t\t\tstructures.length = sharedLength\n\t\t\t\t\tif (transitionsCount > 10000) {\n\t\t\t\t\t\t// force a rebuild occasionally after a lot of transitions so it can get cleaned up\n\t\t\t\t\t\tstructures.transitions = null\n\t\t\t\t\t\tserializationsSinceTransitionRebuild = 0\n\t\t\t\t\t\ttransitionsCount = 0\n\t\t\t\t\t\tif (recordIdsToRemove.length > 0)\n\t\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t} else if (recordIdsToRemove.length > 0 && !isSequential) {\n\t\t\t\t\t\tfor (let i = 0, l = recordIdsToRemove.length; i < l; i++) {\n\t\t\t\t\t\t\trecordIdsToRemove[i][RECORD_SYMBOL] = 0\n\t\t\t\t\t\t}\n\t\t\t\t\t\trecordIdsToRemove = []\n\t\t\t\t\t}\n\t\t\t\t\tif (hasSharedUpdate && packr.saveStructures) {\n\t\t\t\t\t\t// we can't rely on start/end with REUSE_BUFFER_MODE since they will (probably) change when we save\n\t\t\t\t\t\tlet returnBuffer = target.subarray(start, position)\n\t\t\t\t\t\tlet newSharedData = prepareStructures(structures, packr);\n\t\t\t\t\t\tif (packr.saveStructures(newSharedData, newSharedData.isCompatible) === false) {\n\t\t\t\t\t\t\t// get updated structures and try again if the update failed\n\t\t\t\t\t\t\treturn packr.pack(value)\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpackr.lastNamedStructuresLength = sharedLength\n\t\t\t\t\t\treturn returnBuffer\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (encodeOptions & RESET_BUFFER_MODE)\n\t\t\t\t\tposition = start\n\t\t\t}\n\t\t}\n\t\tconst packArray = (value) => {\n\t\t\tvar length = value.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x90 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xdc\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdd\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\tpack(value[i])\n\t\t\t}\n\t\t}\n\t\tconst pack = (value) => {\n\t\t\tif (position > safeEnd)\n\t\t\t\ttarget = makeRoom(position)\n\n\t\t\tvar type = typeof value\n\t\t\tvar length\n\t\t\tif (type === 'string') {\n\t\t\t\tlet strLength = value.length\n\t\t\t\tif (bundledStrings && strLength >= 4 && strLength < 0x1000) {\n\t\t\t\t\tif ((bundledStrings.size += strLength) > MAX_BUNDLE_SIZE) {\n\t\t\t\t\t\tlet extStart\n\t\t\t\t\t\tlet maxBytes = (bundledStrings[0] ? bundledStrings[0].length * 3 + bundledStrings[1].length : 0) + 10\n\t\t\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\t\t\t\t\t\tlet lastBundle\n\t\t\t\t\t\tif (bundledStrings.position) { // here we use the 0x62 extension to write the last bundle and reserve space for the reference pointer to the next/current bundle\n\t\t\t\t\t\t\tlastBundle = bundledStrings\n\t\t\t\t\t\t\ttarget[position] = 0xc8 // ext 16\n\t\t\t\t\t\t\tposition += 3 // reserve for the writing bundle size\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t\twriteBundles(start, pack, 0) // write the last bundles\n\t\t\t\t\t\t\ttargetView.setUint16(extStart + start - 3, position - start - extStart)\n\t\t\t\t\t\t} else { // here we use the 0x62 extension just to reserve the space for the reference pointer to the bundle (will be updated once the bundle is written)\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x62 // 'b'\n\t\t\t\t\t\t\textStart = position - start\n\t\t\t\t\t\t\tposition += 4 // reserve for writing bundle reference\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbundledStrings = ['', ''] // create new ones\n\t\t\t\t\t\tbundledStrings.previous = lastBundle;\n\t\t\t\t\t\tbundledStrings.size = 0\n\t\t\t\t\t\tbundledStrings.position = extStart\n\t\t\t\t\t}\n\t\t\t\t\tlet twoByte = hasNonLatin.test(value)\n\t\t\t\t\tbundledStrings[twoByte ? 0 : 1] += value\n\t\t\t\t\ttarget[position++] = 0xc1\n\t\t\t\t\tpack(twoByte ? -strLength : strLength);\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tlet headerSize\n\t\t\t\t// first we estimate the header size, so we can write to the correct location\n\t\t\t\tif (strLength < 0x20) {\n\t\t\t\t\theaderSize = 1\n\t\t\t\t} else if (strLength < 0x100) {\n\t\t\t\t\theaderSize = 2\n\t\t\t\t} else if (strLength < 0x10000) {\n\t\t\t\t\theaderSize = 3\n\t\t\t\t} else {\n\t\t\t\t\theaderSize = 5\n\t\t\t\t}\n\t\t\t\tlet maxBytes = strLength * 3\n\t\t\t\tif (position + maxBytes > safeEnd)\n\t\t\t\t\ttarget = makeRoom(position + maxBytes)\n\n\t\t\t\tif (strLength < 0x40 || !encodeUtf8) {\n\t\t\t\t\tlet i, c1, c2, strPosition = position + headerSize\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[strPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tlength = strPosition - position - headerSize\n\t\t\t\t} else {\n\t\t\t\t\tlength = encodeUtf8(value, position + headerSize)\n\t\t\t\t}\n\n\t\t\t\tif (length < 0x20) {\n\t\t\t\t\ttarget[position++] = 0xa0 | length\n\t\t\t\t} else if (length < 0x100) {\n\t\t\t\t\tif (headerSize < 2) {\n\t\t\t\t\t\ttarget.copyWithin(position + 2, position + 1, position + 1 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xd9\n\t\t\t\t\ttarget[position++] = length\n\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\tif (headerSize < 3) {\n\t\t\t\t\t\ttarget.copyWithin(position + 3, position + 2, position + 2 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xda\n\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t} else {\n\t\t\t\t\tif (headerSize < 5) {\n\t\t\t\t\t\ttarget.copyWithin(position + 5, position + 3, position + 3 + length)\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xdb\n\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\tposition += 4\n\t\t\t\t}\n\t\t\t\tposition += length\n\t\t\t} else if (type === 'number') {\n\t\t\t\tif (value >>> 0 === value) {// positive integer, 32-bit or less\n\t\t\t\t\t// positive uint\n\t\t\t\t\tif (value < 0x20 || (value < 0x80 && this.useRecords === false) || (value < 0x40 && !this.randomAccessStructure)) {\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x100) {\n\t\t\t\t\t\ttarget[position++] = 0xcc\n\t\t\t\t\t\ttarget[position++] = value\n\t\t\t\t\t} else if (value < 0x10000) {\n\t\t\t\t\t\ttarget[position++] = 0xcd\n\t\t\t\t\t\ttarget[position++] = value >> 8\n\t\t\t\t\t\ttarget[position++] = value & 0xff\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xce\n\t\t\t\t\t\ttargetView.setUint32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else if (value >> 0 === value) { // negative integer\n\t\t\t\t\tif (value >= -0x20) {\n\t\t\t\t\t\ttarget[position++] = 0x100 + value\n\t\t\t\t\t} else if (value >= -0x80) {\n\t\t\t\t\t\ttarget[position++] = 0xd0\n\t\t\t\t\t\ttarget[position++] = value + 0x100\n\t\t\t\t\t} else if (value >= -0x8000) {\n\t\t\t\t\t\ttarget[position++] = 0xd1\n\t\t\t\t\t\ttargetView.setInt16(position, value)\n\t\t\t\t\t\tposition += 2\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[position++] = 0xd2\n\t\t\t\t\t\ttargetView.setInt32(position, value)\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet useFloat32\n\t\t\t\t\tif ((useFloat32 = this.useFloat32) > 0 && value < 0x100000000 && value >= -0x80000000) {\n\t\t\t\t\t\ttarget[position++] = 0xca\n\t\t\t\t\t\ttargetView.setFloat32(position, value)\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\tif (useFloat32 < 4 ||\n\t\t\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\t((xShifted = value * mult10[((target[position] & 0x7f) << 1) | (target[position + 1] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else\n\t\t\t\t\t\t\tposition-- // move back into position for writing a double\n\t\t\t\t\t}\n\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\ttargetView.setFloat64(position, value)\n\t\t\t\t\tposition += 8\n\t\t\t\t}\n\t\t\t} else if (type === 'object' || type === 'function') {\n\t\t\t\tif (!value)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\tif (referenceMap) {\n\t\t\t\t\t\tlet referee = referenceMap.get(value)\n\t\t\t\t\t\tif (referee) {\n\t\t\t\t\t\t\tif (!referee.id) {\n\t\t\t\t\t\t\t\tlet idsToInsert = referenceMap.idsToInsert || (referenceMap.idsToInsert = [])\n\t\t\t\t\t\t\t\treferee.id = idsToInsert.push(referee)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttarget[position++] = 0xd6 // fixext 4\n\t\t\t\t\t\t\ttarget[position++] = 0x70 // \"p\" for pointer\n\t\t\t\t\t\t\ttargetView.setUint32(position, referee.id)\n\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t} else \n\t\t\t\t\t\t\treferenceMap.set(value, { offset: position - start })\n\t\t\t\t\t}\n\t\t\t\t\tlet constructor = value.constructor\n\t\t\t\t\tif (constructor === Object) {\n\t\t\t\t\t\twriteObject(value, true)\n\t\t\t\t\t} else if (constructor === Array) {\n\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t} else if (constructor === Map) {\n\t\t\t\t\t\tif (this.mapAsEmptyObject) target[position++] = 0x80\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tlength = value.size\n\t\t\t\t\t\t\tif (length < 0x10) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t\t\t\t\t} else if (length < 0x10000) {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xde\n\t\t\t\t\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\t\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\t\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (let [key, entryValue] of value) {\n\t\t\t\t\t\t\t\tpack(key)\n\t\t\t\t\t\t\t\tpack(entryValue)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\t\n\t\t\t\t\t\tfor (let i = 0, l = extensions.length; i < l; i++) {\n\t\t\t\t\t\t\tlet extensionClass = extensionClasses[i]\n\t\t\t\t\t\t\tif (value instanceof extensionClass) {\n\t\t\t\t\t\t\t\tlet extension = extensions[i]\n\t\t\t\t\t\t\t\tif (extension.write) {\n\t\t\t\t\t\t\t\t\tif (extension.type) {\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0xd4 // one byte \"tag\" extension\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = extension.type\n\t\t\t\t\t\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tlet writeResult = extension.write.call(this, value)\n\t\t\t\t\t\t\t\t\tif (writeResult === value) { // avoid infinite recursion\n\t\t\t\t\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\twriteObject(value)\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tpack(writeResult)\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet currentTarget = target\n\t\t\t\t\t\t\t\tlet currentTargetView = targetView\n\t\t\t\t\t\t\t\tlet currentPosition = position\n\t\t\t\t\t\t\t\ttarget = null\n\t\t\t\t\t\t\t\tlet result\n\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\tresult = extension.pack.call(this, value, (size) => {\n\t\t\t\t\t\t\t\t\t\t// restore target and use it\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\tcurrentTarget = null\n\t\t\t\t\t\t\t\t\t\tposition += size\n\t\t\t\t\t\t\t\t\t\tif (position > safeEnd)\n\t\t\t\t\t\t\t\t\t\t\tmakeRoom(position)\n\t\t\t\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t\t\t\ttarget, targetView, position: position - size\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}, pack)\n\t\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\t\t// restore current target information (unless already restored)\n\t\t\t\t\t\t\t\t\tif (currentTarget) {\n\t\t\t\t\t\t\t\t\t\ttarget = currentTarget\n\t\t\t\t\t\t\t\t\t\ttargetView = currentTargetView\n\t\t\t\t\t\t\t\t\t\tposition = currentPosition\n\t\t\t\t\t\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (result) {\n\t\t\t\t\t\t\t\t\tif (result.length + position > safeEnd)\n\t\t\t\t\t\t\t\t\t\tmakeRoom(result.length + position)\n\t\t\t\t\t\t\t\t\tposition = writeExtensionData(result, target, position, extension.type)\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// check isArray after extensions, because extensions can extend Array\n\t\t\t\t\t\tif (Array.isArray(value)) {\n\t\t\t\t\t\t\tpackArray(value)\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// use this as an alternate mechanism for expressing how to serialize\n\t\t\t\t\t\t\tif (value.toJSON) {\n\t\t\t\t\t\t\t\tconst json = value.toJSON()\n\t\t\t\t\t\t\t\t// if for some reason value.toJSON returns itself it'll loop forever\n\t\t\t\t\t\t\t\tif (json !== value)\n\t\t\t\t\t\t\t\t\treturn pack(json)\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// if there is a writeFunction, use it, otherwise just encode as undefined\n\t\t\t\t\t\t\tif (type === 'function')\n\t\t\t\t\t\t\t\treturn pack(this.writeFunction && this.writeFunction(value));\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t// no extension found, write as object\n\t\t\t\t\t\t\twriteObject(value, !value.hasOwnProperty) // if it doesn't have hasOwnProperty, don't do hasOwnProperty checks\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (type === 'boolean') {\n\t\t\t\ttarget[position++] = value ? 0xc3 : 0xc2\n\t\t\t} else if (type === 'bigint') {\n\t\t\t\tif (value < (BigInt(1)<<BigInt(63)) && value >= -(BigInt(1)<<BigInt(63))) {\n\t\t\t\t\t// use a signed int as long as it fits\n\t\t\t\t\ttarget[position++] = 0xd3\n\t\t\t\t\ttargetView.setBigInt64(position, value)\n\t\t\t\t} else if (value < (BigInt(1)<<BigInt(64)) && value > 0) {\n\t\t\t\t\t// if we can fit an unsigned int, use that\n\t\t\t\t\ttarget[position++] = 0xcf\n\t\t\t\t\ttargetView.setBigUint64(position, value)\n\t\t\t\t} else {\n\t\t\t\t\t// overflow\n\t\t\t\t\tif (this.largeBigIntToFloat) {\n\t\t\t\t\t\ttarget[position++] = 0xcb\n\t\t\t\t\t\ttargetView.setFloat64(position, Number(value))\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new RangeError(value + ' was too large to fit in MessagePack 64-bit integer format, set largeBigIntToFloat to convert to float-64')\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tposition += 8\n\t\t\t} else if (type === 'undefined') {\n\t\t\t\tif (this.encodeUndefinedAsNil)\n\t\t\t\t\ttarget[position++] = 0xc0\n\t\t\t\telse {\n\t\t\t\t\ttarget[position++] = 0xd4 // a number of implementations use fixext1 with type 0, data 0 to denote undefined, so we follow suite\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t\ttarget[position++] = 0\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Unknown type: ' + type)\n\t\t\t}\n\t\t}\n\n\t\tconst writePlainObject = (this.variableMapSize || this.coercibleKeyAsNumber) ? (object) => {\n\t\t\t// this method is slightly slower, but generates \"preferred serialization\" (optimally small for smaller objects)\n\t\t\tlet keys = Object.keys(object)\n\t\t\tlet length = keys.length\n\t\t\tif (length < 0x10) {\n\t\t\t\ttarget[position++] = 0x80 | length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xde\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xdf\n\t\t\t\ttargetView.setUint32(position, length)\n\t\t\t\tposition += 4\n\t\t\t}\n\t\t\tlet key\n\t\t\tif (this.coercibleKeyAsNumber) {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tkey = keys[i]\n\t\t\t\t\tlet num = Number(key)\n\t\t\t\t\tpack(isNaN(num) ? key : num)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < length; i++) {\n\t\t\t\t\tpack(key = keys[i])\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\ttarget[position++] = 0xde // always using map 16, so we can preallocate and set the length afterwards\n\t\t\tlet objectOffset = position - start\n\t\t\tposition += 2\n\t\t\tlet size = 0\n\t\t\tfor (let key in object) {\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tpack(key)\n\t\t\t\t\tpack(object[key])\n\t\t\t\t\tsize++\n\t\t\t\t}\n\t\t\t}\n\t\t\ttarget[objectOffset++ + start] = size >> 8\n\t\t\ttarget[objectOffset + start] = size & 0xff\n\t\t}\n\n\t\tconst writeRecord = this.useRecords === false ? writePlainObject :\n\t\t(options.progressiveRecords && !useTwoByteRecords) ?  // this is about 2% faster for highly stable structures, since it only requires one for-in loop (but much more expensive when new structure needs to be written)\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet objectOffset = position++ - start\n\t\t\tlet wroteKeys\n\t\t\tfor (let key in object) {\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\tif (nextTransition)\n\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\telse {\n\t\t\t\t\t\t// record doesn't exist, create full new record and insert it\n\t\t\t\t\t\tlet keys = Object.keys(object)\n\t\t\t\t\t\tlet lastTransition = transition\n\t\t\t\t\t\ttransition = structures.transitions\n\t\t\t\t\t\tlet newTransitions = 0\n\t\t\t\t\t\tfor (let i = 0, l = keys.length; i < l; i++) {\n\t\t\t\t\t\t\tlet key = keys[i]\n\t\t\t\t\t\t\tnextTransition = transition[key]\n\t\t\t\t\t\t\tif (!nextTransition) {\n\t\t\t\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\t\t\t\tnewTransitions++\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttransition = nextTransition\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (objectOffset + start + 1 == position) {\n\t\t\t\t\t\t\t// first key, so we don't need to insert, we can just write record directly\n\t\t\t\t\t\t\tposition--\n\t\t\t\t\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\t\t\t\t} else // otherwise we need to insert the record, moving existing data after the record\n\t\t\t\t\t\t\tinsertNewRecord(transition, keys, objectOffset, newTransitions)\n\t\t\t\t\t\twroteKeys = true\n\t\t\t\t\t\ttransition = lastTransition[key]\n\t\t\t\t\t}\n\t\t\t\t\tpack(object[key])\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!wroteKeys) {\n\t\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\t\tif (recordId)\n\t\t\t\t\ttarget[objectOffset + start] = recordId\n\t\t\t\telse\n\t\t\t\t\tinsertNewRecord(transition, Object.keys(object), objectOffset, 0)\n\t\t\t}\n\t\t} :\n\t\t(object, safePrototype) => {\n\t\t\tlet nextTransition, transition = structures.transitions || (structures.transitions = Object.create(null))\n\t\t\tlet newTransitions = 0\n\t\t\tfor (let key in object) if (safePrototype || object.hasOwnProperty(key)) {\n\t\t\t\tnextTransition = transition[key]\n\t\t\t\tif (!nextTransition) {\n\t\t\t\t\tnextTransition = transition[key] = Object.create(null)\n\t\t\t\t\tnewTransitions++\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition\n\t\t\t}\n\t\t\tlet recordId = transition[RECORD_SYMBOL]\n\t\t\tif (recordId) {\n\t\t\t\tif (recordId >= 0x60 && useTwoByteRecords) {\n\t\t\t\t\ttarget[position++] = ((recordId -= 0x60) & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = recordId >> 5\n\t\t\t\t} else\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t} else {\n\t\t\t\tnewRecord(transition, transition.__keys__ || Object.keys(object), newTransitions)\n\t\t\t}\n\t\t\t// now write the values\n\t\t\tfor (let key in object)\n\t\t\t\tif (safePrototype || object.hasOwnProperty(key))\n\t\t\t\t\tpack(object[key])\n\t\t}\n\n\t\t// craete reference to useRecords if useRecords is a function\n\t\tconst checkUseRecords = typeof this.useRecords == 'function' && this.useRecords;\n\t\t\n\t\tconst writeObject = checkUseRecords ? (object, safePrototype) => {\n\t\t\tcheckUseRecords(object) ? writeRecord(object,safePrototype) : writePlainObject(object,safePrototype)\n\t\t} : writeRecord\n\n\t\tconst makeRoom = (end) => {\n\t\t\tlet newSize\n\t\t\tif (end > 0x1000000) {\n\t\t\t\t// special handling for really large buffers\n\t\t\t\tif ((end - start) > MAX_BUFFER_SIZE)\n\t\t\t\t\tthrow new Error('Packed buffer would be larger than maximum buffer size')\n\t\t\t\tnewSize = Math.min(MAX_BUFFER_SIZE,\n\t\t\t\t\tMath.round(Math.max((end - start) * (end > 0x4000000 ? 1.25 : 2), 0x400000) / 0x1000) * 0x1000)\n\t\t\t} else // faster handling for smaller buffers\n\t\t\t\tnewSize = ((Math.max((end - start) << 2, target.length - 1) >> 12) + 1) << 12\n\t\t\tlet newBuffer = new ByteArrayAllocate(newSize)\n\t\t\ttargetView = newBuffer.dataView || (newBuffer.dataView = new DataView(newBuffer.buffer, 0, newSize))\n\t\t\tend = Math.min(end, target.length)\n\t\t\tif (target.copy)\n\t\t\t\ttarget.copy(newBuffer, 0, start, end)\n\t\t\telse\n\t\t\t\tnewBuffer.set(target.slice(start, end))\n\t\t\tposition -= start\n\t\t\tstart = 0\n\t\t\tsafeEnd = newBuffer.length - 10\n\t\t\treturn target = newBuffer\n\t\t}\n\t\tconst newRecord = (transition, keys, newTransitions) => {\n\t\t\tlet recordId = structures.nextId\n\t\t\tif (!recordId)\n\t\t\t\trecordId = 0x40\n\t\t\tif (recordId < sharedLimitId && this.shouldShareStructure && !this.shouldShareStructure(keys)) {\n\t\t\t\trecordId = structures.nextOwnId\n\t\t\t\tif (!(recordId < maxStructureId))\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextOwnId = recordId + 1\n\t\t\t} else {\n\t\t\t\tif (recordId >= maxStructureId)// cycle back around\n\t\t\t\t\trecordId = sharedLimitId\n\t\t\t\tstructures.nextId = recordId + 1\n\t\t\t}\n\t\t\tlet highByte = keys.highByte = recordId >= 0x60 && useTwoByteRecords ? (recordId - 0x60) >> 5 : -1\n\t\t\ttransition[RECORD_SYMBOL] = recordId\n\t\t\ttransition.__keys__ = keys\n\t\t\tstructures[recordId - 0x40] = keys\n\n\t\t\tif (recordId < sharedLimitId) {\n\t\t\t\tkeys.isShared = true\n\t\t\t\tstructures.sharedLength = recordId - 0x3f\n\t\t\t\thasSharedUpdate = true\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (highByte >= 0) {\n\t\t\t\t\ttarget[position++] = 0xd5 // fixext 2\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = (recordId & 0x1f) + 0x60\n\t\t\t\t\ttarget[position++] = highByte\n\t\t\t\t} else {\n\t\t\t\t\ttarget[position++] = 0xd4 // fixext 1\n\t\t\t\t\ttarget[position++] = 0x72 // \"r\" record defintion extension type\n\t\t\t\t\ttarget[position++] = recordId\n\t\t\t\t}\n\n\t\t\t\tif (newTransitions)\n\t\t\t\t\ttransitionsCount += serializationsSinceTransitionRebuild * newTransitions\n\t\t\t\t// record the removal of the id, we can maintain our shared structure\n\t\t\t\tif (recordIdsToRemove.length >= maxOwnStructures)\n\t\t\t\t\trecordIdsToRemove.shift()[RECORD_SYMBOL] = 0 // we are cycling back through, and have to remove old ones\n\t\t\t\trecordIdsToRemove.push(transition)\n\t\t\t\tpack(keys)\n\t\t\t}\n\t\t}\n\t\tconst insertNewRecord = (transition, keys, insertionOffset, newTransitions) => {\n\t\t\tlet mainTarget = target\n\t\t\tlet mainPosition = position\n\t\t\tlet mainSafeEnd = safeEnd\n\t\t\tlet mainStart = start\n\t\t\ttarget = keysTarget\n\t\t\tposition = 0\n\t\t\tstart = 0\n\t\t\tif (!target)\n\t\t\t\tkeysTarget = target = new ByteArrayAllocate(8192)\n\t\t\tsafeEnd = target.length - 10\n\t\t\tnewRecord(transition, keys, newTransitions)\n\t\t\tkeysTarget = target\n\t\t\tlet keysPosition = position\n\t\t\ttarget = mainTarget\n\t\t\tposition = mainPosition\n\t\t\tsafeEnd = mainSafeEnd\n\t\t\tstart = mainStart\n\t\t\tif (keysPosition > 1) {\n\t\t\t\tlet newEnd = position + keysPosition - 1\n\t\t\t\tif (newEnd > safeEnd)\n\t\t\t\t\tmakeRoom(newEnd)\n\t\t\t\tlet insertionPosition = insertionOffset + start\n\t\t\t\ttarget.copyWithin(insertionPosition + keysPosition, insertionPosition + 1, position)\n\t\t\t\ttarget.set(keysTarget.slice(0, keysPosition), insertionPosition)\n\t\t\t\tposition = newEnd\n\t\t\t} else {\n\t\t\t\ttarget[insertionOffset + start] = keysTarget[0]\n\t\t\t}\n\t\t}\n\t\tconst writeStruct = (object, safePrototype) => {\n\t\t\tlet newPosition = writeStructSlots(object, target, position, structures, makeRoom, (value, newPosition, notifySharedUpdate) => {\n\t\t\t\tif (notifySharedUpdate)\n\t\t\t\t\treturn hasSharedUpdate = true;\n\t\t\t\tposition = newPosition;\n\t\t\t\tlet startTarget = target;\n\t\t\t\tpack(value);\n\t\t\t\tif (startTarget !== target) {\n\t\t\t\t\treturn { position, targetView, target }; // indicate the buffer was re-allocated\n\t\t\t\t}\n\t\t\t\treturn position;\n\t\t\t}, this);\n\t\t\tif (newPosition === 0) // bail and go to a msgpack object\n\t\t\t\treturn writeObject(object, true);\n\t\t\tposition = newPosition;\n\t\t}\n\t}\n\tuseBuffer(buffer) {\n\t\t// this means we are finished using our own buffer and we can write over it safely\n\t\ttarget = buffer\n\t\ttargetView = new DataView(target.buffer, target.byteOffset, target.byteLength)\n\t\tposition = 0\n\t}\n\tclearSharedData() {\n\t\tif (this.structures)\n\t\t\tthis.structures = []\n\t\tif (this.typedStructs)\n\t\t\tthis.typedStructs = []\n\t}\n}\n\nfunction copyBinary(source, target, targetOffset, offset, endOffset) {\n\twhile (offset < endOffset) {\n\t\ttarget[targetOffset++] = source[offset++]\n\t}\n}\n\nextensionClasses = [ Date, Set, Error, RegExp, ArrayBuffer, Object.getPrototypeOf(Uint8Array.prototype).constructor /*TypedArray*/, C1Type ]\nextensions = [{\n\tpack(date, allocateForWrite, pack) {\n\t\tlet seconds = date.getTime() / 1000\n\t\tif ((this.useTimestamp32 || date.getMilliseconds() === 0) && seconds >= 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 32\n\t\t\tlet { target, targetView, position} = allocateForWrite(6)\n\t\t\ttarget[position++] = 0xd6\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, seconds)\n\t\t} else if (seconds > 0 && seconds < 0x100000000) {\n\t\t\t// Timestamp 64\n\t\t\tlet { target, targetView, position} = allocateForWrite(10)\n\t\t\ttarget[position++] = 0xd7\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 4000000 + ((seconds / 1000 / 0x100000000) >> 0))\n\t\t\ttargetView.setUint32(position + 4, seconds)\n\t\t} else if (isNaN(seconds)) {\n\t\t\tif (this.onInvalidDate) {\n\t\t\t\tallocateForWrite(0)\n\t\t\t\treturn pack(this.onInvalidDate())\n\t\t\t}\n\t\t\t// Intentionally invalid timestamp\n\t\t\tlet { target, targetView, position} = allocateForWrite(3)\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0xff\n\t\t\ttarget[position++] = 0xff\n\t\t} else {\n\t\t\t// Timestamp 96\n\t\t\tlet { target, targetView, position} = allocateForWrite(15)\n\t\t\ttarget[position++] = 0xc7\n\t\t\ttarget[position++] = 12\n\t\t\ttarget[position++] = 0xff\n\t\t\ttargetView.setUint32(position, date.getMilliseconds() * 1000000)\n\t\t\ttargetView.setBigInt64(position + 4, BigInt(Math.floor(seconds)))\n\t\t}\n\t}\n}, {\n\tpack(set, allocateForWrite, pack) {\n\t\tif (this.setAsEmptyObject) {\n\t\t\tallocateForWrite(0);\n\t\t\treturn pack({})\n\t\t}\n\t\tlet array = Array.from(set)\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x73 // 's' for Set\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack(array)\n\t}\n}, {\n\tpack(error, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x65 // 'e' for error\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ error.name, error.message ])\n\t}\n}, {\n\tpack(regex, allocateForWrite, pack) {\n\t\tlet { target, position} = allocateForWrite(this.moreTypes ? 3 : 0)\n\t\tif (this.moreTypes) {\n\t\t\ttarget[position++] = 0xd4\n\t\t\ttarget[position++] = 0x78 // 'x' for regeXp\n\t\t\ttarget[position++] = 0\n\t\t}\n\t\tpack([ regex.source, regex.flags ])\n\t}\n}, {\n\tpack(arrayBuffer, allocateForWrite) {\n\t\tif (this.moreTypes)\n\t\t\twriteExtBuffer(arrayBuffer, 0x10, allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(hasNodeBuffer ? Buffer.from(arrayBuffer) : new Uint8Array(arrayBuffer), allocateForWrite)\n\t}\n}, {\n\tpack(typedArray, allocateForWrite) {\n\t\tlet constructor = typedArray.constructor\n\t\tif (constructor !== ByteArray && this.moreTypes)\n\t\t\twriteExtBuffer(typedArray, typedArrays.indexOf(constructor.name), allocateForWrite)\n\t\telse\n\t\t\twriteBuffer(typedArray, allocateForWrite)\n\t}\n}, {\n\tpack(c1, allocateForWrite) { // specific 0xC1 object\n\t\tlet { target, position} = allocateForWrite(1)\n\t\ttarget[position] = 0xc1\n\t}\n}]\n\nfunction writeExtBuffer(typedArray, type, allocateForWrite, encode) {\n\tlet length = typedArray.byteLength\n\tif (length + 1 < 0x100) {\n\t\tvar { target, position } = allocateForWrite(4 + length)\n\t\ttarget[position++] = 0xc7\n\t\ttarget[position++] = length + 1\n\t} else if (length + 1 < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(5 + length)\n\t\ttarget[position++] = 0xc8\n\t\ttarget[position++] = (length + 1) >> 8\n\t\ttarget[position++] = (length + 1) & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(7 + length)\n\t\ttarget[position++] = 0xc9\n\t\ttargetView.setUint32(position, length + 1) // plus one for the type byte\n\t\tposition += 4\n\t}\n\ttarget[position++] = 0x74 // \"t\" for typed array\n\ttarget[position++] = type\n\ttarget.set(new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength), position)\n}\nfunction writeBuffer(buffer, allocateForWrite) {\n\tlet length = buffer.byteLength\n\tvar target, position\n\tif (length < 0x100) {\n\t\tvar { target, position } = allocateForWrite(length + 2)\n\t\ttarget[position++] = 0xc4\n\t\ttarget[position++] = length\n\t} else if (length < 0x10000) {\n\t\tvar { target, position } = allocateForWrite(length + 3)\n\t\ttarget[position++] = 0xc5\n\t\ttarget[position++] = length >> 8\n\t\ttarget[position++] = length & 0xff\n\t} else {\n\t\tvar { target, position, targetView } = allocateForWrite(length + 5)\n\t\ttarget[position++] = 0xc6\n\t\ttargetView.setUint32(position, length)\n\t\tposition += 4\n\t}\n\ttarget.set(buffer, position)\n}\n\nfunction writeExtensionData(result, target, position, type) {\n\tlet length = result.length\n\tswitch (length) {\n\t\tcase 1:\n\t\t\ttarget[position++] = 0xd4\n\t\t\tbreak\n\t\tcase 2:\n\t\t\ttarget[position++] = 0xd5\n\t\t\tbreak\n\t\tcase 4:\n\t\t\ttarget[position++] = 0xd6\n\t\t\tbreak\n\t\tcase 8:\n\t\t\ttarget[position++] = 0xd7\n\t\t\tbreak\n\t\tcase 16:\n\t\t\ttarget[position++] = 0xd8\n\t\t\tbreak\n\t\tdefault:\n\t\t\tif (length < 0x100) {\n\t\t\t\ttarget[position++] = 0xc7\n\t\t\t\ttarget[position++] = length\n\t\t\t} else if (length < 0x10000) {\n\t\t\t\ttarget[position++] = 0xc8\n\t\t\t\ttarget[position++] = length >> 8\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t} else {\n\t\t\t\ttarget[position++] = 0xc9\n\t\t\t\ttarget[position++] = length >> 24\n\t\t\t\ttarget[position++] = (length >> 16) & 0xff\n\t\t\t\ttarget[position++] = (length >> 8) & 0xff\n\t\t\t\ttarget[position++] = length & 0xff\n\t\t\t}\n\t}\n\ttarget[position++] = type\n\ttarget.set(result, position)\n\tposition += length\n\treturn position\n}\n\nfunction insertIds(serialized, idsToInsert) {\n\t// insert the ids that need to be referenced for structured clones\n\tlet nextId\n\tlet distanceToMove = idsToInsert.length * 6\n\tlet lastEnd = serialized.length - distanceToMove\n\twhile (nextId = idsToInsert.pop()) {\n\t\tlet offset = nextId.offset\n\t\tlet id = nextId.id\n\t\tserialized.copyWithin(offset + distanceToMove, offset, lastEnd)\n\t\tdistanceToMove -= 6\n\t\tlet position = offset + distanceToMove\n\t\tserialized[position++] = 0xd6\n\t\tserialized[position++] = 0x69 // 'i'\n\t\tserialized[position++] = id >> 24\n\t\tserialized[position++] = (id >> 16) & 0xff\n\t\tserialized[position++] = (id >> 8) & 0xff\n\t\tserialized[position++] = id & 0xff\n\t\tlastEnd = offset\n\t}\n\treturn serialized\n}\n\nfunction writeBundles(start, pack, incrementPosition) {\n\tif (bundledStrings.length > 0) {\n\t\ttargetView.setUint32(bundledStrings.position + start, position + incrementPosition - bundledStrings.position - start)\n\t\tbundledStrings.stringsPosition = position - start;\n\t\tlet writeStrings = bundledStrings\n\t\tbundledStrings = null\n\t\tpack(writeStrings[0])\n\t\tpack(writeStrings[1])\n\t}\n}\n\nexport function addExtension(extension) {\n\tif (extension.Class) {\n\t\tif (!extension.pack && !extension.write)\n\t\t\tthrow new Error('Extension has no pack or write function')\n\t\tif (extension.pack && !extension.type)\n\t\t\tthrow new Error('Extension has no type (numeric code to identify the extension)')\n\t\textensionClasses.unshift(extension.Class)\n\t\textensions.unshift(extension)\n\t}\n\tunpackAddExtension(extension)\n}\nfunction prepareStructures(structures, packr) {\n\tstructures.isCompatible = (existingStructures) => {\n\t\tlet compatible = !existingStructures || ((packr.lastNamedStructuresLength || 0) === existingStructures.length)\n\t\tif (!compatible) // we want to merge these existing structures immediately since we already have it and we are in the right transaction\n\t\t\tpackr._mergeStructures(existingStructures);\n\t\treturn compatible;\n\t}\n\treturn structures\n}\nexport function setWriteStructSlots(writeSlots, makeStructures) {\n\twriteStructSlots = writeSlots;\n\tprepareStructures = makeStructures;\n}\n\nlet defaultPackr = new Packr({ useRecords: false })\nexport const pack = defaultPackr.pack\nexport const encode = defaultPackr.pack\nexport const Encoder = Packr\nexport { FLOAT32_OPTIONS } from './unpack.js'\nimport { FLOAT32_OPTIONS } from './unpack.js'\nexport const { NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } = FLOAT32_OPTIONS\nexport const REUSE_BUFFER_MODE = 512\nexport const RESET_BUFFER_MODE = 1024\n","\n/*\n\nFor \"any-data\":\n32-55 - record with record ids (-32)\n56 - 8-bit record ids\n57 - 16-bit record ids\n58 - 24-bit record ids\n59 - 32-bit record ids\n250-255 - followed by typed fixed width values\n64-250 msgpackr/cbor/paired data\narrays and strings within arrays are handled by paired encoding\n\nStructure encoding:\n(type - string (using paired encoding))+\n\nType encoding\nencoding byte - fixed width byte - next reference+\n\nEncoding byte:\nfirst bit:\n\t0 - inline\n\t1 - reference\nsecond bit:\n\t0 - data or number\n\t1 - string\n\nremaining bits:\n\tcharacter encoding - ISO-8859-x\n\n\nnull (0xff)+ 0xf6\nnull (0xff)+ 0xf7\n\n*/\n\n\nimport {setWriteStructSlots, RECORD_SYMBOL, addExtension} from './pack.js'\nimport {setReadStruct, mult10, readString} from './unpack.js';\nconst ASCII = 3; // the MIBenum from https://www.iana.org/assignments/character-sets/character-sets.xhtml (and other character encodings could be referenced by MIBenum)\nconst NUMBER = 0;\nconst UTF8 = 2;\nconst OBJECT_DATA = 1;\nconst DATE = 16;\nconst TYPE_NAMES = ['num', 'object', 'string', 'ascii'];\nTYPE_NAMES[DATE] = 'date';\nconst float32Headers = [false, true, true, false, false, true, true, false];\nlet evalSupported;\ntry {\n\tnew Function('');\n\tevalSupported = true;\n} catch(error) {\n\t// if eval variants are not supported, do not create inline object readers ever\n}\n\nlet updatedPosition;\nconst hasNodeBuffer = typeof Buffer !== 'undefined'\nlet textEncoder, currentSource;\ntry {\n\ttextEncoder = new TextEncoder()\n} catch (error) {}\nconst encodeUtf8 = hasNodeBuffer ? function(target, string, position) {\n\treturn target.utf8Write(string, position, 0xffffffff)\n} : (textEncoder && textEncoder.encodeInto) ?\n\tfunction(target, string, position) {\n\t\treturn textEncoder.encodeInto(string, target.subarray(position)).written\n\t} : false\n\nconst TYPE = Symbol('type');\nconst PARENT = Symbol('parent');\nsetWriteStructSlots(writeStruct, prepareStructures);\nfunction writeStruct(object, target, position, structures, makeRoom, pack, packr) {\n\tlet typedStructs = packr.typedStructs || (packr.typedStructs = []);\n\t// note that we rely on pack.js to load stored structures before we get to this point\n\tlet targetView = target.dataView;\n\tlet refsStartPosition = (typedStructs.lastStringStart || 100) + position;\n\tlet safeEnd = target.length - 10;\n\tlet start = position;\n\tif (position > safeEnd) {\n\t\tlet lastStart = start;\n\t\ttarget = makeRoom(position);\n\t\ttargetView = target.dataView;\n\t\tposition -= lastStart;\n\t\trefsStartPosition -= lastStart;\n\t\tstart = 0;\n\t\tsafeEnd = target.length - 10;\n\t}\n\n\tlet refOffset, refPosition = refsStartPosition;\n\n\tlet transition = typedStructs.transitions || (typedStructs.transitions = Object.create(null));\n\tlet nextId = typedStructs.nextId || typedStructs.length;\n\tlet headerSize =\n\t\tnextId < 0xf ? 1 :\n\t\t\tnextId < 0xf0 ? 2 :\n\t\t\t\tnextId < 0xf000 ? 3 :\n\t\t\t\t\tnextId < 0xf00000 ? 4 : 0;\n\tif (headerSize === 0)\n\t\treturn 0;\n\tposition += headerSize;\n\tlet queuedReferences = [];\n\tlet usedAscii0;\n\tlet keyIndex = 0;\n\tfor (let key in object) {\n\t\tlet value = object[key];\n\t\tlet nextTransition = transition[key];\n\t\tif (!nextTransition) {\n\t\t\ttransition[key] = nextTransition = {\n\t\t\t\tkey,\n\t\t\t\tparent: transition,\n\t\t\t\tenumerationOffset: 0,\n\t\t\t\tascii0: null,\n\t\t\t\tascii8: null,\n\t\t\t\tnum8: null,\n\t\t\t\tstring16: null,\n\t\t\t\tobject16: null,\n\t\t\t\tnum32: null,\n\t\t\t\tfloat64: null,\n\t\t\t\tdate64: null\n\t\t\t};\n\t\t}\n\t\tif (position > safeEnd) {\n\t\t\tlet lastStart = start;\n\t\t\ttarget = makeRoom(position);\n\t\t\ttargetView = target.dataView;\n\t\t\tposition -= lastStart;\n\t\t\trefsStartPosition -= lastStart;\n\t\t\trefPosition -= lastStart;\n\t\t\tstart = 0;\n\t\t\tsafeEnd = target.length - 10\n\t\t}\n\t\tswitch (typeof value) {\n\t\t\tcase 'number':\n\t\t\t\tlet number = value;\n\t\t\t\tif (number >> 0 === number && number < 0x20000000 && number > -0x1f000000) {\n\t\t\t\t\tif (number < 0xf6 && number >= 0 && (nextTransition.num8 || number < 0x20 && !nextTransition.num32)) {\n\t\t\t\t\t\ttransition = nextTransition.num8 || createTypeTransition(nextTransition, NUMBER, 1);\n\t\t\t\t\t\ttarget[position++] = number;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttransition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n\t\t\t\t\t\ttargetView.setUint32(position, number, true);\n\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else if (number < 0x100000000 && number >= -0x80000000) {\n\t\t\t\t\ttargetView.setFloat32(position, number, true);\n\t\t\t\t\tif (float32Headers[target[position + 3] >>> 5]) {\n\t\t\t\t\t\tlet xShifted\n\t\t\t\t\t\t// this checks for rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\tif (((xShifted = number * mult10[((target[position + 3] & 0x7f) << 1) | (target[position + 2] >> 7)]) >> 0) === xShifted) {\n\t\t\t\t\t\t\ttransition = nextTransition.num32 || createTypeTransition(nextTransition, NUMBER, 4);\n\t\t\t\t\t\t\tposition += 4;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttransition = nextTransition.num64 || createTypeTransition(nextTransition, NUMBER, 8);\n\t\t\t\ttargetView.setFloat64(position, number, true);\n\t\t\t\tposition += 8;\n\t\t\t\tbreak;\n\t\t\tcase 'string':\n\t\t\t\tlet strLength = value.length;\n\t\t\t\trefOffset = refPosition - refsStartPosition;\n\t\t\t\tif ((strLength << 2) + refPosition > safeEnd) {\n\t\t\t\t\tlet lastStart = start;\n\t\t\t\t\ttarget = makeRoom((strLength << 2) + refPosition);\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tposition -= lastStart;\n\t\t\t\t\trefsStartPosition -= lastStart;\n\t\t\t\t\trefPosition -= lastStart;\n\t\t\t\t\tstart = 0;\n\t\t\t\t\tsafeEnd = target.length - 10\n\t\t\t\t}\n\t\t\t\tif (strLength > ((0xff00 + refOffset) >> 2)) {\n\t\t\t\t\tqueuedReferences.push(key, value, position - start);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlet isNotAscii\n\t\t\t\tlet strStart = refPosition;\n\t\t\t\tif (strLength < 0x40) {\n\t\t\t\t\tlet i, c1, c2;\n\t\t\t\t\tfor (i = 0; i < strLength; i++) {\n\t\t\t\t\t\tc1 = value.charCodeAt(i)\n\t\t\t\t\t\tif (c1 < 0x80) {\n\t\t\t\t\t\t\ttarget[refPosition++] = c1\n\t\t\t\t\t\t} else if (c1 < 0x800) {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 | 0xc0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else if (\n\t\t\t\t\t\t\t(c1 & 0xfc00) === 0xd800 &&\n\t\t\t\t\t\t\t((c2 = value.charCodeAt(i + 1)) & 0xfc00) === 0xdc00\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\tc1 = 0x10000 + ((c1 & 0x03ff) << 10) + (c2 & 0x03ff)\n\t\t\t\t\t\t\ti++\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 18 | 0xf0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 12 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tisNotAscii = true;\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 12 | 0xe0\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 >> 6 & 0x3f | 0x80\n\t\t\t\t\t\t\ttarget[refPosition++] = c1 & 0x3f | 0x80\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\trefPosition += encodeUtf8(target, value, refPosition);\n\t\t\t\t\tisNotAscii = refPosition - strStart > strLength;\n\t\t\t\t}\n\t\t\t\tif (refOffset < 0xa0 || (refOffset < 0xf6 && (nextTransition.ascii8 || nextTransition.string8))) {\n\t\t\t\t\t// short strings\n\t\t\t\t\tif (isNotAscii) {\n\t\t\t\t\t\tif (!(transition = nextTransition.string8)) {\n\t\t\t\t\t\t\tif (typedStructs.length > 10 && (transition = nextTransition.ascii8)) {\n\t\t\t\t\t\t\t\t// we can safely change ascii to utf8 in place since they are compatible\n\t\t\t\t\t\t\t\ttransition.__type = UTF8;\n\t\t\t\t\t\t\t\tnextTransition.ascii8 = null;\n\t\t\t\t\t\t\t\tnextTransition.string8 = transition;\n\t\t\t\t\t\t\t\tpack(null, 0, true); // special call to notify that structures have been updated\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\ttransition = createTypeTransition(nextTransition, UTF8, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (refOffset === 0 && !usedAscii0) {\n\t\t\t\t\t\tusedAscii0 = true;\n\t\t\t\t\t\ttransition = nextTransition.ascii0 || createTypeTransition(nextTransition, ASCII, 0);\n\t\t\t\t\t\tbreak; // don't increment position\n\t\t\t\t\t}// else ascii:\n\t\t\t\t\telse if (!(transition = nextTransition.ascii8) && !(typedStructs.length > 10 && (transition = nextTransition.string8)))\n\t\t\t\t\t\ttransition = createTypeTransition(nextTransition, ASCII, 1);\n\t\t\t\t\ttarget[position++] = refOffset;\n\t\t\t\t} else {\n\t\t\t\t\t// TODO: Enable ascii16 at some point, but get the logic right\n\t\t\t\t\t//if (isNotAscii)\n\t\t\t\t\t\ttransition = nextTransition.string16 || createTypeTransition(nextTransition, UTF8, 2);\n\t\t\t\t\t//else\n\t\t\t\t\t\t//transition = nextTransition.ascii16 || createTypeTransition(nextTransition, ASCII, 2);\n\t\t\t\t\ttargetView.setUint16(position, refOffset, true);\n\t\t\t\t\tposition += 2;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'object':\n\t\t\t\tif (value) {\n\t\t\t\t\tif (value.constructor === Date) {\n\t\t\t\t\t\ttransition = nextTransition.date64 || createTypeTransition(nextTransition, DATE, 8);\n\t\t\t\t\t\ttargetView.setFloat64(position, value.getTime(), true);\n\t\t\t\t\t\tposition += 8;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tqueuedReferences.push(key, value, keyIndex);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else { // null\n\t\t\t\t\tnextTransition = anyType(nextTransition, position, targetView, -10); // match CBOR with this\n\t\t\t\t\tif (nextTransition) {\n\t\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\t\tposition = updatedPosition;\n\t\t\t\t\t} else queuedReferences.push(key, value, keyIndex);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase 'boolean':\n\t\t\t\ttransition = nextTransition.num8 || nextTransition.ascii8 || createTypeTransition(nextTransition, NUMBER, 1);\n\t\t\t\ttarget[position++] = value ? 0xf9 : 0xf8; // match CBOR with these\n\t\t\t\tbreak;\n\t\t\tcase 'undefined':\n\t\t\t\tnextTransition = anyType(nextTransition, position, targetView, -9); // match CBOR with this\n\t\t\t\tif (nextTransition) {\n\t\t\t\t\ttransition = nextTransition;\n\t\t\t\t\tposition = updatedPosition;\n\t\t\t\t} else queuedReferences.push(key, value, keyIndex);\n\t\t\t\tbreak;\n\t\t}\n\t\tkeyIndex++;\n\t}\n\n\tfor (let i = 0, l = queuedReferences.length; i < l;) {\n\t\tlet key = queuedReferences[i++];\n\t\tlet value = queuedReferences[i++];\n\t\tlet propertyIndex = queuedReferences[i++];\n\t\tlet nextTransition = transition[key];\n\t\tif (!nextTransition) {\n\t\t\ttransition[key] = nextTransition = {\n\t\t\t\tkey,\n\t\t\t\tparent: transition,\n\t\t\t\tenumerationOffset: propertyIndex - keyIndex,\n\t\t\t\tascii0: null,\n\t\t\t\tascii8: null,\n\t\t\t\tnum8: null,\n\t\t\t\tstring16: null,\n\t\t\t\tobject16: null,\n\t\t\t\tnum32: null,\n\t\t\t\tfloat64: null\n\t\t\t};\n\t\t}\n\t\tlet newPosition;\n\t\tif (value) {\n\t\t\t/*if (typeof value === 'string') { // TODO: we could re-enable long strings\n\t\t\t\tif (position + value.length * 3 > safeEnd) {\n\t\t\t\t\ttarget = makeRoom(position + value.length * 3);\n\t\t\t\t\tposition -= start;\n\t\t\t\t\ttargetView = target.dataView;\n\t\t\t\t\tstart = 0;\n\t\t\t\t}\n\t\t\t\tnewPosition = position + target.utf8Write(value, position, 0xffffffff);\n\t\t\t} else { */\n\t\t\tlet size;\n\t\t\trefOffset = refPosition - refsStartPosition;\n\t\t\tif (refOffset < 0xff00) {\n\t\t\t\ttransition = nextTransition.object16;\n\t\t\t\tif (transition)\n\t\t\t\t\tsize = 2;\n\t\t\t\telse if ((transition = nextTransition.object32))\n\t\t\t\t\tsize = 4;\n\t\t\t\telse {\n\t\t\t\t\ttransition = createTypeTransition(nextTransition, OBJECT_DATA, 2);\n\t\t\t\t\tsize = 2;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\ttransition = nextTransition.object32 || createTypeTransition(nextTransition, OBJECT_DATA, 4);\n\t\t\t\tsize = 4;\n\t\t\t}\n\t\t\tnewPosition = pack(value, refPosition);\n\t\t\t//}\n\t\t\tif (typeof newPosition === 'object') {\n\t\t\t\t// re-allocated\n\t\t\t\trefPosition = newPosition.position;\n\t\t\t\ttargetView = newPosition.targetView;\n\t\t\t\ttarget = newPosition.target;\n\t\t\t\trefsStartPosition -= start;\n\t\t\t\tposition -= start;\n\t\t\t\tstart = 0;\n\t\t\t} else\n\t\t\t\trefPosition = newPosition;\n\t\t\tif (size === 2) {\n\t\t\t\ttargetView.setUint16(position, refOffset, true);\n\t\t\t\tposition += 2;\n\t\t\t} else {\n\t\t\t\ttargetView.setUint32(position, refOffset, true);\n\t\t\t\tposition += 4;\n\t\t\t}\n\t\t} else { // null or undefined\n\t\t\ttransition = nextTransition.object16 || createTypeTransition(nextTransition, OBJECT_DATA, 2);\n\t\t\ttargetView.setInt16(position, value === null ? -10 : -9, true);\n\t\t\tposition += 2;\n\t\t}\n\t\tkeyIndex++;\n\t}\n\n\n\tlet recordId = transition[RECORD_SYMBOL];\n\tif (recordId == null) {\n\t\trecordId = packr.typedStructs.length;\n\t\tlet structure = [];\n\t\tlet nextTransition = transition;\n\t\tlet key, type;\n\t\twhile ((type = nextTransition.__type) !== undefined) {\n\t\t\tlet size = nextTransition.__size;\n\t\t\tnextTransition = nextTransition.__parent;\n\t\t\tkey = nextTransition.key;\n\t\t\tlet property = [type, size, key];\n\t\t\tif (nextTransition.enumerationOffset)\n\t\t\t\tproperty.push(nextTransition.enumerationOffset);\n\t\t\tstructure.push(property);\n\t\t\tnextTransition = nextTransition.parent;\n\t\t}\n\t\tstructure.reverse();\n\t\ttransition[RECORD_SYMBOL] = recordId;\n\t\tpackr.typedStructs[recordId] = structure;\n\t\tpack(null, 0, true); // special call to notify that structures have been updated\n\t}\n\n\n\tswitch (headerSize) {\n\t\tcase 1:\n\t\t\tif (recordId >= 0x10) return 0;\n\t\t\ttarget[start] = recordId + 0x20;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (recordId >= 0x100) return 0;\n\t\t\ttarget[start] = 0x38;\n\t\t\ttarget[start + 1] = recordId;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif (recordId >= 0x10000) return 0;\n\t\t\ttarget[start] = 0x39;\n\t\t\ttargetView.setUint16(start + 1, recordId, true);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tif (recordId >= 0x1000000) return 0;\n\t\t\ttargetView.setUint32(start, (recordId << 8) + 0x3a, true);\n\t\t\tbreak;\n\t}\n\n\tif (position < refsStartPosition) {\n\t\tif (refsStartPosition === refPosition)\n\t\t\treturn position; // no refs\n\t\t// adjust positioning\n\t\ttarget.copyWithin(position, refsStartPosition, refPosition);\n\t\trefPosition += position - refsStartPosition;\n\t\ttypedStructs.lastStringStart = position - start;\n\t} else if (position > refsStartPosition) {\n\t\tif (refsStartPosition === refPosition)\n\t\t\treturn position; // no refs\n\t\ttypedStructs.lastStringStart = position - start;\n\t\treturn writeStruct(object, target, start, structures, makeRoom, pack, packr);\n\t}\n\treturn refPosition;\n}\nfunction anyType(transition, position, targetView, value) {\n\tlet nextTransition;\n\tif ((nextTransition = transition.ascii8 || transition.num8)) {\n\t\ttargetView.setInt8(position, value, true);\n\t\tupdatedPosition = position + 1;\n\t\treturn nextTransition;\n\t}\n\tif ((nextTransition = transition.string16 || transition.object16)) {\n\t\ttargetView.setInt16(position, value, true);\n\t\tupdatedPosition = position + 2;\n\t\treturn nextTransition;\n\t}\n\tif (nextTransition = transition.num32) {\n\t\ttargetView.setUint32(position, 0xe0000100 + value, true);\n\t\tupdatedPosition = position + 4;\n\t\treturn nextTransition;\n\t}\n\t// transition.float64\n\tif (nextTransition = transition.num64) {\n\t\ttargetView.setFloat64(position, NaN, true);\n\t\ttargetView.setInt8(position, value);\n\t\tupdatedPosition = position + 8;\n\t\treturn nextTransition;\n\t}\n\tupdatedPosition = position;\n\t// TODO: can we do an \"any\" type where we defer the decision?\n\treturn;\n}\nfunction createTypeTransition(transition, type, size) {\n\tlet typeName = TYPE_NAMES[type] + (size << 3);\n\tlet newTransition = transition[typeName] || (transition[typeName] = Object.create(null));\n\tnewTransition.__type = type;\n\tnewTransition.__size = size;\n\tnewTransition.__parent = transition;\n\treturn newTransition;\n}\nfunction onLoadedStructures(sharedData) {\n\tif (!(sharedData instanceof Map))\n\t\treturn sharedData;\n\tlet typed = sharedData.get('typed') || [];\n\tif (Object.isFrozen(typed))\n\t\ttyped = typed.map(structure => structure.slice(0));\n\tlet named = sharedData.get('named');\n\tlet transitions = Object.create(null);\n\tfor (let i = 0, l = typed.length; i < l; i++) {\n\t\tlet structure = typed[i];\n\t\tlet transition = transitions;\n\t\tfor (let [type, size, key] of structure) {\n\t\t\tlet nextTransition = transition[key];\n\t\t\tif (!nextTransition) {\n\t\t\t\ttransition[key] = nextTransition = {\n\t\t\t\t\tkey,\n\t\t\t\t\tparent: transition,\n\t\t\t\t\tenumerationOffset: 0,\n\t\t\t\t\tascii0: null,\n\t\t\t\t\tascii8: null,\n\t\t\t\t\tnum8: null,\n\t\t\t\t\tstring16: null,\n\t\t\t\t\tobject16: null,\n\t\t\t\t\tnum32: null,\n\t\t\t\t\tfloat64: null,\n\t\t\t\t\tdate64: null,\n\t\t\t\t};\n\t\t\t}\n\t\t\ttransition = createTypeTransition(nextTransition, type, size);\n\t\t}\n\t\ttransition[RECORD_SYMBOL] = i;\n\t}\n\ttyped.transitions = transitions;\n\tthis.typedStructs = typed;\n\tthis.lastTypedStructuresLength = typed.length;\n\treturn named;\n}\nvar sourceSymbol = Symbol.for('source')\nfunction readStruct(src, position, srcEnd, unpackr) {\n\tlet recordId = src[position++] - 0x20;\n\tif (recordId >= 24) {\n\t\tswitch(recordId) {\n\t\t\tcase 24: recordId = src[position++]; break;\n\t\t\t// little endian:\n\t\t\tcase 25: recordId = src[position++] + (src[position++] << 8); break;\n\t\t\tcase 26: recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16); break;\n\t\t\tcase 27: recordId = src[position++] + (src[position++] << 8) + (src[position++] << 16) + (src[position++] << 24); break;\n\t\t}\n\t}\n\tlet structure = unpackr.typedStructs && unpackr.typedStructs[recordId];\n\tif (!structure) {\n\t\t// copy src buffer because getStructures will override it\n\t\tsrc = Uint8Array.prototype.slice.call(src, position, srcEnd);\n\t\tsrcEnd -= position;\n\t\tposition = 0;\n\t\tunpackr._mergeStructures(unpackr.getStructures());\n\t\tif (!unpackr.typedStructs)\n\t\t\tthrow new Error('Could not find any shared typed structures');\n\t\tunpackr.lastTypedStructuresLength = unpackr.typedStructs.length;\n\t\tstructure = unpackr.typedStructs[recordId];\n\t\tif (!structure)\n\t\t\tthrow new Error('Could not find typed structure ' + recordId);\n\t}\n\tvar construct = structure.construct;\n\tif (!construct) {\n\t\tconstruct = structure.construct = function LazyObject() {\n\t\t}\n\t\tvar prototype = construct.prototype;\n\t\tlet properties = [];\n\t\tlet currentOffset = 0;\n\t\tlet lastRefProperty;\n\t\tfor (let i = 0, l = structure.length; i < l; i++) {\n\t\t\tlet definition = structure[i];\n\t\t\tlet [ type, size, key, enumerationOffset ] = definition;\n\t\t\tif (key === '__proto__')\n\t\t\t\tkey = '__proto_';\n\t\t\tlet property = {\n\t\t\t\tkey,\n\t\t\t\toffset: currentOffset,\n\t\t\t}\n\t\t\tif (enumerationOffset)\n\t\t\t\tproperties.splice(i + enumerationOffset, 0, property);\n\t\t\telse\n\t\t\t\tproperties.push(property);\n\t\t\tlet getRef;\n\t\t\tswitch(size) { // TODO: Move into a separate function\n\t\t\t\tcase 0: getRef = () => 0; break;\n\t\t\t\tcase 1:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet ref = source.bytes[position + property.offset];\n\t\t\t\t\t\treturn ref >= 0xf6 ? toConstant(ref) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\tlet ref = dataView.getUint16(position + property.offset, true);\n\t\t\t\t\t\treturn ref >= 0xff00 ? toConstant(ref & 0xff) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase 4:\n\t\t\t\t\tgetRef = (source, position) => {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\tlet ref = dataView.getUint32(position + property.offset, true);\n\t\t\t\t\t\treturn ref >= 0xffffff00 ? toConstant(ref & 0xff) : ref;\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tproperty.getRef = getRef;\n\t\t\tcurrentOffset += size;\n\t\t\tlet get;\n\t\t\tswitch(type) {\n\t\t\t\tcase ASCII:\n\t\t\t\t\tif (lastRefProperty && !lastRefProperty.next)\n\t\t\t\t\t\tlastRefProperty.next = property;\n\t\t\t\t\tlastRefProperty = property;\n\t\t\t\t\tproperty.multiGetCount = 0;\n\t\t\t\t\tget = function(source) {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet position = source.position;\n\t\t\t\t\t\tlet refStart = currentOffset + position;\n\t\t\t\t\t\tlet ref = getRef(source, position);\n\t\t\t\t\t\tif (typeof ref !== 'number') return ref;\n\n\t\t\t\t\t\tlet end, next = property.next;\n\t\t\t\t\t\twhile(next) {\n\t\t\t\t\t\t\tend = next.getRef(source, position);\n\t\t\t\t\t\t\tif (typeof end === 'number')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tend = null;\n\t\t\t\t\t\t\tnext = next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (end == null)\n\t\t\t\t\t\t\tend = source.bytesEnd - refStart;\n\t\t\t\t\t\tif (source.srcString) {\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/*if (property.multiGetCount > 0) {\n\t\t\t\t\t\t\tlet asciiEnd;\n\t\t\t\t\t\t\tnext = firstRefProperty;\n\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tasciiEnd = dataView.getUint16(source.position + next.offset, true);\n\t\t\t\t\t\t\t\tif (asciiEnd < 0xff00)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tasciiEnd = null;\n\t\t\t\t\t\t\t} while((next = next.next));\n\t\t\t\t\t\t\tif (asciiEnd == null)\n\t\t\t\t\t\t\t\tasciiEnd = source.bytesEnd - refStart\n\t\t\t\t\t\t\tsource.srcString = src.toString('latin1', refStart, refStart + asciiEnd);\n\t\t\t\t\t\t\treturn source.srcString.slice(ref, end);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (source.prevStringGet) {\n\t\t\t\t\t\t\tsource.prevStringGet.multiGetCount += 2;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsource.prevStringGet = property;\n\t\t\t\t\t\t\tproperty.multiGetCount--;\n\t\t\t\t\t\t}*/\n\t\t\t\t\t\treturn readString(src, ref + refStart, end - ref);\n\t\t\t\t\t\t//return src.toString('latin1', ref + refStart, end + refStart);\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase UTF8: case OBJECT_DATA:\n\t\t\t\t\tif (lastRefProperty && !lastRefProperty.next)\n\t\t\t\t\t\tlastRefProperty.next = property;\n\t\t\t\t\tlastRefProperty = property;\n\t\t\t\t\tget = function(source) {\n\t\t\t\t\t\tlet position = source.position;\n\t\t\t\t\t\tlet refStart = currentOffset + position;\n\t\t\t\t\t\tlet ref = getRef(source, position);\n\t\t\t\t\t\tif (typeof ref !== 'number') return ref;\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet end, next = property.next;\n\t\t\t\t\t\twhile(next) {\n\t\t\t\t\t\t\tend = next.getRef(source, position);\n\t\t\t\t\t\t\tif (typeof end === 'number')\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tend = null;\n\t\t\t\t\t\t\tnext = next.next;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (end == null)\n\t\t\t\t\t\t\tend = source.bytesEnd - refStart;\n\t\t\t\t\t\tif (type === UTF8) {\n\t\t\t\t\t\t\treturn src.toString('utf8', ref + refStart, end + refStart);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcurrentSource = source;\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\treturn unpackr.unpack(src, { start: ref + refStart, end: end + refStart });\n\t\t\t\t\t\t\t} finally {\n\t\t\t\t\t\t\t\tcurrentSource = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\t\t\t\tcase NUMBER:\n\t\t\t\t\tswitch(size) {\n\t\t\t\t\t\tcase 4:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\t\tlet position = source.position + property.offset;\n\t\t\t\t\t\t\t\tlet value = dataView.getInt32(position, true)\n\t\t\t\t\t\t\t\tif (value < 0x20000000) {\n\t\t\t\t\t\t\t\t\tif (value > -0x1f000000)\n\t\t\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t\t\tif (value > -0x20000000)\n\t\t\t\t\t\t\t\t\t\treturn toConstant(value & 0xff);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tlet fValue = dataView.getFloat32(position, true);\n\t\t\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\t\t\tlet multiplier = mult10[((src[position + 3] & 0x7f) << 1) | (src[position + 2] >> 7)]\n\t\t\t\t\t\t\t\treturn ((multiplier * fValue + (fValue > 0 ? 0.5 : -0.5)) >> 0) / multiplier;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 8:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\t\t\tlet value = dataView.getFloat64(source.position + property.offset, true);\n\t\t\t\t\t\t\t\tif (isNaN(value)) {\n\t\t\t\t\t\t\t\t\tlet byte = src[source.position + property.offset];\n\t\t\t\t\t\t\t\t\tif (byte >= 0xf6)\n\t\t\t\t\t\t\t\t\t\treturn toConstant(byte);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\treturn value;\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\t\t\tlet value = src[source.position + property.offset];\n\t\t\t\t\t\t\t\treturn value < 0xf6 ? value : toConstant(value);\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase DATE:\n\t\t\t\t\tget = function (source) {\n\t\t\t\t\t\tlet src = source.bytes;\n\t\t\t\t\t\tlet dataView = src.dataView || (src.dataView = new DataView(src.buffer, src.byteOffset, src.byteLength));\n\t\t\t\t\t\treturn new Date(dataView.getFloat64(source.position + property.offset, true));\n\t\t\t\t\t};\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\t\t\tproperty.get = get;\n\t\t}\n\t\t// TODO: load the srcString for faster string decoding on toJSON\n\t\tif (evalSupported) {\n\t\t\tlet objectLiteralProperties = [];\n\t\t\tlet args = [];\n\t\t\tlet i = 0;\n\t\t\tlet hasInheritedProperties;\n\t\t\tfor (let property of properties) { // assign in enumeration order\n\t\t\t\tif (unpackr.alwaysLazyProperty && unpackr.alwaysLazyProperty(property.key)) {\n\t\t\t\t\t// these properties are not eagerly evaluated and this can be used for creating properties\n\t\t\t\t\t// that are not serialized as JSON\n\t\t\t\t\thasInheritedProperties = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tObject.defineProperty(prototype, property.key, { get: withSource(property.get), enumerable: true });\n\t\t\t\tlet valueFunction = 'v' + i++;\n\t\t\t\targs.push(valueFunction);\n\t\t\t\tobjectLiteralProperties.push('[' + JSON.stringify(property.key) + ']:' + valueFunction + '(s)');\n\t\t\t}\n\t\t\tif (hasInheritedProperties) {\n\t\t\t\tobjectLiteralProperties.push('__proto__:this');\n\t\t\t}\n\t\t\tlet toObject = (new Function(...args, 'return function(s){return{' + objectLiteralProperties.join(',') + '}}')).apply(null, properties.map(prop => prop.get));\n\t\t\tObject.defineProperty(prototype, 'toJSON', {\n\t\t\t\tvalue(omitUnderscoredProperties) {\n\t\t\t\t\treturn toObject.call(this, this[sourceSymbol]);\n\t\t\t\t}\n\t\t\t});\n\t\t} else {\n\t\t\tObject.defineProperty(prototype, 'toJSON', {\n\t\t\t\tvalue(omitUnderscoredProperties) {\n\t\t\t\t\t// return an enumerable object with own properties to JSON stringify\n\t\t\t\t\tlet resolved = {};\n\t\t\t\t\tfor (let i = 0, l = properties.length; i < l; i++) {\n\t\t\t\t\t\t// TODO: check alwaysLazyProperty\n\t\t\t\t\t\tlet key = properties[i].key;\n\n\t\t\t\t\t\tresolved[key] = this[key];\n\t\t\t\t\t}\n\t\t\t\t\treturn resolved;\n\t\t\t\t},\n\t\t\t\t// not enumerable or anything\n\t\t\t});\n\t\t}\n\t}\n\tvar instance = new construct();\n\tinstance[sourceSymbol] = {\n\t\tbytes: src,\n\t\tposition,\n\t\tsrcString: '',\n\t\tbytesEnd: srcEnd\n\t}\n\treturn instance;\n}\nfunction toConstant(code) {\n\tswitch(code) {\n\t\tcase 0xf6: return null;\n\t\tcase 0xf7: return undefined;\n\t\tcase 0xf8: return false;\n\t\tcase 0xf9: return true;\n\t}\n\tthrow new Error('Unknown constant');\n}\nfunction withSource(get) {\n\treturn function() {\n\t\treturn get(this[sourceSymbol]);\n\t}\n}\n\nfunction saveState() {\n\tif (currentSource) {\n\t\tcurrentSource.bytes = Uint8Array.prototype.slice.call(currentSource.bytes, currentSource.position, currentSource.bytesEnd);\n\t\tcurrentSource.position = 0;\n\t\tcurrentSource.bytesEnd = currentSource.bytes.length;\n\t}\n}\nfunction prepareStructures(structures, packr) {\n\tif (packr.typedStructs) {\n\t\tlet structMap = new Map();\n\t\tstructMap.set('named', structures);\n\t\tstructMap.set('typed', packr.typedStructs);\n\t\tstructures = structMap;\n\t}\n\tlet lastTypedStructuresLength = packr.lastTypedStructuresLength || 0;\n\tstructures.isCompatible = existing => {\n\t\tlet compatible = true;\n\t\tif (existing instanceof Map) {\n\t\t\tlet named = existing.get('named') || [];\n\t\t\tif (named.length !== (packr.lastNamedStructuresLength || 0))\n\t\t\t\tcompatible = false;\n\t\t\tlet typed = existing.get('typed') || [];\n\t\t\tif (typed.length !== lastTypedStructuresLength)\n\t\t\t\tcompatible = false;\n\t\t} else if (existing instanceof Array || Array.isArray(existing)) {\n\t\t\tif (existing.length !== (packr.lastNamedStructuresLength || 0))\n\t\t\t\tcompatible = false;\n\t\t}\n\t\tif (!compatible)\n\t\t\tpackr._mergeStructures(existing);\n\t\treturn compatible;\n\t};\n\tpackr.lastTypedStructuresLength = packr.typedStructs && packr.typedStructs.length;\n\treturn structures;\n}\n\nsetReadStruct(readStruct, onLoadedStructures, saveState);\n\n","export { Packr, Encoder, addExtension, pack, encode, NEVER, ALWAYS, DECIMAL_ROUND, DECIMAL_FIT } from './pack.js'\nexport { Unpackr, Decoder, C1, unpack, unpackMultiple, decode, FLOAT32_OPTIONS, clearSource, roundFloat32, isNativeAccelerationEnabled } from './unpack.js'\nimport './struct.js'\nexport { PackrStream, UnpackrStream, PackrStream as EncoderStream, UnpackrStream as DecoderStream } from './stream.js'\nexport { decodeIter, encodeIter } from './iterators.js'\nexport const useRecords = false\nexport const mapsAsObjects = true\nimport { setExtractor } from './unpack.js'\nimport { createRequire } from 'module'\n\nconst nativeAccelerationDisabled = process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED !== undefined && process.env.MSGPACKR_NATIVE_ACCELERATION_DISABLED.toLowerCase() === 'true';\n\nif (!nativeAccelerationDisabled) {\n\tlet extractor\n\ttry {\n\t\tif (typeof require == 'function')\n\t\t\textractor = require('msgpackr-extract')\n\t\telse\n\t\t\textractor = createRequire(import.meta.url)('msgpackr-extract')\n\t\tif (extractor)\n\t\t\tsetExtractor(extractor.extractStrings)\n\t} catch (error) {\n\t\t// native module is optional\n\t}\n}","const __WEBPACK_NAMESPACE_OBJECT__ = require(\"stream\");","const PINNED_IN_MEMORY = 0x7fffffff\r\nconst NOT_IN_LRU = 0x40000000\r\nexport const EXPIRED_ENTRY = {\r\n\tdescription: 'This cache entry value has been expired from the LRFU cache, and is waiting for garbage collection to be removed.'\r\n}\r\n/* bit pattern:\r\n*  < is-in-lru 1 bit > ...< mask/or bits 6 bits > <lru index 2 bits > < position in cache - 22 bits >\r\n*/\r\nexport class LRFUExpirer {\r\n\tconstructor(options) {\r\n\t\tthis.lruSize = options && options.lruSize || 0x2000\r\n\t\tif (this.lruSize > 0x400000)\r\n\t\t\tthrow new Error('The LRU/cache size was larger than the maximum cache size of 16777216 (LRU size of 4194304)')\r\n\t\tthis.reset()\r\n\t\tstartTimedCleanup(new WeakRef(this), options && options.cleanupInterval || 60000)\r\n\t}\r\n\tdelete(entry) {\r\n\t\tif (entry.position < NOT_IN_LRU) {\r\n\t\t\tthis.lru[(entry.position >> 22) & 3][entry.position & 0x3fffff] = null\r\n\t\t}\r\n\t\tentry.position |= NOT_IN_LRU\r\n\t}\r\n\tused(entry, expirationPriority) {\r\n\t\tlet originalPosition = entry.position\r\n\t\tlet orMask\r\n\t\tif (expirationPriority < 0) {\r\n\t\t\t// pin this in memory, first remove from LRFU and then mark it as pinned in memory\r\n\t\t\tif (entry.position < NOT_IN_LRU) {\r\n\t\t\t\tthis.lru[(entry.position >> 22) & 3][entry.position & 0x3fffff] = null\r\n\t\t\t}\r\n\t\t\tentry.position = PINNED_IN_MEMORY\r\n\t\t\treturn\r\n\t\t} else if (entry.position == PINNED_IN_MEMORY && expirationPriority == undefined) {\r\n\t\t\treturn\r\n\t\t} else if (expirationPriority >= 0) {\r\n\t\t\tlet bits = 0\r\n\t\t\tif (expirationPriority > (this.lruSize >> 2))\r\n\t\t\t\texpirationPriority = this.lruSize >> 2\r\n\t\t\twhile (expirationPriority > 0) {\r\n\t\t\t\texpirationPriority = expirationPriority >> 1\r\n\t\t\t\tbits++\r\n\t\t\t}\r\n\t\t\texpirationPriority = bits\r\n\t\t} else {\r\n\t\t\tif (originalPosition >= 0)\r\n\t\t\t\texpirationPriority = (originalPosition >> 24) & 0x3f\r\n\t\t\telse\r\n\t\t\t\texpirationPriority = 0\r\n\t\t}\r\n\t\t\r\n\t\tlet lruPosition\r\n\t\tlet lruIndex\r\n\t\tif (originalPosition < NOT_IN_LRU) {\r\n\t\t\tlruIndex = (originalPosition >> 22) & 3\r\n\t\t\tif (lruIndex >= 3)\r\n\t\t\t\treturn // can't get any higher than this, don't do anything\r\n\t\t\tlet lru = this.lru[lruIndex]\r\n\t\t\t// check to see if it is in the same generation\r\n\t\t\tlruPosition = lru.position\r\n\t\t\tif ((originalPosition > lruPosition ? lruPosition + this.lruSize : lruPosition) - originalPosition < (this.lruSize >> 2))\r\n\t\t\t\treturn // only recently added, don't promote\r\n\t\t\tlru[originalPosition & 0x3fffff] = null // remove it, we are going to move/promote it\r\n\t\t\tlruIndex++\r\n\t\t} else\r\n\t\t\tlruIndex = 0\r\n\t\tthis.insertEntry(entry, lruIndex, expirationPriority)\r\n\t}\r\n\tinsertEntry(entry, lruIndex, expirationPriority) {\r\n\t\tlet lruPosition, nextLru = this.lru[lruIndex]\r\n\t\tlet orMask = 0x3fffff >> (22 - expirationPriority)\r\n\t\tdo {\r\n\t\t\t// put it in the next lru\r\n\t\t\tlruPosition = nextLru.position | orMask\r\n\t\t\tlet previousEntry = nextLru[lruPosition & 0x3fffff]\r\n\t\t\tnextLru[lruPosition & 0x3fffff] = entry\r\n\t\t\tif (entry)\r\n\t\t\t\tentry.position = lruPosition | (expirationPriority << 24)\r\n\t\t\tnextLru.position = ++lruPosition\r\n\t\t\tif ((lruPosition & 0x3fffff) >= this.lruSize) {\r\n\t\t\t\t// reset at the beginning of the lru cache\r\n\t\t\t\tlruPosition &= 0x7fc00000\r\n\t\t\t\tnextLru.position = lruPosition\r\n\t\t\t\tnextLru.cycles++\r\n\t\t\t}\r\n\t\t\tentry = previousEntry\r\n\t\t\tif (entry && (nextLru = this.lru[--lruIndex])) {\r\n\t\t\t\texpirationPriority = ((entry.position || 0) >> 24) & 0x3f\r\n\t\t\t\torMask = 0x3fffff >> (22 - expirationPriority)\r\n\t\t\t} else\r\n\t\t\t\tbreak\r\n\t\t} while (true)\r\n\t\tif (entry) {// this one was removed\r\n\t\t\tentry.position |= NOT_IN_LRU\r\n\t\t\tif (entry.cache)\r\n\t\t\t\tentry.cache.onRemove(entry)\r\n\t\t\telse if (entry.deref) // if we have already registered the entry in the finalization registry, just clear it\r\n\t\t\t\tentry.value = EXPIRED_ENTRY\r\n\t\t}\r\n\t}\r\n\treset() {\r\n\t/*\tif (this.lru) {\r\n\t\t\tfor (let i = 0; i < 4; i++) {\r\n\t\t\t\tfor (let j = 0, l = this.lru.length; j < l; j++) {\r\n\t\t\t\t\tlet entry =\tthis.lru[i][j]\r\n\t\t\t\t\tif (entry) {// this one was removed\r\n\t\t\t\t\t\tentry.position |= NOT_IN_LRU\r\n\t\t\t\t\t\tif (entry.cache)\r\n\t\t\t\t\t\t\tentry.cache.onRemove(entry)\r\n\t\t\t\t\t\telse if (entry.deref) // if we have already registered the entry in the finalization registry, just clear it\r\n\t\t\t\t\t\t\tentry.value = EXPIRED_ENTRY\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}*/\r\n\t\tthis.lru = []\r\n\t\tfor (let i = 0; i < 4; i++) {\r\n\t\t\tthis.lru[i] = new Array(this.lruSize)\r\n\t\t\tthis.lru[i].position = i << 22\r\n\t\t\tthis.lru[i].cycles = 0\r\n\t\t}\r\n\t}\r\n\tcleanup() { // clean out a portion of the cache, so we can clean up over time if idle\r\n\t\tlet toClear = this.lruSize >> 4 // 1/16 of the lru cache at a time\r\n\t\tfor (let i = 3; i >= 0; i--) {\r\n\t\t\tlet lru = this.lru[i]\r\n\t\t\tfor (let j = 0, l = toClear; j < l; j++) {\r\n\t\t\t\tif (lru[lru.position & 0x3fffff]) {\r\n\t\t\t\t\ttoClear--\r\n\t\t\t\t\tthis.insertEntry(null, i, 0)\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif ((++lru.position & 0x3fffff) >= this.lruSize) {\r\n\t\t\t\t\t\t// reset at the beginning of the lru cache\r\n\t\t\t\t\t\tlru.position &= 0x7fc00000\r\n\t\t\t\t\t\tlru.cycles++\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\nfunction startTimedCleanup(reference, cleanupInterval) {\r\n\tlet interval = setInterval(() => {\r\n\t\tlet expirer = reference.deref()\r\n\t\tif (expirer)\r\n\t\t\texpirer.cleanup()\r\n\t\telse\r\n\t\t\tclearInterval(interval)\r\n\t}, cleanupInterval)\r\n\tif (interval.unref)\r\n\t\tinterval.unref()\r\n}","import { LRFUExpirer, EXPIRED_ENTRY } from './LRFUExpirer.js'\r\nexport { LRFUExpirer } from './LRFUExpirer.js'\r\n\r\nlet defaultExpirer\r\nexport class WeakLRUCache extends Map  {\r\n\tconstructor(options) {\r\n\t\tsuper()\r\n\t\tthis.hits = 0\r\n\t\tthis.misses = 0\r\n\t\tif (options && options.cacheSize) {\r\n\t\t\toptions.lruSize = options.cacheSize >> 2\r\n\t\t}\r\n\t\tif (options && options.clearKeptInterval) {\r\n\t\t\tthis.clearKeptInterval = options.clearKeptInterval\r\n\t\t\tthis.clearKeptCount = 0\r\n\t\t\tthis.clearKeptObjects = options.clearKeptObjects\r\n\t\t}\r\n\t\tthis.expirer = (options ? options.expirer === false ? defaultNoLRUExpirer : options.expirer : null) || defaultExpirer || (defaultExpirer = new LRFUExpirer(options))\r\n\t\tthis.deferRegister = Boolean(options && options.deferRegister)\r\n\t\tlet registry = this.registry = new FinalizationRegistry(key => {\r\n\t\t\tlet entry = super.get(key)\r\n\t\t\tif (entry && entry.deref && entry.deref() === undefined)\r\n\t\t\t\tsuper.delete(key)\r\n\t\t})\r\n\t}\r\n\tonRemove(entry) {\r\n\t\tlet target = entry.deref && entry.deref()\r\n\t\tif (target) {\r\n\t\t\t// remove strong reference, so only a weak reference, wait until it is finalized to remove\r\n\t\t\tthis.registry.register(target, entry.key)\r\n\t\t\tentry.value = undefined\r\n\t\t} else if (entry.key) {\r\n\t\t\tlet currentEntry = super.get(entry.key)\r\n\t\t\tif (currentEntry === entry)\r\n\t\t\t\tsuper.delete(entry.key)\r\n\t\t}\r\n\t}\r\n\tget(key, mode) {\r\n\t\tlet entry = super.get(key)\r\n\t\tlet value\r\n\t\tif (entry) {\r\n\t\t\tthis.hits++\r\n\t\t\tvalue = entry.value\r\n\t\t\tif (value === EXPIRED_ENTRY) {\r\n\t\t\t\tvalue = entry.deref && entry.deref()\r\n\t\t\t\tif (value === undefined)\r\n\t\t\t\t\tsuper.delete(key)\r\n\t\t\t\telse {\r\n\t\t\t\t\tentry.value = value\r\n\t\t\t\t\tif (this.clearKeptInterval)\r\n\t\t\t\t\t\tthis.incrementClearKeptCount()\r\n\t\t\t\t\tif (mode !== 1)\r\n\t\t\t\t\t\tthis.expirer.used(entry)\r\n\t\t\t\t\treturn mode === 2 ? value : entry\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (mode !== 1)\r\n\t\t\t\t\tthis.expirer.used(entry)\r\n\t\t\t\treturn mode === 2 ? value : entry\r\n\t\t\t}\r\n\t\t} else\r\n\t\t\tthis.misses++\r\n\t}\r\n\tgetValue(key) {\r\n\t\treturn this.get(key, 2)\r\n\t}\r\n\r\n\tsetValue(key, value, expirationPriority) {\r\n\t\tlet entry\r\n\t\tif (value && typeof value == 'object') {\r\n\t\t\tentry = new WeakRef(value)\r\n\t\t\tif (this.clearKeptInterval)\r\n\t\t\t\tthis.incrementClearKeptCount()\r\n\t\t\tentry.value = value\r\n\t\t\tif (this.deferRegister) {\r\n\t\t\t\tentry.key = key\r\n\t\t\t\tentry.cache = this\r\n\t\t\t} else\r\n\t\t\t\tthis.registry.register(value, key)\r\n\t\t} else if (value !== undefined)\r\n\t\t\tentry = { value, key, cache: this }\r\n\t\t// else entry is undefined\r\n\t\tthis.set(key, entry, expirationPriority)\r\n\t\treturn entry\r\n\t}\r\n\tincrementClearKeptCount() {\r\n\t\tif (++this.clearKeptCount >= this.clearKeptInterval) {\r\n\t\t\tthis.clearKeptCount = 0\r\n\t\t\tif (this.clearKeptObjects)\r\n\t\t\t\tthis.clearKeptObjects()\r\n\t\t\tif (this.registry.cleanupSome)\r\n\t\t\t\tthis.registry.cleanupSome()\r\n\t\t}\r\n\t}\r\n\tset(key, entry, expirationPriority) {\r\n\t\tlet oldEntry = super.get(key)\r\n\t\tif (oldEntry)\r\n\t\t\tthis.expirer.delete(oldEntry)\r\n\t\treturn this.insert(key, entry, expirationPriority)\r\n\t}\r\n\tinsert(key, entry, expirationPriority) {\r\n\t\tif (entry) {\r\n\t\t\tthis.expirer.used(entry, expirationPriority)\r\n\t\t}\r\n\t\treturn super.set(key, entry)\r\n\t}\r\n\tdelete(key) {\r\n\t\tlet oldEntry = super.get(key)\r\n\t\tif (oldEntry) {\r\n\t\t\tthis.expirer.delete(oldEntry)\r\n\t\t}\r\n\t\treturn super.delete(key)\r\n\t}\r\n\tused(entry, expirationPriority) {\r\n\t\tthis.expirer.used(entry, expirationPriority)\r\n\t}\r\n\tclear() {\r\n\t\tfor (let [ key, entry ] of this) {\r\n\t\t\tthis.expirer.delete(entry)\r\n\t\t\tsuper.delete(key)\r\n\t\t}\r\n\t}\r\n}\r\n\r\nclass NoLRUExpirer {\r\n\tused(entry) {\r\n\t\tif (entry.cache)\r\n\t\t\tentry.cache.onRemove(entry)\r\n\t\telse if (entry.deref) // if we have already registered the entry in the finalization registry, just mark it expired from the beginning\r\n\t\t\tentry.value = EXPIRED_ENTRY\r\n\t}\r\n\tdelete(entry) {\r\n\t\t// nothing to do here, we don't have a separate cache here\r\n\t}\r\n}\r\nconst defaultNoLRUExpirer = new NoLRUExpirer()","export function levelup(store) {\n\treturn Object.assign(Object.create(store), {\n\t\tget(key, options, callback) {\n\t\t\tlet result = store.get(key);\n\t\t\tif (typeof options == 'function')\n\t\t\t\tcallback = options;\n\t\t\tif (callback) {\n\t\t\t\tif (result === undefined)\n\t\t\t\t\tcallback(new NotFoundError());\n\t\t\t\telse\n\t\t\t\t\tcallback(null, result);\n\t\t\t} else {\n\t\t\t\tif (result === undefined)\n\t\t\t\t\treturn Promise.reject(new NotFoundError());\n\t\t\t\telse\n\t\t\t\t\treturn Promise.resolve(result);\n\t\t\t}\n\t\t},\n\t});\n}\nclass NotFoundError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'NotFoundError';\n\t\tthis.notFound = true;\n\t}\n}","import { EventEmitter } from 'events';\nimport { setExternals, setNativeFunctions, Dbi } from './native.js';\nimport { arch, tmpdir, platform } from 'os';\nimport fs from 'fs';\nimport { Encoder as MsgpackrEncoder } from 'msgpackr';\nimport { WeakLRUCache } from 'weak-lru-cache';\nimport * as orderedBinary from 'ordered-binary';\n\n\norderedBinary.enableNullTermination();\nsetExternals({\n\tarch, fs, tmpdir, MsgpackrEncoder, WeakLRUCache, orderedBinary,\n\tEventEmitter, os: platform(), onExit(callback) {\n\t\tif (process.getMaxListeners() < process.listenerCount('exit') + 8)\n\t\t\tprocess.setMaxListeners(process.listenerCount('exit') + 8);\n\t\tprocess.on('exit', callback);\n\t},\n});\nexport { toBufferKey as keyValueToBuffer, compareKeys, compareKeys as compareKey, fromBufferKey as bufferToKeyValue } from 'ordered-binary';\nexport { ABORT, IF_EXISTS, asBinary } from './write.js';\nimport { ABORT, IF_EXISTS, asBinary } from './write.js';\nexport { levelup } from './level.js';\nexport { SKIP } from './util/RangeIterable.js';\nimport { levelup } from './level.js';\nexport { clearKeptObjects } from './native.js';\nimport { nativeAddon } from './native.js';\nexport let { noop } = nativeAddon;\nexport { open, openAsClass, getLastVersion, allDbs, getLastTxnId } from './open.js';\nimport { toBufferKey as keyValueToBuffer, compareKeys as compareKey, fromBufferKey as bufferToKeyValue } from 'ordered-binary';\nimport { open, openAsClass, getLastVersion } from './open.js';\nexport const TransactionFlags = {\n\tABORTABLE: 1,\n\tSYNCHRONOUS_COMMIT: 2,\n\tNO_SYNC_FLUSH: 0x10000,\n};\nexport default {\n\topen, openAsClass, getLastVersion, compareKey, keyValueToBuffer, bufferToKeyValue, ABORT, IF_EXISTS, asBinary, levelup, TransactionFlags\n};\n","import { createRequire } from 'module';\nimport { setRequire } from './open.js';\nimport { nativeAddon, setNativeFunctions } from './native.js';\nexport { nativeAddon } from './native.js'\nlet require = createRequire(import.meta.url);\nsetRequire(require);\nexport let v8AccelerationEnabled = false\n\nlet versions = process.versions;\nif (!versions.deno && !process.isBun) {\n\tlet [ majorVersion, minorVersion ] = versions.node.split('.');\n\tif (versions.v8 && +majorVersion == nativeAddon.version.nodeCompiledVersion) {\n\t\tlet v8Funcs = {};\n\t\tlet fastApiCalls = (majorVersion == 17 || majorVersion == 18 || majorVersion == 16 && minorVersion > 8) && !process.env.DISABLE_TURBO_CALLS;\n\t\tif (fastApiCalls) {\n\t\t\trequire('v8').setFlagsFromString('--turbo-fast-api-calls');\n\t\t}\n\t\tnativeAddon.enableDirectV8(v8Funcs, fastApiCalls);\n\t\tObject.assign(nativeAddon, v8Funcs);\n\t\tv8AccelerationEnabled = true;\n\t} else if (majorVersion == 14) {\n\t\t// node v14 only has ABI compatibility with node v16 for zero-arg clearKeptObjects\n\t\tlet v8Funcs = {};\n\t\tnativeAddon.enableDirectV8(v8Funcs, false);\n\t\tnativeAddon.clearKeptObjects = v8Funcs.clearKeptObjects;\n\t}\n\tnativeAddon.enableThreadSafeCalls();\n}\nsetNativeFunctions(nativeAddon);\n\nexport * from './index.js'\nexport { default } from './index.js'\n","import { open } from 'lmdb';\r\nimport path from 'path';\r\nimport * as vscode from 'vscode';\r\nconst deactivationEvents: (() => Promise<void>)[] = [];\r\nexport async function activate(context: vscode.ExtensionContext) {                                                    \r\n    let db = open(context.asAbsolutePath('db'), {\r\n        \r\n    });\r\n}   \r\n\r\n// this method is called when your extension is deactivated\r\nexport async function deactivate(): Promise<void> {    \r\n    for (let deactivateME of deactivationEvents) {\r\n        await deactivateME();\r\n    }\r\n}"],"names":["childProcess","isLinux","getReport","command","commandOut","safeCommand","Promise","resolve","exec","err","out","safeCommandSync","execSync","encoding","_err","GLIBC","MUSL","isFileMusl","f","includes","familyFromReport","report","header","glibcVersionRuntime","Array","isArray","sharedObjects","some","familyFromCommand","getconf","ldd1","split","family","async","familySync","versionFromReport","versionSuffix","s","trim","versionFromCommand","ldd2","module","exports","isNonGlibcLinux","isNonGlibcLinuxSync","version","versionSync","process","platform","fs","path","url","vars","config","variables","prebuildsOnly","env","PREBUILDS_ONLY","versions","abi","modules","deno","isBun","runtime","electron","ELECTRON_RUN_AS_NODE","window","type","arch","libc","LIBC","isMusl","armv","ARM_VERSION","arm_version","uv","load","dir","readdirSync","getFirst","filter","files","join","matchBuild","name","test","parseTuple","arr","length","architectures","every","Boolean","matchTuple","tuple","compareTuples","a","b","parseTags","file","tags","specificity","pop","i","tag","napi","slice","matchTags","runtimeAgnostic","compareTags","packageName","varName","toUpperCase","replace","release","debug","prebuild","nearby","dirname","execPath","platformPackage","resolveFile","pathToFileURL","error","target","node","Error","map","sort","prebuilds","winner","require","float64Array","Float64Array","int32Array","Int32Array","buffer","nullTerminate","textEncoder","position","TextEncoder","writeKey","key","inSequence","targetView","dataView","DataView","byteOffset","byteLength","strLength","c1","charCodeAt","c2","utf8Write","encodeInto","subarray","written","RangeError","lowInt","highInt","setInt32","l","Uint8Array","set","setUint32","Number","description","readKey","start","end","value","controlByte","prototype","call","Symbol","for","readString","getInt32","size","encoder","nextValue","push","enableNullTermination","targetBuffer","targetPosition","hasNodeBuffer","Buffer","ByteArrayAllocate","allocUnsafeSlow","toBufferKey","newBuffer","result","fromBufferKey","sourceBuffer","fromCharCode","String","makeStringBuilder","stringBuildCode","previous","v","finishUtf8","pendingSurrogate","byte1","src","unit","eval","compareKeys","compare","arrayComparison","keyFor","typeOrder","symbol","undefined","boolean","number","string","MINIMUM_KEY","MAXIMUM_KEY","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","o","Object","defineProperty","enumerable","get","obj","prop","hasOwnProperty","r","toStringTag","Env","Txn","Dbi","Compression","Cursor","getAddress","getBufferAddress","createBufferForAddress","clearKeptObjects","globalBuffer","setGlobalBuffer","os","onExit","tmpdir","lmdbError","EventEmitter","orderedBinary","MsgpackrEncoder","WeakLRUCache","getByBinary","detachBuffer","startRead","setReadCallback","write","iterate","prefetch","resetTxn","getCurrentValue","getCurrentShared","getStringByBinary","getSharedByBinary","getSharedBuffer","compress","nativeAddon","fileURLToPath","setNativeFunctions","externals","when","promise","callback","errback","then","backpressureArray","WAITING_OPERATION","BACKPRESSURE_THRESHOLD","TXN_DELIMITER","TXN_COMMITTED","TXN_FLUSHED","TXN_FAILED","FAILED_CONDITION","REUSE_BUFFER_MODE","RESET_BUFFER_MODE","NO_RESOLVE","HAS_TXN","CONDITIONAL_VERSION_LESS_THAN","CONDITIONAL_ALLOW_NOTFOUND","SYNC_PROMISE_SUCCESS","SYNC_PROMISE_FAIL","isSync","PROMISE_SUCCESS","ABORT","IF_EXISTS","CALLBACK_THREW","LocalSharedArrayBuffer","Deno","ArrayBuffer","SharedArrayBuffer","ByteArray","from","queueTask","setImmediate","setTimeout","WRITE_BUFFER_SIZE","Batch","constructor","super","this","put","del","clear","splice","SKIP","DONE","done","asyncIterator","RangeIterable","sourceArray","iterator","bind","func","source","iterable","next","resolvedResult","iteratorResult","onDone","return","throw","element","forEach","concat","secondIterable","concatIterable","isFirst","flatMap","mappedIterable","currentSubIterator","toJSON","asArray","_asArray","reject","array","resolveData","writeUint32Key","readUint32Key","getUint32","writeBufferKey","Uint8ArraySlice","readBufferKey","lastEncodedValue","bytes","saveBuffer","uint32","saveDataAddress","saveDataView","setFloat64","savePosition","DYNAMIC_KEY_BUFFER_SIZE","allocateSaveBuffer","alloc","address","saveKey","saveTo","maxKeySize","flags","fill","ITERATOR_DONE","getValueBytes","maxLength","isGlobal","writable","configurable","START_ADDRESS_POSITION","NEW_BUFFER_THRESHOLD","SOURCE_SYMBOL","UNMODIFIED","mmaps","addReadMethods","LMDBStore","keyBytes","keyBytesView","getLastVersion","getLastTxnId","readTxn","readTxnRenewed","asSafeBuffer","renewId","outstandingReads","assign","getString","id","options","txn","writeTxn","transaction","renewReadTxn","dbAddress","_allocateGetBuffer","lastSize","getBinaryFast","rc","ifNotTxnId","getMMapBuffer","compression","_returnLargeBuffer","getBFAsync","refCount","recordReadInstruction","db","dbi","bufferId","offset","isSharedMap","resolveReads","getAsync","useVersions","decoder","decode","utf8Slice","JSON","parse","retain","data","getFast","bytesToRestore","dictionary","dictLength","makeReusableBuffer","setBuffer","newLength","Math","min","max","getBinary","fastBuffer","getSharedBinary","decoderCopies","getEntry","resetReadTxn","_commitReadTxn","isCommitted","commit","lastReadTxnRef","ensureReadTxn","doesExist","versionOrValue","encode","getValuesCount","exactMatch","getValues","defaultOptions","valuesForKey","snapshot","getRange","getKeys","values","getCount","onlyCount","getKeysCount","includeValues","includeVersions","limit","currentKey","reverse","cursor","cursorRenewId","cursorAddress","count","inclusiveEnd","exclusiveStart","store","resetCursor","txnAddress","finishCursor","isDone","availableCursor","renewingRefCount","close","endAddress","keySize","startAddress","notCurrent","abort","cursorTxn","toString","getMany","keys","results","getSharedBufferForGet","keyIsCompatibility","getBinaryShared","startPosition","lastBuffer","buffers","bufferHolder","console","useReadTransaction","use","txnPromise","status","isRoot","renew","_endWrites","doClose","getStats","dbStats","stat","root","info","free","freeStat","waitArray","retries","lastReadTxn","deref","message","Atomics","wait","emit","WeakRef","readInstructions","uint32Instructions","instructionsAddress","readCallbacks","Map","instructionsDataView","allocateInstructionsBuffer","keyPosition","callbackId","addReadCallback","thisInstructions","nextCallbackId","globalThis","__lmdb_read_callback","delete","mapGet","CachingStore","Store","childTxnChanges","dbName","cacheCommitter","on","last","txnId","meta","flag","cache","expirationPriority","valueSize","entry","used","cachingDb","clearKeptInterval","validated","isCaching","cachedValue","getValue","setValue","putEntry","ifVersion","setManually","add","putSync","remove","removeSync","clearAsync","clearSync","childTransaction","previousChanges","Set","setGetLastVersion","getTxnId","moduleRequire","__lmdb_envs__","setEnvsPointer","getEnvsPointer","MAX_KEY_SIZE","DEFAULT_MAX_KEY_SIZE","DEFAULT_COMMIT_DELAY","allDbs","defaultCompression","hasRegisteredOnExit","open","KEY_BUFFER_SIZE","keyBuffer","Uint32Array","float64","allocateFixedBuffer","noFSAccess","userOptions","deleteOnClose","noSync","floor","random","extension","extname","basename","is32Bit","endsWith","remapChunks","encryptionKey","mapSize","userMapSize","makeCompression","compressionOptions","useDefault","threshold","readFileSync","URL","noSubdir","maxDbs","overlappingSync","readOnly","safeRestore","LMDB_RESTORE","asyncTransactionOrder","strictAsyncOrder","major","minor","patch","trackMetrics","usePreviousSnapshot","existsSync","statSync","exists","mkdirSync","recursive","noMetaSync","useWritemap","mapAsync","noReadAhead","noMemInit","jsFlags","separateFlushed","getMaxKeySize","pageSize","getEnvFlags","setJSFlags","readerCheck","dbOptions","dupSort","keyIsBuffer","keyEncoding","keyIsUint32","keyEncoder","Encoder","reverseKey","dupFixed","integerDup","reverseDup","create","keyType","transactionSync","reads","writes","transactions","averageTransactionTime","syncBatchThreshold","warn","immediateBatchThreshold","commitDelay","allowedProperties","arguments","assignConstrainedProperties","sharedStructuresKey","setupSharedStructures","copyBuffers","stringify","needsStableBuffer","mode","openDB","indexOf","backup","compact","copy","isOperational","sync","deleteDB","dropSync","drop","justFreePages","clearSharedData","structures","readerList","saveStructures","isCompatible","existingStructuresBuffer","existingStructures","getStructures","lastVersion","fixedBuffer","eventTurnBatching","txnStartThreshold","batchStartThreshold","maxFlushDelay","dynamicBytes","allocateInstructionBuffer","lastPosition","lastBytes","committed","abortedNonChildTransactionWarn","commitPromise","flushPromise","enqueuedCommit","newBufferThreshold","outstandingWriteCount","nextTxnCallbacks","flushResolvers","batchFlushResolvers","enqueuedEventTurnBatch","lastWritePromise","writeBatchStart","outstandingBatchCount","lastSyncTxnFlush","hasUnresolvedTxns","afterCommitCallbacks","beforeCommitCallbacks","batchDepth","txnResolution","nextResolution","flagPosition","valueBuffer","uncommittedResolution","unwrittenResolution","lastPromisedResolution","lastQueuedResolution","writeInstructions","writeStatus","targetBytes","valueBufferStart","finishBatch","nextUint32","endPosition","keyStartPosition","mustCompress","valueArrayBuffer","resolution","writtenBatchDepth","or","queueCommitResolution","round","startWriting","resolveWrites","unconditional","flushed","clearImmediate","resolvers","Date","now","resolver","isExecuting","txnCallbacks","j","userTxnCallback","asChild","beginTxn","parentTxn","abortTxn","commitTxn","clearWriteTxn","txnError","errors","resumeWriting","executeTxnCallbacks","commitRejectPromise","nextTxn","TXN_DONE","instructionStatus","callbacks","rejectCommit","resolveCommit","afterCommit","queueMicrotask","rejectFunction","commitError","newStatus","atomicStatus","versionOrOptions","noOverwrite","noDupData","append","ifVersionOrValue","ifNoExists","operations","ifLessThan","allowNotFound","finishStartWrite","operation","batch","callbackOrOperations","_triggerError","transactionAsync","callbackDone","finishTxn","thisTxn","childResults","txnIndex","finishWrite","e","transactionSyncStart","onfulfilled","onrejected","hasCallbacks","all","resolvedPromise","resolvedSyncPromise","finalPromise","finalSyncPromise","event","addWriteMethods","supports","permanence","bufferKeys","promises","snapshots","deferredOpen","openCallback","Class","asClass","getFloat64","srcEnd","TextDecoder","EMPTY_ARRAY","currentStructures","srcString","bundledStrings","referenceMap","strings","stringPosition","currentUnpackr","srcStringStart","srcStringEnd","currentExtensions","useRecords","mapsAsObjects","C1Type","C1","readStruct","onLoadedStructures","onSaveState","sequentialMode","inlineObjectReadThreshold","Function","Infinity","sequential","trusted","maxSharedStructures","sharedLength","uninitialized","int64AsNumber","int64AsType","unpack","saveState","clearSource","checkedRead","unpackMultiple","defaultUnpackr","_mergeStructures","loadedStructures","isFrozen","structure","isShared","highByte","existing","restoreStructures","randomAccessStructure","lazy","read","postBundlePosition","jsonView","_","startsWith","incomplete","token","loadStructures","createStructureReader","object","freezeData","freeze","shortStringInJS","longStringInJS","readFixedString","position1","position0","readBin","getUint16","readExt","getFloat32","useFloat32","multiplier","mult10","getBigUint64","BigInt","getInt8","getInt16","getBigInt64","recordDefinition","noBuffer","readString8","readString16","readString32","readArray","readMap","validName","firstId","readObject","createSecondByteReader","read0","readStringJS","isNativeAccelerationEnabled","units","byte2","byte3","apply","existingSrc","byte","c","g","h","k","m","n","readOnlyJSString","readPosition","keyCache","chunk","checkPosition","property","firstByte","existingStructure","TypeError","ReferenceError","refEntry","targetProperties","typedArrays","glbl","typeCode","typedArrayName","RegExp","TEMP_BUNDLE","savedSrcEnd","savedPosition","savedStringPosition","savedSrcStringStart","savedSrcStringEnd","savedSrcString","savedStrings","savedReferenceMap","savedBundledStrings","savedSrc","savedStructures","savedStructuresContents","savedPackr","savedSequentialMode","dataSize","dataPosition","extensions","extensionClasses","f32Array","Float32Array","MAX_BUFFER_SIZE","keysTarget","safeEnd","writeStructSlots","hasNonLatin","RECORD_SYMBOL","hasSharedUpdate","encodeUtf8","packr","isSequential","hasSharedStructures","structuredClone","moreTypes","maxOwnStructures","useTwoByteRecords","sharedLimitId","maxStructureId","recordIdsToRemove","transitionsCount","serializationsSinceTransitionRebuild","pack","encodeOptions","bundleStrings","transitions","nextTransition","transition","lastNamedStructuresLength","nextId","writeStruct","lastBundle","writeBundles","idsToInsert","incrementPosition","insertionPoint","stringsPosition","makeRoom","serialized","distanceToMove","lastEnd","copyWithin","insertIds","returnBuffer","newSharedData","prepareStructures","packArray","headerSize","extStart","maxBytes","setUint16","twoByte","strPosition","setInt16","xShifted","setFloat32","referee","writeObject","mapAsEmptyObject","entryValue","writeResult","currentTarget","currentTargetView","currentPosition","writeExtensionData","json","writeFunction","setBigInt64","setBigUint64","largeBigIntToFloat","encodeUndefinedAsNil","writePlainObject","variableMapSize","coercibleKeyAsNumber","num","isNaN","safePrototype","objectOffset","writeRecord","progressiveRecords","wroteKeys","lastTransition","newTransitions","newRecord","insertNewRecord","recordId","__keys__","checkUseRecords","newSize","shouldShareStructure","nextOwnId","shift","insertionOffset","mainTarget","mainPosition","mainSafeEnd","mainStart","keysPosition","newEnd","insertionPosition","newPosition","notifySharedUpdate","startTarget","useBuffer","typedStructs","writeExtBuffer","typedArray","allocateForWrite","writeBuffer","writeStrings","compatible","getPrototypeOf","date","seconds","getTime","useTimestamp32","getMilliseconds","onInvalidDate","setAsEmptyObject","regex","arrayBuffer","defaultPackr","NEVER","ALWAYS","DECIMAL_ROUND","DECIMAL_FIT","TYPE_NAMES","float32Headers","evalSupported","updatedPosition","currentSource","writeSlots","anyType","ascii8","num8","setInt8","string16","object16","num32","num64","NaN","createTypeTransition","typeName","newTransition","__type","__size","__parent","refsStartPosition","lastStringStart","lastStart","refOffset","refPosition","usedAscii0","queuedReferences","keyIndex","parent","enumerationOffset","ascii0","date64","isNotAscii","strStart","string8","propertyIndex","object32","structMap","lastTypedStructuresLength","sourceSymbol","toConstant","code","withSource","unpackr","construct","lastRefProperty","properties","currentOffset","getRef","ref","multiGetCount","refStart","bytesEnd","fValue","hasInheritedProperties","objectLiteralProperties","args","alwaysLazyProperty","valueFunction","toObject","omitUnderscoredProperties","resolved","instance","sharedData","typed","named","MSGPACKR_NATIVE_ACCELERATION_DISABLED","toLowerCase","extractor","createRequire","extractStrings","headerLength","extraction","srcStringLength","setExtractor","PINNED_IN_MEMORY","NOT_IN_LRU","EXPIRED_ENTRY","LRFUExpirer","lruSize","reset","reference","cleanupInterval","interval","setInterval","expirer","cleanup","clearInterval","unref","startTimedCleanup","lru","lruPosition","lruIndex","originalPosition","bits","insertEntry","nextLru","orMask","previousEntry","cycles","onRemove","toClear","defaultExpirer","hits","misses","cacheSize","clearKeptCount","defaultNoLRUExpirer","deferRegister","registry","FinalizationRegistry","register","incrementClearKeptCount","cleanupSome","oldEntry","insert","getMaxListeners","listenerCount","setMaxListeners","noop","setRequire","v8AccelerationEnabled","majorVersion","minorVersion","v8","nodeCompiledVersion","v8Funcs","fastApiCalls","DISABLE_TURBO_CALLS","setFlagsFromString","enableDirectV8","enableThreadSafeCalls","deactivationEvents","activate","context","asAbsolutePath","deactivate","deactivateME"],"sourceRoot":""}